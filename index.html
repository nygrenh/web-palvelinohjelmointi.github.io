<!DOCTYPE html>
<html>
    <head>
        <title>Web-palvelinohjelmointi</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="js/libs/syntaxhighlight/css/sh_style.css"/>
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
        <link rel="stylesheet" href="css/chartist.min.css"/>
        <link rel="stylesheet" href="css/wepa.css"/>

        <link rel="stylesheet" href="css/wepa-mooc.css"/>

    </head>
    <body>

        <!-- BEGIN NAV -->
        <header role="navigation">
            <h1>
                <button type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>

                <!-- BEGIN MOOC SNIP -->                    
<!--
                <a href="http://www.mooc.fi" class="hidden-in-hy">&#171; mooc.fi</a>
-->
                <!-- END MOOC SNIP -->
                <!-- BEGIN HY SNIP -->                    
                <!-- END HY SNIP -->

                <a href="http://www.cs.helsinki.fi"><img src="img/header_tktl.png" alt="CS Dept. Univ. Helsinki"></a>
		
            </h1>
            <nav class="collapse bs-navbar-collapse" role="navigation">
                <ul>
                    <li>
                        <a href="#viikko1">Viikko 1</a>
                    </li>
                    <li>
                        <a href="#viikko2">Viikko 2</a>
                    </li>
                    <li>
                        <a href="#viikko3">Viikko 3</a>
                    </li>
                    <li>
                        <a href="#viikko4">Viikko 4</a>
                    </li>
<!--
                    <li>
                        <a href="#viikko5">Viikko 5</a>
                    </li>
                    <li>
                        <a href="#viikko6">Viikko 6</a>
                    </li>
                    <li>
                        <a href="#viikko7">Viikko 7</a>
                    </li>
-->
                </ul>

		<div style="direction: rtl;">
		  <button id="logout" class="btn btn-warning">Kirjaudu ulos</button>
		</div>
            </nav>
	    
        </header>
        <!-- // END NAV -->
        <article>


          <div class="modal fade" id="tmcAuthModal" data-backdrop="static" data-keyboard="false"  tabindex="-1" role="dialog" aria-labelledby="tmcAuthModalLabel" aria-hidden="true">
            <div class="modal-dialog">
              <form class="form-inline"  id="TmcLoginForm" role="form">
		<div class="modal-content">
                  <div class="modal-header">
                    <h4 class="modal-title" id="tmcAuthModalLabel">Kirjoita TMC-tunnuksesi</h4>
                  </div>
                  <div class="modal-body">
                    <p>Pyydämme sinua kirjautumaan TMC-tunnuksillasi materiaaliin. Kirjautumistietoja käytetään oppimateriaalin käytön tutkimukseen.</p>
                    <div id="tmc-account-wrong-alert" class="hidden alert alert-danger">Tarkista TMC-tunnuksesi</div>
                    <div class="form-group">
                      <label class="sr-only" for="exampleInputPassword2">TMC-tunnus</label>
                      <input type="text" name="tmcAccountName" class="form-control" id="inputTmcAccount" placeholder="TMC-tunnus">
                    </div>
                  </div>
                  <div class="modal-footer">
                    <button type="button" id="tmcAccountNOACCOUNT" class="btn btn-default" data-dismiss="modal">En halua</button>
                    <button type="submit" name="tmcLoginButton" id="tmcAccountOK" class="btn btn-primary">OK</button>
                  </div>
		</div><!-- /.modal-content -->
              </form>
            </div><!-- /.modal-dialog -->
          </div><!-- /.modal -->
	  

            <section id="intro" class="no-toc weeklimit" data-week-id="-1">Huom! Jos etsit syksyllä 2014 julkaistua web-palvelinohjelmoinnin oppimateriaalia, löytyy se <a href="s2014-wepa.html">täältä</a>.</section>



            <!-- BEGIN INDEX -->
            <section id="intro" class="no-toc weeklimit" data-week-id="0">
                
                <header>

                    <div class="intro-header-img"></div>

                    <h1>Web-palvelinohjelmointi</h1>

                    <p>Voinko oppia tekemään Facebookin, Flickrin tai Twitterin?</p>

                    <a class="call-to-action" href="#start" role="button">No todellakin!</a>

                </header>


<!--
                <div class="hidden">

                    <h1>Sisältö ja aikataulu</h1>

                    <p>Kurssilla tutustutaan nykyaikaisten, skaalautuvien ja virheenkestävien web-sovellusten toteuttamiseen, testaamiseen ja julkaisemiseen. Kurssilla keskitytään palvelinpuolen toiminnallisuuden toteuttamiseen. Selainpuolen toiminnallisuudella on kurssilla hyvin pieni paino. Kurssin opetuskieli on Suomi ja ohjelmointikieli Java. Kurssilla hyödynnetään <a href="http://spring.io/" target="_blank">Spring</a>-sovelluskehystä.</p>

                    <p>Kurssi sisältää seitsemän tehtäväsarjaa, joista ensimmäinen julkaistaan 2. syyskuuta 2014, ja uusia julkaistaan aina viikoittain. Seuraavaan tehtäväsarjaan eteneminen vaatii sen, että tekee vähintään 80% edeltävästä tehtäväsetistä.</p>

                    <p><a class="jump" href="#viikoittaiset-teemat" role="button">Viikoittaiset teemat &raquo;</a></p>

                    <h1>Opettajille ja opiskelijoille</h1>

                    <p>Kurssi vastaa <a href="http://www.cs.helsinki.fi/home/" target="_blank">Helsingin yliopiston tietojenkäsittelytieteen laitoksen</a> kurssia <a href="http://www.cs.helsinki.fi/en/courses/582353" target="_blank">Web-palvelinohjelmointi</a> (5 opintopistettä).</p>

                    <p>Kurssia ja sen materiaalia saa käyttää ja muokata vapaasti, kunhan noudattaa materiaalin <a href="#license">lisenssiä</a>. Jos järjestät kurssista kokeen omassa oppilaitoksessasi, saat tarvittaessa osoitteesta <a href="mailto:mooc@cs.helsinki.fi">mooc@cs.helsinki.fi</a> koepohjan.</p>

                    <p>Jos olet opiskelijana jossain muualla kuin Helsingin yliopistolla ja haluaisit suorittaa kurssin siten, että saat suoritusmerkinnän tai opintopisteet omassa oppilaitoksessasi, etsi omasta oppilaitoksestasi opettaja tai opinto-ohjaaja, joka on valmis valvomaan kokeen ja hyväksymään kurssisuorituksen ja pyydä häntä lähettämään sähköpostia osoitteeseen <a href="mailto:mooc@cs.helsinki.fi">mooc@cs.helsinki.fi</a></p>

                </div>
-->

                <h1 id="start">Sisältö, aikataulu, arvostelu</h1>

                <p>Kurssilla tutustutaan nykyaikaisten, skaalautuvien ja virheenkestävien web-sovellusten toteuttamiseen, testaamiseen ja julkaisemiseen. Kurssilla keskitytään palvelinpuolen toiminnallisuuden toteuttamiseen. Selainpuolen toiminnallisuudella on kurssilla hyvin pieni paino. Kurssin opetuskieli on Suomi ja ohjelmointikieli Java. Kurssilla hyödynnetään <a href="http://spring.io/" target="_blank">Spring</a>-sovelluskehystä.</p>

                <p>Kurssi sisältää seitsemän tehtäväsarjaa. <strong>Ensimmäinen tehtäväsarja julkaistaan 2. syyskuuta 2015</strong>. Uusia tehtäväsarjoja julkaistaan viikoittain. Tehtäväsarjojen viimeiset palautuspäivät löytyvät TMC:stä -- ensimmäisen sarjan viimeinen palautuspäivä on <strong>maanantaina 7.9. klo 16:00</strong>.</p>

                <p>Kurssin arvostelu perustuu viikoittaisiin harjoitustehtäviin, sekä kahteen kokeeseen, joista toinen tehdään kynällä ja paperilla, ja toinen tietokoneella. Kurssin pisteytys on seuraava:</p>

		<ul>
		  <li>Viikoittaisista tehtäväsarjoista saa 100 pistettä viikkoa kohti. Täydet 100 pistettä saa tekemällä 100% viikon tehtävistä. Jos tekee puolet tehtävistä, saa 50 pistettä jne.</li>
		  <li>Paperilla tehtävästä kokeesta on mahdollista saada 250 pistettä.</li>
		  <li>Tietokoneella tehtävästä kokeesta on mahdollista saada 250 pistettä.</li>
		</ul>

		<p>Kurssista voi saada yhteensä 1200 pistettä. Sekä paperilla ja kynällä että tietokoneella tehtävistä kokeista on kummastakin saatava vähintään puolet mahdollisista pisteistä. Kurssin alustavat arvosanarajat ovat seuraavat:</p>

		<ul>
		  <li>700 -> 1</li>
		  <li>800 -> 2</li>
		  <li>900 -> 3</li>
		  <li>1000 -> 4</li>
		  <li>1100 -> 5</li>
		</ul>

                <p><a class="jump" href="#viikoittaiset-teemat" role="button">Viikoittaiset teemat &raquo;</a></p>

                <h1>Esitietovaatimukset ja kurssin suorittaminen</h1>

                <p>Kurssilla oletetaan Java-ohjelmointikielen tuntemus kurssien ohjelmoinnin perusteet ja ohjelmoinnin jatkokurssi laajuudessa. Tämän lisäksi kursseista ohjelmistotekniikan menetelmät, tietokantojen perusteet, ohjelmoinnin harjoitustyö, tietokantasovellus, ja ohjelmistotuotanto on huomattavasti apua.</p>

		<p>Kurssi käyttää TMC-palvelua tehtävien tarkistamisessa. Helsingin yliopistolla järjestettävällä kurssilla TMC-palvelin löytyy osoitteessa <a href="http://tmc.mooc.fi/hy" target="_blank">http://tmc.mooc.fi/hy</a>, kurssin nimenä on <code>hy-s2015-wepa</code>.</p>

		<p>Jos et ole käyttänyt TMC:tä aiemmin, tutustu Ohjelmoinnin perusteiden kurssin ohjeisiin osoitteessa <a href="http://www.cs.helsinki.fi/group/java/s15/" target="_blank">http://www.cs.helsinki.fi/group/java/s15/</a>.</p>

		


                <h2>Luennot ja ohjaus</h2>
		
                <p>Kurssin ainoa luento pidetään keskiviikkona 2.9. kello 14-16 salissa A111.</p>
		
                <p>Kurssilla on kyselymuotoisia ohjaustunteja huoneessa C221 (Linkki) maanantaisin ja perjantaisin kello 12-14. Huoneessa on myös tietokoneita, joilla kurssin tehtäviä voi tehdä.</p>

		<p>Ohjaustunneille tulee ilmoittautua osoitteessa <a href="http://kyselyilmo.herokuapp.com" target="_blank">http://kyselyilmo.herokuapp.com</a> olevan sovelluksen kautta. Jos tunnille ei ole tulossa osallistujia, tuntia ei pidetä.</p> 

		<p>Kurssilla on lisäksi IRC-kanava <code>#wadup</code>, josta löytyy muita kurssilaisia. Muiden auttaminen kanavalla on vapaaehtoista, mutta luonnollisesti suositeltavaa. Auttamisesta hyötyy apua tarvitsevan lisäksi myös auttaja.</p>


                <h1 id="viikoittaiset-teemat">Viikoittaiset teemat -- voivat muuttua kurssin edetessä</h1>


                <ul id="week-toc">
                    <li><a href="#viikko1">Viikko 1</a> Webin peruskomponentit, Spring Bootin alkeet, dynaamiset sivut ja luonnolliset näkymätemplatet, ensimmäinen tietokantasovellus.</li>
                    <li><a href="#viikko2">Viikko 2</a> Palvelinohjelmistojen kerrokset.</li>
                    <li><a href="#viikko3">Viikko 3</a> REST, HTTP ja Sessiot.</li>
                    <li><a href="#viikko4">Viikko 4</a> Palveluorientoituneet arkkitehtuurit, testaamisen perusteet sekä konfiguraatiot.</li>
                    <li><a href="#viikko5">Viikko 5</a> Luonnolliset näkymätemplatet, mediatiedostojen kuten kuvien ja videoiden tallentaminen ja näyttäminen, tietoturva.</li>
                    <li><a href="#viikko6">Viikko 6</a> Web-sovellusten skaalautuminen.</li>
                    <li><a href="#viikko7">Viikko 7</a> Kertaus ja "facebook".</li>
                </ul>


                <h1>Sisällysluettelo</h1>

                <ul class="nav" id="material-toc"></ul>

                <h1>Tehtävät</h1>

                <ul class="nav nav-pills nav-pills-fixed-width" id="tehtavat-toc"></ul>

            </section>
            <!-- END INDEX -->

            <!-- BEGIN WEEK1 -->
            <section class="weeklimit" data-week-id="1">

                <header>
                    <h1 id="viikko1">Viikko 1</h1>
                </header>

                <h1>Aloitus</h1>

                <h2>Web-sovelluksista yleisesti</h2>

                <p>Web-sovellukset koostuvat selain- ja palvelinpuolesta. Käyttäjän koneella toimii selainohjelmisto (esim. <a href="http://chrome.google.com" target="_blank">Google Chrome</a>), jonka kautta käyttäjä tekee pyyntöjä verkossa sijaitsevalle palvelimelle. Kun palvelin vastaanottaa pyynnön, se käsittelee pyynnön ja rakentaa pyynnölle sopivan vastauksen. Vastaus voi sisältää esimerkiksi web-sivun tai tietyssä muodossa olevaa dataa.</p>

                <div class="image">
                    <img src="img/pyynto.png"/>
                    <div>Web-sovellusten käyttäminen: (1) käyttäjä klikkaa linkkiä, (2) selain tekee pyynnön palvelimelle, (3) palvelin käsittelee pyynnön ja rakentaa vastauksen, (4) selaimen tekemään pyyntöön palautetaan vastaus. Vastauksen näyttämistä käyttäjälle ei näytetä tässä kuvassa.</div>
                </div>

                <p>Selainohjelmointiin ja käyttöliittymäpuoleen keskityttäessä painotetaan rakenteen, ulkoasun, ja toiminnallisuuden erottamista toisistaan. Karkeasti voidaan sanoa, että sivun rakenne määritellään <a href="http://en.wikipedia.org/wiki/CSS" target="_blank">HTML</a>-tiedostoilla, ulkoasu <a href="http://en.wikipedia.org/wiki/CSS" target="_blank">CSS</a>-tiedostoilla, ja toiminnallisuus <a href="http://en.wikipedia.org/wiki/JavaScript" target="_blank">JavaScript</a>-tiedostoilla.</p>

                <p>Palvelinpuolen toiminnallisuutta toteutettaessa keskitytään tyypillisesti selainohjelmiston tarvitsevan "APIn" suunnitteluun ja toteutukseen, sivujen muodostamiseen selainohjelmistoa varten, datan tallentamiseen ja käsittelyyn, sekä sellaisten laskentaoperaatioiden toteuttamiseen, joita selainohjelmistossa ei kannata tai voida tehdä.</p>

                <p>Web-sovelluksista puhuttaessa on hyvä erottaa staattiset ja dynaamiset sivut toisistaan. Staattiset sivut ovat sivuja, joiden sisältö on ennalta määrätty, ja jotka palvelin palauttaa suoraan käyttäjälle niitä pyydettäessä. Dynaamiset sivut taas luodaan palvelimella tarvittaessa. Esimerkiksi osoitteessa <a href="http://telkku.com/" target="_blank">http://telkku.com/</a> toimiva web-sovellus luo näytettävän televisio-ohjelmiston dynaamisesti palvelinpuolella: uuden staattisen sivun luominen käsin aina uuden ohjelmatiedon saapuessa olisi erittäin raskasta ja tehotonta. Sivuston tarjoama hakupalvelu mahdollistaa rajattoman määrän erilaisia sivustoja; kukaan ei kirjoittaisi näitä käsin.</p>

                <p>Työpöytäsovelluksia ja web-sovelluksia verrattaessa työpöytäsovellukset tarjoavat enemmän interaktiivisuutta ja nopeutta web-sovelluksiin verraten. Web-sovellukset toisaalta mahdollistavat saumattomat ohjelmistojen päivitykset, helposti jaettavan ja ylläpidettävän datan ja dokumenttien jakamisen, sekä kevyet käyttöliittymät. Olemme viimeisten vuosien aikana todistaneet muutosta, missä web-sovellukset hiljalleen syrjäyttävät perinteiset työpöytäsovellukset, myöskin niissä tapauksissa, joissa sovelluksilla on käyttäjiä vain yksittäisessä paikassa. Tälläkin hetkellä Google tarjoaa kaikille ilmaista toimistotyökalupakettia, elokuvien ja tv-ohjelmien katsominen selainohjelmistossa on helppoa esimerkiksi Yle Areenan tai Netflixin avulla, ja selaimessa pelattavat pelit ovat ohittaneet perinteiset tietokonepelit käyttäjämäärissä jo muutamia vuosia sitten.</p>



                <h2>Ohjelmistojen kehittämisestä</h2>

                <p>Ohjelmistojen kehittämistä verrataan usein naiivisti talojen tai rakennusten rakentamiseen. Taloa suunnitellessa arkkitehdillä on selkeä tehtävä ja etenemissuunnitelma: kerää vaatimukset, tutki vaihtoehtoja, ja luo pohjapiirrustus. Kun arkkitehti on luonut pohjapiirrustuksen, se annetaan urakoitsijalle, jonka pohjalta urakoitsijan palkkaamat työntekijät -- rakennusmiehet -- rakentavat rakennuksen vaadituilla materiaaleilla.</p>

                <p>Ohjelmistoja suunniteltaessa arkkitehti osallistuu sekä ohjelmiston suunnitteluun että kehitykseen, eli rakentamiseen. Koska ohjelmistoista halutaan mahdollisimman nopeasti konkreettista palautetta, arkkitehti aloittaa ohjelmiston suunnittelun perustarpeista: muutamasta huoneesta, joihin palautetta antavat ihmiset muuttavat. Kun alkuperäinen suunnitelma on lähes valmis, rakennukseen muuttaa lisää ihmisiä, jotka tarvitsevat rakennukselta uusia toiminnallisuuksia. Ensisijaisina vaatimuksina ovat uudet huoneet, pesula, disko ja luonnollisesti oleskelutila, jossa on tilaa biljardipöydälle.</p>

                <p>Tällöin arkkitehti muuttaa alkuperäistä suunnitelmaansa ottaen huomioon uudet ihmiset ja kehitystyö jatkuu. Kehitystyön jatkuessa alkuperäiset asukkaat alkavat valittamaan rakennusmelusta ja uhkaavat poismuutolla jos asioihin ei saada muutosta, aiheuttaen hiusten harvenemista arkkitehdille. Toisaalta, sana uudesta biljardipöydästä kiertää, ja yhä enemmän ihmisiä muuttaa rakennukseen, ja rakennukselta vaaditaan taas uusia huoneita sekä cartingrata ja curlinghalli.</p>

                <p>Hyvän suunnittelun perusta on mahdollisuuksien huomiointi. Huomioinnilla ei tarkoiteta sitä, että rakennetaan heti aluksi iso järjestelmä -- käytännössä järjestelmän valmistuessa sille ei olisi käyttäjiä sillä kaikki olisivat siirtyneet toiseen aiemmin tarpeellisia ominaisuuksia tarjonneeseen järjestelmään. Jos alkuperäinen suunnitelma tekee järjestelmän laajentamisesta vaikeaa, käyttäjät saattavat vaihtaa palvelua hitauden takia.</p>

                <p>Kaikkien osapuolten toiveet tyydyttävän ohjelmiston rakentaminen on haastavaa. Jokaista ohjelmistoa joudutaan laajentamaan, rajaamaan ja muokkaamaan. Asiakkaalla tai asiakkailla on käytännössä aina uusia toivomuksia ohjelmiston elinkaaren varrella.</p>

                <p>Arkkitehtuurin tulee mahdollistaa sopivan kokoisesta palasta aloittaminen sekä rakennettavan sovelluksen laajentaminen, myös toisten kehittäjien toimesta. Käytännössä hyvin harvat ohjelmistot ovat vain yhden ihmisen käsialaa, ja laajempaa sovellusta kehitettäessä olemassaolevien ohjelmistokomponenttien hyödyntäminen on oleellista. Ohjelmistoalalla aloittelevan on hyvin vaikea valita sopivia komponentteja olemassaolevasta viidakosta sillä yhtä oikeaa ratkaisua ei yleensä ole.</p>

                <p>Oleelllisinta ohjelmistokehityksessä on kommunikointi niin koodin kautta kuin muita väyliä käyttäen. Avoimeen lähdekoodiin ja online-versionhallintatyökaluihin (esim. GitHub) perustuvat projektit saavat ihmiset eri puolilta maailmaa tekemään työtä yhteisten kiinnostuksenkohteiden takia. Sovittujen käytänteiden (esim. nimeämiskäytänteet, versionhallinta, testaus, dokumentointi ym.) noudattaminen on oleellista sillä heikko suunnittelu ja ylläpidettävyys, esimerkiksi muuttujien huono nimentä, aiheuttavat lähinnä kylmiä väreitä ja ajavat innokkaat ihmiset pois.</p>

                <p>Työkaluja valittaessa tarkoituksena on välttää nurkkaan ajautumista: työkaluista tulee pystyä myös pääsemään eroon. On paljon hyödyllisempää miettiä päivä ja käyttää muutama päivä prototyypin tekemiseen, koska prototyyppiä voidaan parantaa kuukausia, kuin miettiä kuukausi ja sitouttaa itsensä kuukauden aikana luotuun suunnitelmaan. Mitä nopeammin toiminnallisuutta on olemassa, sitä nopeammin siitä saa palautetta.  Toisaalta, mitä vähemmän aikaa yksittäisen toiminnallisuuden toteuttamiseen käytetään, sitä helpommin siitä voi tarpeen vaatiessa hankkiutua eroon.</p>

                <p>Sovelluksia tehdessä, erityisesti prototyyppivaiheessa, otetaankin usein hieman teknistä velkaa ns. "menemällä siitä mistä aita on matalin". Tämä velka maksetaan kuitenkin ennen pitkää takaisin; mitä pidempään sen takaisinmaksussa kestää, sitä suurempi velan korko on.</p> 



                <h2>Kurssin työvälineet</h2>

                <p>Käytämme tällä kurssilla ohjelmointiympäristönä <a href="http://netbeans.org/" target="_blank">NetBeans</a>ia, ohjelmistoprojektien ja komponenttien riippuvuuksien hallintaan <a href="http://maven.apache.org" target="_blank">Maven</a>ia, sekä komentotulkkia. Harjoitustehtävät palautetaan <a href="http://tmc.mooc.fi/hy" target="_blank">Test My Code</a>-palvelimelle NetBeansiin ladattavan Test My Code -liitännäisen avulla.</p>

                <p>Selainpuolella ohjelmistoja tutkitaan <a href="http://chrome.google.com">Google Chrome</a>ssa olevien <a href="https://developers.google.com/chrome-developer-tools/" target="_blank">DevTools</a>ien avulla.</p>

                <h3>NetBeansin ja Test My Coden asennus</h3>

                <p>Test My Coden web-sivu löytyy osoitteesta <a href="http://tmc.mooc.fi/hy">http://tmc.mooc.fi/hy</a>. Valitse sivun ylälaidasta <em>Sign up</em> ja kirjaudu järjestelmään. Jos olet HY:n opiskelija, käytä käyttäjätunnuksena (<em>username</em>) opiskelijanumeroasi, ja anna järjestelmään käyttämäsi sähköpostiosoite. Opiskelijanumeron käyttö opiskelijana on tärkeää: näin tehtävistä saamasi pisteet voidaan liittää sinuun jos osallistut kokeeseen. Kun käyttäjätunnuksesi on luotu ja kirjautuminen onnistuu, jatka eteenpäin.</p>

                <p>NetBeans-sovelluskehitysympäristön ladattua osoitteesta <a href="http://netbeans.org/" target="_blank">http://netbeans.org/</a>. NetBeansin versiota ladattaessa kannattaa valita versio kaikilla mausteilla, eli vaihtoehto "All". Jos NetBeans kysyy haluatko käyttää vanhoja asetuksia sitä käynnistettäessä, kannattaa valita <strong>ei</strong>.</p>

                <p>Test My Code-liitännäisen saa lisättyä NetBeansin pluginvaihtoehdoksi näkyviin valitsemalla Tools -> Plugins. Valitse avautuvasta ikkunasta Settings-välilehti, ja klikkaa uuden liitännäispaikan lisäämiseen tarkoitettua Add-nappia. Anna avautuvaan ikkunaan latauspaikan nimeksi <code>TMC</code>, ja osoitteeksi <code>http://update.testmycode.net/tmc-netbeans_mooc/updates.xml</code>. Valitse lopulta OK.</p>

                <p>Mene tämän jälkeen Available Plugins -välilehdelle ja etsi sieltä vaihtoehto Test My Code NetBeans Plugin. Klikkaa sen vasemmalla puolella olevaa laatikkoa, ja painaa Install. Tämä asentaa Test My Coden NetBeansiisi.</p>

                <p>Kun Test My Code on asentunut, NetBeans haluaa käynnistyä uudestaan. Käynnistä NetBeans uudestaan. Tämän jälkeen NetBeansin valikossa on myös vaihtoehto Test My Code. Käy vielä asettamassa Test My Coden asetukset. Valitse TMC -> Settings, ja täytä avautuvaan ikkunaan tietosi. Käyttäjätunnus on TMC-tunnuksesi, salasanasi TMC:hen liittyvä salasanasi. Valitse kurssiksi <em>opettajalta saamasi tunnus</em>.</p>

                <p>Varmista että myös alaosassa olevat vaihtoehdot ovat valittuina ja paina OK (kurssin kehittämisen kannalta on erittäin tärkeää, että viimeinen vaihtoehto "Send snapshots of your progress for study" on valittu). Tämän jälkeen NetBeans kysyy sinulta ladataanko saatavilla olevat tehtävät. Valitse "Download".</p>

                <p>NetBeans lataa tehtävät, jonka jälkeen ne ovat näkyvissä NetBeans-projekteina. Pieni musta pallo projektin ikonissa tarkoittaa että tehtävää ei ole vielä yritetty. Jos pallo on vihreä, on tehtävästä kerätty kaikki pisteet.</p>



                <h3>Ohjelmistoprojektien hallinta ja Maven</h3>

                <p>Jokaisessa ohjelmistoprojektissa tulee vastaan erilaisia lähdekoodiin liittyviä tarpeita. Lähdekoodia tulee pystyä paketoimaan tuotantopalvelimelle siirettäväksi paketiksi (esim -.jar ja -.war -tiedostot), lähdekoodiin liittyviä testejä tulee pystyä ajamaan erillisellä palvelimella ja lähdekoodista tulee pystyä generoimaan erilaisia raportteja sekä luonnollisesti dokumentaatiota.</p>

                <p>Työkalut kuten <em><a href="http://ant.apache.org/" target="_blank">Apache Ant</a></em> auttavat projektiin liittyvän lähdekoodin hallinnoinnissa ja kääntämisessä. Ant on käytännössä 2000-luvun alun vastine perinteisille Makefile-tiedostoille. Nykyaikaisemmat <em><a href="http://maven.apache.org/" target="_blank">Apache Maven</a></em> ja <em><a href="http://www.gradle.org/" target="_blank">Gradle</a></em> auttavat käännösprosessin lisäksi muunmuassa projektiin liittyvien kirjastoriippuvuuksien automaattisessa hallinnassa. Käytämme tällä kurssilla Mavenia.</p>

                <p>Apache Maven on projektinhallintatyökalu, jota voi käyttää ohjelmakoodikäännösten lisäksi lähes koko projektin elinkaaren hallintaan uuden projektin aloittamisesta lähtien. Maven tarjoaa ohjelmiston elinkaaren hallintaan joukon valmiiksi konfiguroituja vaiheita (<em>phase</em>), joita voidaan suorittaa komentoriviltä. Usein käytettäviä vaiheita ovat mm. <em>test</em>, joka suorittaa projektiin liittyvät testit sekä <em>package</em>, joka paketoi lähdekoodin projektityypistä riippuen sopivaan pakettiin. Oikeastaan Maven on sovelluskehys liitännäisten suoritukseen ja yksinkertaisimmatkin Mavenin tarjoamat toiminnot ovat toteutettu liitännäisinä.</p>

                <p>Jokaisella Maven-projektilla on elinkaari, joka sisältää vaiheet lähtien projektin validoinnista, kääntämisestä ja testaamisesta aina tuotantoon siirtämiseen asti. Tarkempi listaus projektin erilaisista vaiheista löytyy Mavenin <a href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#Lifecycle_Reference" target="_blank">dokumentaatiosta</a>. Kukin vaihe koostuu yhdestä tai useammasta tavoitteesta (<em>goal</em>), jotka suoritetaan vaiheen sisällä. Vaiheet riippuvat myös edellisistä vaiheista; esimerkiksi vaihetta <em>test</em> suoritettaessa Maven suorittaa ensin projektin validoinnin ja kääntämisen.</p>

                <p>Mavenin liitännäisarkkitehtuuri mahdollistaa hyvin monipuolisen toiminnallisuuden. Esimerkiksi raportointia ja staattista koodianalyysiä varten löytyy omat liitännäiset, samoin kuin mahdollisen (web-)palvelimen käynnistämiselle projektin testausta varten. Liitännäisistä löytyy (ei kattava) lista osoitteessa <a href="http://maven.apache.org/plugins/index.html" target="_blank">http://maven.apache.org/plugins/index.html</a>.</p>

                <p>Maven automatisoi uusien projektien luomisen <em>archetype</em>-liitännäisellä. Archetype-liitännäisen avulla ohjelmistokehittäjät voivat tarjota toisilleen valmiita projektirunkoja ja esimerkiksi määritellä yrityksen teknologiavalinnat paketiksi, jonka pohjalta uuden sovelluksen kehittäminen on nopeaa.</p>

                <p>Yksi Mavenin tärkeimmistä ominaisuuksista on tarvittavien kirjastojen eli riippuvuuksien automaattinen lataaminen. Mavenin avulla projektiin voi määritellä riippuvuuden esimerkiksi yksikkötestauskirjastoihin ja käytetyn web-sovelluskehyksen kirjastoihin. Tällöin Maven lataa riippuvuudet automaattisesti ja kirjastoja ei tarvitse pitää esimerkiksi projektikohtaisessa tai paikallisessa versionhallintajärjestelmässä.</p>



                <h3>Mavenin projektirakenne</h3>

                <p>Mavenin archetype-pluginia käyttäen uuden projektin luonti tapahtuu helposti. Luodaan uusi projekti, jota tarkastelemme seuraavaksi. Uuden projektin luominen onnistuu komentoriviltä esimerkiksi seuraavan komennon avulla.</p>

                <pre>mvn archetype:generate -DgroupId=fi.organisaatio -DartifactId=sovelluksen-nimi</pre>

                <p>Käytännössä komennossa <code>mvn archetype:generate</code> kutsutaan Mavenin archetype-liitännäiseen liittyvää tavoitetta <code>generate</code> ja annetaan sille kaksi parametria. Parametrilla <code>-DgroupId</code> kerrotaan katto-organisaation tai ryhmän tunnus, parametrilla <code>-DartifactId</code> kerrotaan luotavan sovelluksen nimi.</p>

                <p>Komento hakee archetype-pluginista valmit projektipohjat, ja kysyy ensin mitä pohjaa haluat käyttää. Tämän jälkeen Maven kyselee muita tietoja luotavasta projektista. Koska haluamme vain tutustua tässä Mavenin projektirakenteeseen, vastaillaan kysymyksiin enter-painalluksilla. Tällöin Maven käyttää oletusvastauksia.</p>

                <p>Kun projekti on luotu, sillä on seuraavanlainen kansiorakenne.</p>

                <pre>
sovelluksen-nimi
 ├── pom.xml
 └── src
     ├── main
     │   └── java
     │       └── fi
     │           └── organisaatio
     │               └── App.java
     └── test
         └── java
             └── fi
                 └── organisaatio
                     └── AppTest.java
                </pre>

                <p>Sovelluksen ja testien lähdekoodit ovat eritelty erillisiin kansioihin. Projektin alla olevassa kansiossa <code>src</code> on projektiin liittyvät lähdekoodit. Kansion <code>src</code> alla on kansiot <code>main</code> ja <code>test</code>, joissa toisessa on projektiin liittyvää koodia, ja toisessa projektiin liittyvät testit. Maven-projektin konfiguraatiotiedosto <code>pom.xml</code> on projektin juuressa.</p>

                <p>Projektin luominen valmiista archetype-projekstista onnistuu myös NetBeansissa. Valitsemalle File -&gt; New Project pääsee projektivalikkoon, josta löytyy kategoria Maven. Kun vaihtoehto "Project from Archetype" valitaan käyttäjä pääsee selaamaan saatavilla olevia vaihtoehtoja. Archetypen valinnan jälkeen projektille annetaan nimi ja aloitetaan sovelluksen kehittäminen. </p>


                <h3>Mavenin "pom.xml": Project Object Model</h3>

                <p>Tiedoston pom.xml osa <strong>pom</strong> tulee sanoista <em>Project Object Model</em>. XML-muotoinen pom-tiedosto sisältää projektiin liittyvän rakenteen, asetukset, kirjastoriippuvuudet ja tarvittaessa määritellyt tavoitteet. Yksinkertaisimmillaan pom.xml -tiedosto sisältää kuvauksen organisaatiosta, projektin nimestä, versiosta ja lähdekoodin pakkausmuodosta. Edellisessä osiossa komentorivillä luodun projektin pom.xml -sisältö näyttää seuraavalta.</p>

                <pre class="sh_xml">
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;groupId&gt;fi.organisaatio&lt;/groupId&gt;
  &lt;artifactId&gt;sovelluksen-nimi&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;name&gt;sovelluksen-nimi&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;

  &lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
  &lt;/properties&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</pre>

                <p>Alussa on XML-tiedoston otsake, joka määrittelee käytetyn <a href="http://www.w3schools.com/schema/schema_intro.asp" target="_blank">XML-skeeman</a>. Tämän jälkeen määritellään projektin tiedot (groupId = ryhmä, artifactId = projekti, version = projektin versio, packaging = pakkausmuoto). Tämän jälkeen tulee sovelluksen nimi (usein sama kuin projekti), sekä projektiin liittyvä osoite. Näitä seuraa projektiin liittyvät asetukset – yllä olevassa tiedostossa on määritelty projekti käyttämään UTF-8 -merkistökoodausta.</p>

                <p>Dependencies-osiossa määritellään kirjastot, joita projekti tarvitsee. Esimerkissä projektille on määritelty riippuvuus yksikkötestauksessa käytettävään JUnit-sovelluskirjastoon, jonka Maven lataa automaattisesti. Riippuvuuden <code>scope</code>-osiolla voidaan määritellä vaihe, johon riippuvuus liittyy. Yllä olevassa esimerkissä JUnit-kirjastoa on käytössä vain <code>test</code>-vaiheessa. Käytännössä siis JUnit on käytössä vain testausta varten, mutta se ei tule olemaan mukana asiakkaalle lähetettävässä valmiissa sovelluksessa.</p>

                <aside class="extra">
                    <h1>XML?!</h1>

                    <p>XML (Extensible Markup Language) on laitteistoriippumaton tapa tiedon tallentamiseen siten, että tallennusmuodossa välittyy myös tiedon rakenne. XML-dokumentteja käytetään mm. grafiikan (SVG), tekstidokumenttien (OOXML) ja erilaisten asetustiedostojen tallentamiseen. Tällä kurssilla XML esiintyy projektien asetuksia muokatessa.</p>

                    <p><a href="http://www.w3schools.com/xml/xml_whatis.asp" target="_blank">W3Schoolsin XML-opas</a></p>
                </aside>


                <h3>Maven ja riippuvuuksien hallinta</h3>


                <p>Projektikonfiguraatiossa (<code>pom.xml</code>) olevassa dependencies-osiossa määritellään kirjastot, joita projekti käyttää. Riippuvuuksia ei ole pakko olla yhtäkään, tai niitä voi olla useita. Käytettävät kirjastot riippuvat usein myös muista kirjastoista. Maven (versiosta 2 lähtien) lataa automaattisesti myös käytettävien kirjastojen tarvitsemat riippuvuudet: esimerkiksi JUnit-kirjaston uusin versio tarvitsee avukseen hamcrest-nimisen kirjaston (kts. "This artifact depends on..." osoitteessa <a href="http://mvnrepository.com/artifact/junit/junit/4.11" target="_blank">http://mvnrepository.com/artifact/junit/junit/4.11</a>). Voimme kuitenkin määritellä riippuvuudeksi JUnit-kirjaston ja antaa Mavenin hoitaa loput. </p>

                <p>Projekti voi myös periä jonkun toisen projektin konfiguraation. Elementti &lt;parent&gt; kertoo perittävän komponentin tiedot. Esimerkiksi, seuraavalla konfiguraatiolla kerromme, että perimme <code>spring.framework.boot</code>-ryhmän <code>spring-boot-starter-parent</code> -projektin version <code>1.1.6.RELEASE</code>.</p>

                <pre class="sh_xml">
  &lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;1.1.6.RELEASE&lt;/version&gt;
  &lt;/parent&gt;</pre>

                <p>Lisää tietoa riippuvuuksien hallinnasta löytyy mavenin <a href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html" target="_blank">dokumentaatiosta</a>. Hyviä paikkoja kirjastojen etsimiseen ovat muun muassa <a href="http://search.maven.org/" target="_blank">http://search.maven.org/</a> ja <a href="http://mvnrepository.com/" target="_blank">http://mvnrepository.com/</a>.</p>


                <h3>Mavenin valmiita komentoja</h3>

                <p>Kirjoittaessamme pom.xml-tiedoston sisältävässä kansiossa komennon <code>mvn</code>, näemme viestin, joka valittaa komennon puuttumisesta. Viestin konkreettinen sisältö riippuu mavenin versiosta, esimerkiksi mavenin versiossa 2 oleellinen sisältö on seuraavanlainen. Kolmosversiossa viesti on vaikealukuisempi...</p>

                <pre>
$ mvn
...
You must specify at least one goal or lifecycle phase to perform build steps.
The following list illustrates some commonly used build commands:

  mvn clean
    Deletes any build output (e.g. class files or JARs).
  mvn test
    Runs the unit tests for the project.
  mvn install
    Copies the project artifacts into your local repository.
  mvn deploy
    Copies the project artifacts into the remote repository.
  mvn site
    Creates project documentation (e.g. reports or Javadoc).

Please see
http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html
for a complete description of available lifecycle phases.
...
                </pre>


                <p>Selaamalla osoitteeseen <a href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html" target="_blank">http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html</a> näemme tarkemman listan toiminnoista, joita maven tarjoaa ohjelmistoprojektin eri vaiheisiin.</p>

                <h3>Testien suorittaminen</h3>

                <p>Projektiin liittyvät testit suoritetaan käyttämällä mavenin vaihetta <code>test</code>. Käytännössä kukin vaihe liittyy johonkin tiettyyn pluginiin, esimerkiksi test-vaiheessa suoritetaan <code><a href="http://maven.apache.org/plugins/maven-surefire-plugin/" target="_blank">surefire</a></code>-pluginin tavoite <code>test</code>. Lisätietoja vaiheiden oletusplugineista löytyy <a href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#Setting_Up_Your_Project_to_Use_the_Build_Lifecycle" target="_blank">täältä</a>.</p>

                <p>Suoritetaan testit antamalla projektikansiossa komento <code>mvn test</code> (saman voi tehdä myös NetBeansissa valitsemalla projektin oikealla hiiren napilla ja painamalla "Test").</p>

                <pre>
$ mvn test
// tulostusta...
[INFO] ------------------------------------------------------------------------
[INFO] Building sovelluksen-nimi 1.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
// tulostusta...
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running fi.organisaatio.AppTest
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.016 sec

Results :

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0

[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
// tulostusta
                </pre>

                <p>Käytännössä projektiin liittyvät testitiedostot, joita komentorivin kautta luomassamme esimerkkiprojektissa on vain 1, suoritetaan. Jos testeissä on ongelmia, mavenista pääsee käsiksi niihin liittyviin raportteihin.</p>

                <p>Projektin konfiguraation muokkaus on helppoa kun tietää mitä tekee. Esimerkiksi yksikkötestauskirjaston JUnit version vaihtaminen vanhasta versiosta 3.8.1 versioon 4.11 onnistuu helposti. Käytännössä vain <code>version</code>-tägin sisältö tulee vaihtaa:</p>


                <pre class="sh_xml">
  ...
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;4.11&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  ...
                </pre>

                <p>Jos testit suoritetaan nyt uudestaan komennolla <code>mvn test</code>, huomataan että Maven lataa JUnit-version 4.11 käyttöösi. Koska JUnit on taaksepäin yhteensopiva, testit menevät läpi.</p>

                <aside class="extra">

                    <h1>Riippuvuuksien lataamisen manuaalinen käynnistäminen NetBeansissa</h1>

                    <p>Jos NetBeans-projektin kuvakkeessa on keltainen kolmio sekä lähdekoodikansioissa mahdollinen punainen pallo, saat lisätietoa ongelmasta viemällä hiiren projektin nimen päälle.</p>

                    <p>Jos ongelmana näkyy teksti "Some dependency artifacts are not in the local repository.", eli osaa riippuvuuksista ei ole ladattu paikalliselle koneelle, voit valita oikealla hiirennäppäimellä Dependencies ja "Download Declared Dependencies". Nyt NetBeans pyytää Mavenia lataamaan riippuvuudet.</p>

                    <p>Riippuvuudet ladataan käyttäjän kotihakemiston alla olevaan kansioon ".m2".</p>

                </aside>


                <h1>Webin peruskomponentit</h1>

                <p><em>"I just had to take the hypertext idea and connect it to the TCP and DNS ideas and – ta-da! – the World Wide Web."</em> -- <a href="http://en.wikipedia.org/wiki/Tim_Berners-Lee" target="_blank">Tim Berners-Lee</a></p>


                <p>Webin peruskomponentit ovat (1) URI (<em>Uniform Resource Identifier</em>) ja DNS (<em>Domain Name Services</em>) , jotka mahdollistavat resurssien ja palveluiden yksilöinnin, (2) HTTP (<em>HyperText Transfer Protocol</em>), joka on protokolla viestien lähetykseen verkon yli, sekä (3) HTML (<em>HyperText Markup Language</em>), eli yhteinen dokumenttien esityskieli.</p>

                <h2>URI ja DNS</h2>

                <p><em>"The most important thing that was new was the idea of URI-or URL, that any piece of information anywhere should have an identifier, which will allow you to get hold of it."</em> -- Tim Berners-Lee</p>

                <p>Verkossa sijaitseva sivusto tunnistetaan sille annetun yksilöivän osoitteen perusteella. Osoite (URI eli Uniform Resource Identifier, terminä käyttöön jäänyt URL <em>Uniform Resource Locator</em>) koostuu resurssin nimestä ja sijainnista, joiden perusteella haluttu palvelin ja resurssi voidaan löytää verkossa olevien koneiden massasta.</p>

                <p>Kun käyttäjä kirjoittaa web-selaimen osoitekenttään URIn ja painaa enteriä, web-selain tekee kyselyn annettuun osoitteeseen. Koska tekstimuotoiset osoitteet ovat käytännössä vain ihmisiä varten, kääntää selain ensiksi halutun osoitteen numeeriseksi IP-osoitteeksi. Jos IP-osoite on jo tiedossa esimerkiksi aiemmin osoitteeseen tehdyn kyselyjen takia, selain voi ottaa yhteyden IP-osoitteeseen. Jos taas IP-osoite ei ole tiedossa, tulee selaimen ensin tehdä kysely <a href="http://fi.wikipedia.org/wiki/DNS" target="_blank">DNS</a>-palvelimelle (<em>Domain Name System</em>), jonka tehtävänä on muuntaa tekstuaaliset osoitteet IP-osoitteiksi (esim. Tietojenkäsittelytieteen laitoksen kotisivu <code>http://www.cs.helsinki.fi</code> on IP-osoitteessa <code>128.214.166.78</code>). Ilman DNS-palvelimia ihmisten tulisi muistaa IP-osoitteet ulkoa, joka käytännössä tarkoittaisi ettei nykyinen internet toimisi.</p>

                <p>IP-osoitteet yksilöivät tietokoneet ja mahdollistavat koneiden löytämisen verkon yli. Käytännössä yhteys IP-osoitteen määrittelemään koneeseen avataan sovellustason HTTP-protokollan avulla kuljetustason TCP-protokollan yli. TCP-protokollan tehtävänä on varmistaa, että viestit pääsevät perille. Lisää tietoa konkreettisesta tietoliikenteestä kurssilla <a href="http://www.cs.helsinki.fi/courses/582202" target="_blank">Tietoliikenteen perusteet</a>.</p>

                <p>Käytännössä URIt näyttävät seuraavilta:</p>

                <pre>
protokolla://isäntäkone[:portti]/polku/../[kohdedokumentti][?kyselyparametrit][#ankkuri]
                </pre>

                <p>
                <ul>
                    <li>protokolla: kyselyssä käytettävä protokolla, esimerkiksi HTTP, FTP tai SSH.</li>
                    <li>isäntäkone: kone tai palvelin johon luodaan yhteys. Voi olla joko IP-osoite tai tekstuaalinen kuvaus (esim www.cs.helsinki.fi).</li>
                    <li>portti: portti isäntäkoneella johon yhteys luodaan. HTTP-palvelimien oletusportti on 80. Jos palvelin käyttää eri porttinumeroa kuin 80, tulee se merkitä osoitteeseen. Portti käytännössä määrittelee prosessin, johon yritetään ottaa yhteyttä.</li>
                    <li>polku: periaatteessa polku resurssiin palvelimella. Käytännössä (nykyään) palvelun osoite, johon palvelin osaa osoittaa. Usein palvelut toimivat erillisessä koneessa sisäverkossa, ja ulkoverkkoon näkyvä kone vain toimii ohjaajana eli proxynä oikeaan palveluun.</li>
                    <li>kohdedokumentti: haettava resurssi, jos kohdedokumenttia ei ole määritelty palvelin päättelee oletusdokumentin. Usein index.html</li>
                    <li>kyselyparametrit: koostuu avain-arvo -pareista, joiden avulla palvelimelle pystyy toteuttamaan lisätoiminnallisuutta. Kuhunkin avaimeen liittyvä arvo esitetään = -merkillä, avain-arvo -parit erotetaan toisistaan &-merkillä.</li>
                    <li>ankkuri: kertoo mihin kohtaan dokumentissa tulee mennä.</li>
                </ul>
                </p>

                <aside class="pohdi">
                    <h1>Osoitteen osat</h1>

                    <p>Tutki osoitetta <a href="http://www.googlefight.com/index.php?lang=en_GB&word1=Batman&word2=Superman" target="_blank">http://www.googlefight.com/index.php?lang=en_GB&word1=Batman&word2=Superman</a>. Mitkä tai mikä ovat/on osoitteen:</p>

                    <ul>
                        <li>protokolla</li>
                        <li>isäntäkone</li>
                        <li>portti</li>
                        <li>polku</li>
                        <li>kohdedokumentti</li>
                        <li>kyselyparametrit</li>
                        <li>ankkuri</li>
                    </ul>

                    <p>Mitkä näistä puuttuvat?</p>
                </aside>


                <h2>HTTP</h2>

                <p>HTTP (<em>HyperText Transfer Protocol</em>) on TCP/IP -protokollapinon sovellustason protokolla, jota web-palvelimet ja selaimet käyttävät kommunikointiin. HTTP-protokolla perustuu asiakas-palvelin malliin, jossa jokaista pyyntöä kohden on yksi vastaus (<em>request-response paradigm</em>). Käytännössä HTTP-asiakasohjelma (jatkossa selain) lähettää HTTP-viestin HTTP-palvelimelle (jatkossa palvelin), joka palauttaa HTTP-vastauksen. HTTP-protokollan versio 1.1 on määritelty <a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html" target="_blank">RFC 2616</a>-spesifikaatiossa.</p>

                <h5>Asiakas-palvelin malli</h5>

                <p>Asiakas-palvelin -mallissa <em>(Client-Server model)</em> asiakkaat käyttävät palvelimen tarjoamia palveluja. Kommunikointi asiakkaan ja palvelimen välillä tapahtuu usein verkon yli siten, että asiakasohjelmisto ja palvelinohjelmisto sijaitsevat erillisissä fyysisissä sijainneissa (eri tietokoneilla). Palvelinohjelmisto tarjoaa yhden tai useamman palvelun, joita asiakasohjelmisto käyttää.</p>

                <p>Käytännössä asiakasohjelmisto tarjoaa käyttöliittymän ohjelmiston käyttäjälle. Asiakasohjelmiston käyttäjän ei tarvitse tietää, että kaikki käytetty tieto ei ole hänen koneella. Käyttäjän tehdessä toiminnon asiakasohjelmisto pyytää tarpeen vaatiessa palvelimelta käyttäjän tarpeeseen liittyvää lisätietoa. Tyypillistä mallille on se, että palvelin tarjoaa vain asiakkaan pyytämät tiedot ja verkossa liikkuvan tiedon määrä pidetään vähäisenä.</p>

                <p>Asiakas-palvelin -malli mahdollistaa hajautetut ohjelmistot: asiakasohjelmistoa käyttävät loppukäyttäjät voivat sijaita eri puolilla maapalloa palvelinohjelmiston sijaitessa tietyssä paikassa.</p>


                <aside class="pohdi">
                    <h1>Chuck Norris</h1>

                    <p>Selaa osoitteeseen <a href="http://www.imdb.com" target="_blank">http://www.imdb.com</a>. Kirjoita sivuston ylälaidassa olevaan kenttään "Chuck Norris" ja paina Enter. Mitkä seuraavista askeleista tapahtuivat asiakasohjelmistossa, mitkä palvelinohjelmistossa, mitkä muualla? Voit olettaa että asiakasohjelmistolla tarkoitetaan käyttämääsi web-selainta.</p>

                    <ol>
                        <li>Näppäimistön avulla kirjoittamasi osoitetekstin näyttäminen.</li>
                        <li>Osoitetta http://www.imdb.com vastaavan IP-osoitteen etsiminen.</li>
                        <li>Sivun http://www.imdb.com näyttäminen.</li>
                        <li><span title="YOU CAN'T FIND CHUCK NORRIS, CHUCK NORRIS FINDS YOU">Chuck Norriksen etsiminen.</span></li>
                    </ol>
                </aside>

                <p>Haasteena perinteisessä asiakas-palvelin mallissa on se, että palvelin sijaitsee yleensä tietyssä keskitetyssä sijainnissa. Keskitetyillä palveluilla on mahdollisuus ylikuormittua asiakasmäärän kasvaessa. Kapasiteettia rajoittavat muun muassa palvelimen fyysinen kapasiteetti (rauta), palvelimeen yhteydessä olevan verkon laatu ja nopeus, sekä tarjotun palvelun tyyppi. Esimerkiksi pyynnöt, jotka johtavat tiedon tallentamiseen, vievät tyypillisesti enemmän resursseja kuin pyynnöt, jotka tarvitsevat vain staattista sisältöä.</p>


                <h3>HTTP-viestin rakenne: palvelimelle lähetettävä kysely</h3>

                <p>HTTP-protokollan yli lähetettävät viestit ovat tekstimuotoisia. Viestit koostuvat riveistä jotka muodostavat otsakkeen, sekä riveistä jotka muodostavat viestin rungon. Viestin runkoa ei ole pakko olla olemassa. Viestin loppuminen ilmoitetaan kahdella peräkkäisellä rivinvaihdolla.</p>

                <p>Palvelimelle lähetettävän viestin, eli kyselyn, ensimmäisellä rivillä on pyyntötapa, halutun resurssin polku ja HTTP-protokollan versionumero.</p>

                <pre>
PYYNTÖTAPA /POLKU_HALUTTUUN_RESURSSIIN HTTP/versio
otsake-1: arvo
otsake-2: arvo

valinnainen viestin runko</pre>

                <p>Pyyntötapa ilmaisee HTTP-protokollassa käytettävän pyynnön tavan (esim. <code>GET</code> tai <code>POST</code>), polku haluttuun resurssiin kertoo haettavan resurssin sijainnin palvelimella (esim. <code>/index.html</code>), ja HTTP-versio kertoo käytettävän version (esim. <code>HTTP/1.0</code>). Alla esimerkki hyvin yksinkertaisesta -- joskin yleisestä -- pyynnöstä. Huomaa että pyyntöä tehdessä yhteys palvelimeen on jo muodostettu, eli palvelimen osoitetta ei merkitä erikseen.</p>

                <pre>
GET /index.html HTTP/1.0</pre>

                <p>Yksittäisen koneen dedikointi web-palvelimeksi jättää usein huomattavan osan koneen kapasiteetista käyttämättä. Nykyään yleisesti käytössä oleva HTTP/1.1 -protokolla mahdollistaa useamman palvelimen pitämisen samassa IP-osoitteessa virtuaalipalvelintekniikan avulla, jolloin yksittäiset palvelinkoneet voivat sisältää useita palvelimia. Käytännössä IP-osoitetta kuunteleva kone voi joko itsessään sisältää useita ohjelmistoilla emuloituja palvelimia, tai se voi toimia reitittimenä ja ohjata pyynnön tietylle esimerkiksi yrityksen sisäverkossa sijaitsevalle koneelle. Kun yksittäinen IP-osoite voi sisältää useampia palvelimia, pelkkä polku haluttuun resurssiin ei riitä oikean resurssin löytämiseen: resurssi voisi olla millä tahansa koneeseen liittyvällä virtuaalipalvelimella. HTTP/1.1 -protokollassa on pyynnöissä pakko olla mukana käytetyn palvelimen osoitteen kertova <code>Host</code>-otsake.</p>

                <pre>
GET /index.html HTTP/1.1
Host: www.munpalvelin.net</pre>

                <h3>HTTP-viestin rakenne: palvelimelta saapuva vastaus</h3>

                <p>Palvelimelle tehtyyn pyyntöön saadaan aina jonkinlainen vastaus. Jos tekstimuotoiseen osoitteeseen ei ole liitetty IP-osoitetta DNS-palvelimilla, selain ilmoittaa ettei palvelinta löydy. Jos palvelin löytyy, ja pyyntö saadaan tehtyä palvelimelle asti, tulee palvelimen myös vastata jollain tavalla.</p>

                <p>Palvelimelta saatavan vastauksen sisältö on seuraavanlainen. Ensimmäisellä rivillä HTTP-protokollan versio, viestiin liittyvä statuskoodi, sekä statuskoodin selvennys. Tämän jälkeen on joukko otsakkeita, tyhjä rivi, ja mahdollinen vastausrunko. Vastausrunko ei ole pakollinen.</p>

                <pre>
HTTP/versio statuskoodi selvennys
otsake-1: arvo
otsake-2: arvo

valinnainen vastauksen runko
                </pre>

                <p>Esimerkiksi:</p>

                <pre>
HTTP/1.1 200 OK
Date: Mon, 01 Sep 2014 03:12:45 GMT
Server: Apache/2.2.14 (Ubuntu)
Vary: Accept-Encoding
Content-Length: 973
Connection: close
Content-Type: text/html;charset=UTF-8

.. runko ..</pre>

                <p>Kun palvelin vastaanottaa tiettyyn resurssiin liittyvän pyynnön, tekee se resurssiin mahdollisesti liittyviä toimintoja ja palauttaa lopulta vastauksen. Kun selain saa vastauksen, tarkistaa se vastaukseen liittyvän <a href="http://httpcats.herokuapp.com/" target="_blank">statuskoodin</a> ja siihen liittyvät tiedot. Tämän jälkeen selain päättelee, mitä vastauksella tehdään, ja esimerkiksi tuottaa vastaukseen liittyvän web-sivun käyttäjälle.</p>

                <aside class="extra">
                    <p><strong>Google Dev Tools</strong></p>

                    <p>Google Chromen DevTools-apuvälineet löytää Tools-valikosta tai painamalla F12 (Linux). Apuvälineillä voi esimerkiksi tarkastella verkkoliikennettä ja lähetettyjä ja vastaanotettuja paketteja. Valitsemalla työvälineistä Network-välilehden, ja lataamalla sivun uudestaan, näet kaikki sivua varten ladattavat osat sekä kunkin osan lataamiseen kuluneen ajan.</p>

                </aside>

                <h3>Statuskoodit</h3>

                <p>Statuskoodit (<em>status code</em>) kuvaavat palvelimella tapahtunutta toimintaa kolmella numerolla. Statuskoodien avulla palvelin kertoo mahdollisista ongelmista tai tarvittavista lisätoimenpiteistä. Yleisin statuskoodi on <code>200</code>, joka kertoo kaiken onnistuneen oikein. HTTP/1.1 sisältää viisi kategoriaa vastausviesteihin.</p>

                <ul>
                    <li>1**: informaatioviestit (esim 100 "Continue")</li>
                    <li>2**: onnistuneet tapahtumat (esim 200 "OK")</li>
                    <li>3**: asiakasohjelmistolta tarvitaan lisätoimintoja (esim 301 "Moved Permanently" tai 304 "Not Modified" eli hae välimuistista)</li>
                    <li>4**: virhe pyynnössä tai erikoistilanne (esim 401 "Not Authorized" ja 404 "Not Found")</li>
                    <li>5**: virhe palvelimella (esim 500 "Internal Server Error")</li>
                </ul>

                <p>Humoristisia kuvia statuskoodeista löytyy osoitteesta <a href="http://httpcats.herokuapp.com" target="_blank">http://httpcats.herokuapp.com</a>.</p>


                <aside class="extra">
                    <h1>HTTP-liikenteen testaaminen telnet-työvälineellä</h1>

                    <p>Linux-ympäristöissä on käytössä telnet-työkalu, jota voi käyttää yksinkertaisena asiakasohjelmistona pyyntöjen simulointiin. Telnet-yhteyden tietyn koneen tiettyyn porttiin saa luotua komennolla <code>telnet isäntäkone portti</code>. Esimerkiksi TKTL:n www-palvelimelle saa yhteyden seuraavasti:</p>

                    <pre>
$ telnet cs.helsinki.fi 80
                    </pre>

                    <p>Tätä seuraa telnetin infoa yhteyden muodostamisesta, jonka jälkeen pääsee kirjoittamaan pyynnön.</p>

                    <pre>
Trying 128.214.166.78...
Connected to cs.helsinki.fi.
Escape character is '^]'.

                    </pre>

                    <p>Yritetään pyytää HTTP/1.1 -protokollalla juuridokumenttia. Huom! HTTP/1.1 -protokollassa tulee pyyntöön lisätä aina Host-otsake. Jos yhteys katkaistaan ennen kuin olet saanut kirjoitettua viestisi loppuun, ota apuusi tekstieditori ja copy-paste. Muistathan myös että viesti lopetetaan aina kahdella rivinvaihdolla.</p>

                    <pre>
GET / HTTP/1.1
Host: cs.helsinki.fi

                    </pre>

                    <p>Palvelin lähettää meille vastauksen, jossa on statuskoodi ja otsakkeita sekä dokumentin runko.</p>

                    <pre>
HTTP/1.1 302 Found
Date: Mon, 02 Sep 2013 18:31:30 GMT
Server: Apache/2.2.14 (Ubuntu)
Location: http://www.cs.helsinki.fi/
Vary: Accept-Encoding
Content-Length: 290
Content-Type: text/html; charset=iso-8859-1

&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;
&lt;html&gt;&lt;head&gt;
&lt;title&gt;302 Found&lt;/title&gt;
&lt;/head&gt;&lt;body&gt;
&lt;h1&gt;Found&lt;/h1&gt;
&lt;p&gt;The document has moved &lt;a href="http://www.cs.helsinki.fi/"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;address&gt;Apache/2.2.14 (Ubuntu) Server at cs.helsinki.fi Port 80&lt;/address&gt;
&lt;/body&gt;&lt;/html&gt;
                    </pre>

                    <p>Juuripolkua palvelimelta <code>cs.helsinki.fi</code> haettaessa palvelin vastaa että dokumentti on löytynyt (<code>302 Found</code>), mutta se sijaitsee muualla (<code>Location: http://www.cs.helsinki.fi/</code>).</p>

                </aside>

                <aside class="pohdi">
                    <h1>Kuinka monta hyppyä?</h1>

                    <p>Käytä telnetiä ja aloita osoitteesta <code>cs.helsinki.fi</code>, tavoitteenasi on päästä laitoksen etusivulle <code>http://www.cs.helsinki.fi/home/</code>. Kuinka monta uudelleenohjausta saat ennenkuin pääset etusivulle?</p>

                    <p>Jos et ehdi kirjoittamaan komentoa telnet-ikkunaan, voit ensin kirjoittaa sen esimerkiksi tekstieditoriin, ja kopioida sen sieltä telnet-ikkunaan.</p>

                </aside>

                <h3>HTTP-protokollan pyyntötavat</h3>

                <p>HTTP-protokolla määrittelee kahdeksan erillistä pyyntötapaa (Request method), joista yleisimmin käytettyjä ovat <code>GET</code> ja <code>POST</code>. Pyyntötavat määrittelevät rajoitteita ja suosituksia viestin rakenteeseen ja niiden prosessointiin palvelinpäässä. Esimerkiksi <a href="http://jcp.org/aboutJava/communityprocess/mrel/jsr154/index2.html" target="_blank">Java Servlet API (versio 2.5)</a> sisältää seuraavan suosituksen GET-pyyntotapaan liittyen:</p>

                <p><em>The GET method should be safe, that is, without any side effects for which users are held responsible. For example, most form queries have no side effects. If a client request is intended to change stored data, the request should use some other HTTP method.</em></p>

                <p>Suomeksi yksinkertaistaen: Palvelinpuolen toiminnallisuutta suunniteltaessa kannattaa pyrkiä tilanteeseen, missä <code>GET</code>-tyyppisillä pyynnöillä ei voida muuttaa palvelimella olevaa dataa.</p>

                <h4>GET</h4>

                <p>GET-pyyntötapaa käytetään esimerkiksi dokumenttien hakemiseen: kun kirjoitat osoitteen selaimen osoitekenttään ja painat enter, selain tekee GET-pyynnön. GET-pyynnöt eivät tarvitse otsaketietoja HTTP/1.1:n vaatiman Host-otsakkeen lisäksi. Mahdolliset kyselyparametrit lähetetään palvelimelle osana haettavaa osoitetta.</p>

                <pre>
GET /sivu.html?porkkana=1 HTTP/1.1
Host: palvelimen-osoite.net

                </pre>

                <h4>POST</h4>

                <p>Käytännön ero POST- ja GET-kyselyn välillä on se, että POST-tyyppisillä pyynnoillä kyselyparametrit liitetään pyynnön runkoon. Rungon sisältö ja koko määritellään otsakeosiossa. POST-kyselyt mahdollistavat multimedian (kuvat, videot, musiikki, ...) lähettämisen palvelimelle.</p>

                <pre>
POST /sivu.html HTTP/1.1
Host: palvelimen-osoite.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

porkkana=1
                </pre>

                <h2>HTML</h2>

                <p><em>"In '93 to '94, every browser had its own flavor of HTML. So it was very difficult to know what you could put in a Web page and reliably have most of your readership see it."</em> -- Tim Berners-Lee</p>

                <p>HTML on rakenteellinen kuvauskieli, jolla voidaan esittää linkkejä sisältävää tekstiä sekä tekstin rakennetta. HTML koostuu elementeistä, jotka voivat olla sisäkkäin ja peräkkäin. Elementtejä käytetään ohjeina dokumentin jäsentämiseen ja käyttäjälle näyttämiseen. HTML-dokumenteissa elementit avataan elementin nimen sisältävällä pienempi kuin -merkillä (&lt;) alkavalla ja suurempi kuin -merkkiin (&gt;) loppuvalla merkkijonolla (&lt;elementin_nimi&gt;), ja suljetaan merkkijonolla jossa elementin pienempi kuin -merkin jälkeen on vinoviiva (&lt;/elementin_nimi&gt;).</p>

                <p>HTML-dokumentin rakennetta voi ajatella myös puuna. Juurisolmuna on elementti <code>&lt;html&gt;</code>, jonka lapsina ovat elementit <code>&lt;head&gt;</code> ja <code>&lt;body&gt;</code>.</p>

                <p>Jos elementin sisällä ei ole muita elementtejä tai tekstisolmuja eli tekstiä, voi elementin yleensä avata ja sulkea samalla merkkijonolla: (&lt;elementin_nimi /&gt;).</p>

                <p>HTML:stä on useita erilaisia standardeja, joista viimeisin julkaistu versio on <a href="http://www.w3.org/TR/html5/" target="_blank">HTML5</a> -- myös versio <a href="http://www.w3.org/TR/html51/" target="_blank">5.1</a> työstetään tällä hetkellä (päivitetty 28.8.2015).</p>

                <pre class="sh_xml">
&lt;!DOCTYPE html&gt;
&lt;html lang="fi"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;title&gt;selainikkunassa näkyvä otsikko&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Tekstiä tekstielementin sisällä, tekstielementti runkoelementin sisällä,
       runkoelementti html-elementin sisällä. Elementin sisältö voidaan asettaa
       useammalle riville.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>

                <p>Ylläoleva HTML5-dokumentti sisältää dokumentin tyypin ilmaisevan aloitustägin (<code>&lt;!DOCTYPE html&gt;</code>), dokumentin aloittavan html-elementin (<code>&lt;html&gt;</code>), otsake-elementin ja sivun otsikon (<code>&lt;head&gt;</code>, jonka sisällä <code>&lt;title&gt;</code>), sekä runkoelementin (<code>&lt;body&gt;</code>).</p>

                <p>Elementit voivat sisältää attribuutteja ja attribuuteille voi antaa arvoja. Esimerkiksi ylläolevassa esimerkissä html-elementille on määritelty erillinen attribuutti <em>lang</em>, joka kertoo dokumentissa käytetystä kielestä.  Ylläolevan esimerkin otsakkeessa on myös metaelementti, jota käytetään lisävinkin antamiseen selaimelle: "dokumentissa käytetään UTF-8 merkistöä". Tämä kannattaa olla dokumenteissa aina.</p>

                <p>Nykyaikaiset web-sivut sisältävät paljon muutakin kuin sarjan HTML-elementtejä. Linkitetyt resurssit, kuten kuvat ja tyylitiedostot, ovat oleellisia sivun ulkoasun ja rakenteen luomisessa. Selainpuolella suoritettavat skriptitiedostot, erityisesti Javascript, ovat luoneet huomattavan määrän syvyyttä nykyaikaiseen web-kokemukseen. Tällä kurssilla emme juurikaan syvenny selainpuolen toiminnallisuuteen.</p>



		<h1>Ensimmäinen palvelinohjelmisto</h1>


                <p>Tutustutaan tässä osiossa yksinkertaisten web-palvelinohjelmistojen rakenteeseen, sekä niiden toteuttamiseen <a href="http://www.spring.io" target="_blank">Spring</a>-sovelluskehyksen <a href="http://projects.spring.io/spring-boot/" target="_blank">Spring Boot</a>-projektilla. Spring on sovelluskehys, joka tarjoaa komponentteja sovellusten toteuttamiseen ja testaamiseen, ja Spring Boot -projekti tarjoaa näistä komponenteista koostuvia valmiita aloituspaketteja.</p>


                <h2>Hello World!</h2>

                <p>Tutustutaan "Hello World!"-tyyppisen web-sovelluksen toteuttamiseen Springin avulla. Oletetaan, että käytössämme on osoitteesta <a href="http://start.spring.io/" target="_blank">start.spring.io</a> ladattu Web-projektirunko (ruksaa Web-listan komponentti Web), jonka kansiorakenne on oletuksena seuraavankaltainen:</p>

                <pre>
├── pom.xml
└── src
    ├── main
    │   ├── java
    │   │   └── demo
    │   │       └── DemoApplication.java
    │   └── resources
    │       ├── application.properties
    │       ├── static
    │       └── templates
    └── test
        └── java
            └── demo
                └── DemoApplicationTests.java</pre>


                <h3>Kontrolleriluokka, pyynnön vastaanottaminen ja pyynnön käsittelevä metodi</h3>


                <p>Lisää kansioon <code>src/main/java/demo</code> luokka <code>HelloController</code>. Kontrollerit (<em>Controller</em>) ovat palvelinohjelmistoissa luokkia, joissa oleviin metodeihin palvelin ohjaa käyttäjän tekemiä pyyntöjä. Spring löytää kontrolleriluokkamme jos luokalle on lisätty <em>annotaatio</em> <code>@Controller</code>. Lisätään luokalle lisäksi annotaatio <code>@ResponseBody</code>, joka kertoo, että metodien palauttamat arvot lähetetään sellaisenaan takaisin pyynnön tehneelle selaimelle. Kontrolleriluokkamme runko on seuraavanlainen.</p>

<pre class="sh_java">
package demo;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
@ResponseBody
public class HelloController {

}</pre>

                <p>Pyynnöt käsitellään kontrolleriluokissa olevien metodien avulla. Jotta Spring osaa valita oikean metodin, tulee metodeille lisäksi kertoa <em>polku</em>, mitä ne kuuntelevat. Polku kerrotaan metodille määriteltävällä <code>@RequestMapping</code>-annotaatiolla. Metodi, jolla on annotaatio <code>@RequestMapping("*")</code> kuuntelisi kaikkia palvelinohjelmistoon liittyviä polkuja, kun taas annotaatiolla <code>@RequestMapping("/hello")</code> metodi kuuntelisi vain ohjelmiston polkuun <code>/hello</code> tulevia pyyntöjä. Luodaan kontrolleri, joka palauttaa selaimelle tekstin <code>"Hello!"</code> riippumatta siitä, mihin polkuun pyyntö tulee.</p>

		<pre class="sh_java">
package demo;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
@ResponseBody
public class HelloController {

    @RequestMapping("*")
    public String hello() {
        return "Hello!";
    }
}</pre>

	

                <h3>Sovelluksen käynnistäminen komentoriviltä</h3>

                <p>Sovelluksen käynnistäminen onnistuu suorittamalla projektijuuressa (hakemisto, missä on tiedosto pom.xml) komento <code>mvn spring-boot:run</code>. Käytännössä komento käynnistää projektissa mukana olevan palvelimen, ja asentaa siihen kehittämämme sovelluksen.</p>

                <p>Kun sovellus käynnistetään, siihen liittyvä palvelin käynnistyy oletuksena osoitteeseen <code>http://localhost:8080</code>. Voit tarkastella sovelluksen toimintaa web-selaimella. </p>


		<h3>Sovelluksen käynnistämisestä ja pakkauksista</h3>
		
		<p>Esimerkkipohjan mukana tuleva Spring-sovellus käynnistyy luokan <code>DemoApplication</code> kautta.</p>
		
		<pre class="sh_java">package demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}</pre>
		
		<p>Luokassa oleva annotaatio <code>@SpringBootApplication</code> pyytää sovellusta muunmuassa etsimään oleellisia luokkia projektista. Oletuksena luokkien tulee olla pakkauksen <code>demo</code> sisällä, tai sen alipakkauksissa kuten <code>demo.controller</code>. Käytämme kurssilla tehtävissä usein juuripakkauksen nimenä termiä <code>wad</code>, joka on kurssia varten keksitty lyhenne sanoista Web Application Development.</p>

		<p>Materiaalin esimerkeissä käytetty pakkausnimentä vaihtelee ajoittain.</p>
		

                <hr/>

                <div class="tehtavat">

                    <p>Tästä eteenpäin materiaalissa on myös ohjelmointitehtäviä. Tehtävien tekeminen ja palautus tapahtuu NetBeans-ympäristössä Test My Code-liitännäisen avulla. Test My Code lataa tehtäväpohjat sinulle valmiiksi, eli et tarvitse <code>start.spring.io</code>-osoitteen projektipohjia tehtävien tekemiseen. Muistathan palauttaa jokaisen tehtävän (<em>submit solution</em>). Tehtävät avataan tehtävän otsikkoa klikkaamalla.</p>
		    
                    <div class="tehtava" id="t-helloweb-ex">

                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-helloweb">
                                    Hello World!
                                </a>
                            </h1>
                        </header>

                        <div id="t-helloweb" class="collapse">

                            <p>Kuten huomattava osa ohjelmointikursseista, tämäkin kurssi alkaa tehtävällä, jossa toteutettava ohjelma kirjoittaa tekstin <code>Hello World!</code>.</p>

                            <p>Toteuta pakkauksessa <code>wad.controller</code> olevaan luokkaan <code>HelloWorldController</code> kontrollerimetodi, joka kuuntelee kaikkia osoitteita. Kun palvelin vastaanottaa pyynnön, tulee palvelimen palauttaa merkkijono "Hello World!".</p>

                            <p>Käynnistä palvelin painamalla NetBeansin play-nappia tai suorittamalla <code>Application</code>-luokan <code>main</code>-metodi. Avaa nettiselain, mene osoitteeseen <a href="http://localhost:8080/" target="_blank">http://localhost:8080/</a>, ja näet selaimessasi tekstin "Hello World!".</p>

                            <p><img class="browser-img" src="img/exercises/w1e01.png"/></p>

                            <p>Palvelin sammutetaan NetBeansissa punaista nappia painamalla -- vain yksi sovellus voi olla kerrallaan päällä samassa osoitteessa. Palauta tehtävä lopuksi Test My Code:n submit-napilla.</p>
                        </div>
                    </div>

                    <div class="tehtava" id="t-vieraslaskuri">

                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-vieraslaskuri">
                                    Vieraslaskuri
                                </a>
                            </h1>
                        </header>
                        <div id="t-vieraslaskuri" class="collapse">
                            <p>Vieraslaskuri kertoo kävijälle kuinka monta kävijää sivulla on käynyt tähän mennessä. Ensimmäinen kävijä näkee luvun 1, toinen kävijä luvun 2, jne.</p>

                            <p>Toteuta pakkauksessa <code>wad.controller</code> olevaan luokkaan <code>VisitCountController</code> polkua <code>/visits</code> kuunteleva metodi, joka toteuttaa toivotun toiminnallisuuden. Vinkki! Kontrolleriluokka luodaan vain kerran palvelimen käynnistyksen yhteydessä, joten voinet hyödyntää jotain sopivaa oliomuuttujaa.</p>

                            <p>Testaa sovellustasi. Ensimmäisellä pyynnöllä osoitteeseen <code>http://localhost:8080/visits</code> sinun pitäisi nähdä numero 1, toisella pyynnöllä numero 2 jne. Kun käynnistät palvelimen uudelleen, laskuri alkaa taas yhdestä.</p>
                        </div>
                    </div>
                </div>



                <h2>Pyynnön parametrit</h2>

                <p>Kun käyttäjä avaa osoitteen web-selaimella, selain tekee GET-tyyppisen pyynnön palvelimelle. Pyynnön mukana voi kulkea parametreja, jotka lisätään haettavan osoitteen perään. Esimerkiksi, osoitteessa <code>http://localhost:8080/autot?numero=95&amp;nimi=salama</code> on kaksi parametria. Parametrin <code>numero</code> arvo on <code>95</code> ja parametrin <code>nimi</code> arvo on <code>salama</code>. Parametrit erotetaan toisistaan <code>&amp;</code>-merkillä.</p>

                <p>Kontrollerimetodit voivat vastaanottaa näitä pyyntöjä määrittelemällä pyynnön vastaanottavalle metodille parametreja. Seuraava osoitetta <code>/tervehdi</code>-kuunteleva kontrollerimetodi olettaa, että pyynnön mukana tulee parametri <code>nimi</code>, ja palauttaa viestin "Hei ", jonka perään on liitetty parametrina saatu arvo.</p>

                <pre class="sh_java">
package demo;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
@ResponseBody
public class HelloController {

    @RequestMapping("/tervehdi")
    public String hello(@RequestParam String nimi) {
        return "Hei " + nimi;
    }
}</pre>

                <p>Jos ylläolevan sovelluksen käynnistää, ja hakee selaimella osoitetta <code>http://localhost:8080/tervehdi?nimi=Winnetou</code> -- olettaen että sovellus on käynnistetty omalla koneella -- käyttäjä näkee tekstin <code>Hei Winnetou</code>. Käytännössä osoitteessa oleva parametrin nimi kytketään automaattisesti metodissa käytettävään muuttujan nimeen.</p>

                <p>Kuten <code>@RequestMapping</code>-annotaatiolle, myös <code>@RequestParam</code>-annotaatiolle voi antaa toimintaa tarkentavia parametreja. Parametrit <code>required</code> ja <code>defaultValue</code> ovat molemmat hyödyllisiä; ensimmäisellä määritellään että tuleeko parametrin olla pyynnössä, ja toisella määritellään parametrin oletusarvo jos parametria ei ole.</p>

                <p>Seuraavassa esimerkissä todetaan, että pyynnön ei tarvitse sisältää parametria <code>sijainti</code>, ja että parametriin asetetaan oletuksena arvo "Kumpula".</p>

                <pre class="sh_java">
    @RequestMapping("/sijainti")
    public String etsi(@RequestParam(required=false, defaultValue="Kumpula") String sijainti) {
        return "Haetaan " + sijainti;
    }</pre>

                <p>Käytännössä jos selain tekee pyynnön osoitteeseen <code>http://localhost:8080/sijainti</code>, palauttaa palvelin merkkijonon "Haetaan Kumpula".</p>

                <p>Parametreja voi olla pyynnössä myös useampia. Seuraavassa esimerkissä metodi osaa käsitellä sekä <code>sijainti</code> että <code>vuosi</code> -nimiset parametrit. Huomaa, että oletusarvot asetetaan aina merkkijonona.</p>

                <pre class="sh_java">
    @RequestMapping("/sijainti")
    public String etsi(@RequestParam(required=false, defaultValue="Kumpula") String sijainti,
                       @RequestParam(required=false, defaultValue="1970") Integer vuosi) {
        return "Haetaan " + sijainti + " vuonna " + vuosi;
    }</pre>



                <p>Käytämme viittaustyyppisiä muuttujia (esim. <code>Integer</code>) myös tapauksissa, joissa alkeistyyppisen muuttujan (esim. <code>int</code>) käyttö olisi periaatteessa mahdollista. Tällä ohjelmointityylillä vältämme ongelmia, joita ilmenee kun sovelluskehys yrittää asettaa puuttuvaa parametrin arvoa (oletuksena <code>null</code>) alkeistyyppiseen muuttujaan (kokeile mitä tapahtuu jos koodissasi on komennot <code>Integer arvo = null; int a = arvo;</code>).</p>


                <div class="tehtavat">

                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-kaikupalvelu">
                                    Papukaija Bob
                                </a>
                            </h1>
                        </header>
                        <div id="t-kaikupalvelu" class="collapse">
                            <p>Papukaija <a href="https://www.youtube.com/watch?v=6NG37huf2dU" target="_blank">Bob</a> on netti-ilmiö, joka on oppinut sanoja, joita se toistaa. Tässä tehdään Bobille vastine, joka osaa toistaa sille sanottavia asioita.</p>

                            <p>Toteuta luokkaan <code>ParrotController</code> kontrollerimetodi, joka kuuntelee pyyntöjä <code>/bob</code>-osoitteessa. Jos pyynnön mukana ei ole <code>message</code>-nimistä parametria, on vastaus <code>"Krraaa"</code>. Muuten, vastaus on <code>"Krraaa"</code>, jota seuraa välilyönti ja <code>message</code>-parametrin arvo.</p>

                            <p>Kun testaat sovellusta, pyyntö osoitteeseen <code>http://localhost:8080/bob</code> näyttää sivun, jossa on merkkijono <code>"Krraaa"</code>, kun taas esimerkiksi pyyntö <code>http://localhost:8080/bob?message=keksii</code> palauttaa merkkijonon <code>"Krraaa keksii"</code>.</p>
                        </div>
                    </div>
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-laskin">
                                    Laskin
                                </a>
                            </h1>
                        </header>
                        <div id="t-laskin" class="collapse">

                            <p>Toteuta luokkaan <code>CalculatorController</code> kontrollerimetodi, joka kuuntelee pyyntöjä <code>/calculate</code>-osoitteessa. Pyynnön mukana voi olla kolme parametria. Parametri <code>"op"</code> kertoo laskuoperaation, <code>"first"</code> kertoo ensimmäisen laskettavan luvun, ja <code>"second"</code> kertoo toisen laskettavan luvun.</p>

                            <p>Jos parametria <code>"op"</code> ei ole pyynnössä mukana, tulee sen saada oletusarvoksi <code>"plus"</code>. Jos parametri <code>"first"</code> puuttuu, saa se oletuksena arvon 0. Myös parametri <code>"second"</code> saa puuttuessaan arvon 0.</p>

                            <p>Laskimen tulee toteuttaa seuraavat operaatiot:</p>

                            <ul>
                                <li>Kun operaatio (op) on <code>"plus"</code> laskin palauttaa lukujen <code>"first"</code> ja <code>"second"</code> summan. Esim. pyyntö osoitteeseen <code>http://localhost:8080/calculate?op=plus&first=3&second=1</code> palauttaa arvon <code>4</code>.</li>
                                <li>Kun operaatio (op) on <code>"minus"</code> laskin palauttaa lukujen <code>"first"</code> ja <code>"second"</code> erotuksen. Esim. pyyntö osoitteeseen <code>http://localhost:8080/calculate?op=minus&first=7&second=2</code> palauttaa arvon <code>5</code>.</li>
                                <li>Kun operaatio (op) on <code>"multiply"</code> laskin palauttaa lukujen <code>"first"</code> ja <code>"second"</code> tulon. Esim. pyyntö osoitteeseen <code>http://localhost:8080/calculate?op=multiply&first=11&second=3</code> palauttaa arvon <code>33</code>.</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <h2>Näkymät ja data</h2>

                <p>Aiemmat sovelluksemme ovat vastaanottaneet tiettyyn osoitteeseen tulevan pyynnön ja palauttaneet käyttäjälle esimerkiksi merkkijonomuodossa olevaa dataa. Tämä ei kuitenkaan ole ainoa palvelinohjelmistojen toimintatyyppi, vaan palvelin voi myös luoda käyttäjälle näkymän, jonka selain lopulta näyttää käyttäjälle. Näkymät luodaan tyypillisesti HTML-kielellä siten, että HTML-kielen sekaan on upotettu komentoja, joiden perusteella näkymään lisätään palvelimen tuottamaa tietoa.</p>



                <h3>Näkymän luominen: Thymeleaf</h3>

                <p>Eräs apuväline näkymän luomiseen on <a href="http://www.thymeleaf.org/" target="_blank">Thymeleaf</a>-templatemoottori, joka tarjoaa välineitä datan lisäämiseen HTML-sivuille. Käytännössä luomme näkymät ensin HTML-sivuina, jonka jälkeen sivuihin lisätään komentoja Thymeleafin käsiteltäväksi.</p>

                <p>Esimerkiksi, kun allaolevaa HTML-sivua käsitellään palvelimella, siinä olevan elementin <code>&lt;span th:text="${viesti}"&gt;hello world!&lt;/span&gt;</code> sisältö vaihdetaan palvelimella pyyntöön lisättyyn muuttujaan <code>viesti</code>.</p>

                <pre class="sh_xml">
&lt;!DOCTYPE html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;title&gt;selainikkunassa näkyvä otsikko&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Tekstiä tekstielementin sisällä, tekstielementti runkoelementin sisällä,
       runkoelementti html-elementin sisällä. Elementin sisältö voidaan asettaa
       useammalle riville.&lt;/p&gt;

    &lt;p&gt;palvelimelta saatu teksti: &lt;span th:text="${viesti}"&gt;hello world!&lt;/span&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>

                <p>Thymeleaf-sivut eroavat HTML-sivuista siinä, että niillä on <code>html</code>-määrittelyssä <code>xml</code>-nimiavaruuden <code>th</code>-määrittely, jonka avulla komennot kuten <code>th:text</code> tunnistetaan.</p>

                <p>Thymeleaf-sivut ("templatet") sijaitsevat tällä kurssilla projektin kansiossa <code>src/main/resources/templates</code> tai sen alla olevissa kansioissa. NetBeansissa kansio löytyy kun klikataan "Other Sources"-kansiota.</p>

		<aside class="info">
		  <br/>
		  <h1>Thymeleafin käyttöönotto</h1>

                  <p>Thymeleafin käyttöönotto vaatii <code>pom.xml</code>-tiedostossa olevien riippuvuuksien muokkaamista. Spring-sovelluskehyksen perusweb-toiminnallisuus on tuotu käyttöömme riippuvuudella</p>

                <pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>

		<p>Vaihtamalla ylläoleva riippuvuus allaolevaan muotoon, otamme Thymeleafin käyttöön.</p>

                <pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>

		<p>Joudumme myös hakemaan projektin riippuuvuuksia. Tämä onnistuu joko kirjoittamalla komentorivillä projektin juuressa komento <code>mvn dependency:resolve</code> tai valitsemalle NetBeansissa projektiin liittyvä kansio <em>Dependencies</em> oikealla hiirennapilla, ja painamalla <em>Download Declared Dependencies</em>.</p>

		<p>tämän lisäksi, HTML-sivujen <code>html</code>-elementin määrittelyssä tulee olla seuraavat määrittelyt.</p>  

                <pre class="sh_xml">
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt;</pre>        

                <p>Thymeleaf etsii näkymiä oletuksena kansiosta <code>src/main/resources/templates</code>. Spring etsii kansiosta <code>src/main/resources</code> konfiguraatiotiedostoa <code>application.properties</code>, johon lisäämme seuraavat rivit.</p>

                <pre>
spring.thymeleaf.suffix=.html
spring.thymeleaf.cache=false</pre>

                <p>Yllä olevalla konfiguraatiolla määrittelemme, että näkymätiedostojen pääte on <code>.html</code>; sitä ei tarvitse erikseen kertoa kontrollerissa. Tämän lisäksi, rivi <code>spring.thymeleaf.cache=false</code> sanoo sovellukselle, että näkymiä ei tule ladata välimuistiin; tämän avulla näemme näkymiin tehtävät muutokset myös palvelimen ollessa käynnissä.</p>

                <p>Nyt jos palautamme kontrollerista esimerkiksi merkkijonon <code>messages</code>, Spring etsii sivun <code>src/main/resources/templates/messages.html</code>, pyytää Thymeleafia luomaan sen, ja palauttaa sen käyttäjälle.</p>

                <pre class="sh_java">
@RequestMapping(method = RequestMethod.GET)
public String view() {
    return "messages";
}</pre>        

		</aside>


                <h3>Näkymän löytäminen ja näyttäminen</h3>

                <p>Sovellukseen tulevat pyynnöt otetaan vastaan ensin Spring-sovelluskehyksen toimesta, jonka tehtävänä on ohjata pyynnöt sopiville kontrollerimetodeille. Nämä päätellään <code>@RequestMapping</code>-annotaatioista. Kontrollerimetodien vastuulla on sekä datan liittäminen pyyntöön että vastauksen ohjaaminen joko suoraan käyttäjälle tai komponentille, joka luo datan avulla näkymän (esim. Thymeleaf).</p>

		<p>Aiemmin kontrolleriluokissa käyttämämme annotaatio <code>@ResponseBody</code> on käytännössä tarkoittanut sitä, että metodin palauttama data palautetaan sellaisenaan käyttäjälle. Kun otamme sen pois, käyttämämme sovelluskehys yrittää etsiä palauttamamme merkkijonon perusteella näkymää, jonka voisi näyttää käyttäjälle.</p>

                <p>Palauttamalla kontrollerimetodista merkkijono, sovellus etsii merkkijonoon liittyvää näkymää. Esimerkiksi, jos metodi palauttaa arvon "index", hakee Spring --  Thymeleafia käytettäessä -- kansiosta <code>src/main/resources/templates/</code> tiedostoa <code>index.html</code> ja näyttää sen sisällön käyttäjälle.</p>  

                <pre class="sh_java">
package wad.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class HelloController {

    @RequestMapping("*")
    public String view() {
        return "index";
    }
}</pre>

                <h3>Tiedon lisääminen pyyntöön</h3>

                <p>Sivua ei lähetetä suoraan käyttäjälle, vaan se käsitellään ensin palvelinohjelmistossa. Sivulle voi lisätä tietoa ns. <em>Model</em>-olion avulla, jonka voimme määritellä kontrollerimetodeihin. Spring asettaa oliolle arvon automaattisesti pyynnön saapuessa. Seuraava koodi lisää pyynnössä olevalle Model-oliolle attribuutin <code>viesti</code>, jonka arvoksi asetetaan merkkijono "aikamoista.". Tämän jälkeen metori palauttaa merkkijonon, jonka perusteella etsitään näkymän määrittelevä tiedosto. Tämä tiedosto ja model-oliossa oleva data käsitellään Thymeleafin toimesta, ja lopulta valmis sivu palautetaan käyttäjälle.</p>

                <pre class="sh_java">
package wad.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class HelloController {

    @RequestMapping("*")
    public String view(Model model) {
        model.addAttribute("viesti", "aikamoista.");
        return "index";
    }
}</pre>

        
		<p>Näkymän luonnin yhteydessä data asetetaan määriteltyihin kohtiin ja Thymeleaf-projektiin liittyvät viitteet poistetaan. Jos sivu "index.html" olisi aiemmin materiaalissa näkemämme HTML-sivu, saisi käyttäjä lopulta seuraavalta näyttävän sivun.</p>


                <pre class="sh_xml">
&lt;!DOCTYPE html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;title&gt;selainikkunassa näkyvä otsikko&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Tekstiä tekstielementin sisällä, tekstielementti runkoelementin sisällä,
       runkoelementti html-elementin sisällä. Elementin sisältö voidaan asettaa
       useammalle riville.&lt;/p&gt;

    &lt;p&gt;palvelimelta saatu teksti: &lt;span&gt;aikamoista&lt;/span&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>     

	

                <p>Kontrollerimetodit voivat luonnollisesti sekä vastaanottaa pyynnön parametreja, että lisätä dataa Model-olioon. Allaolevassa esimerkissä metodi odottaa kahta parametria ja lisää niiden arvot model-oliolle näkymän luomista varten.</p>

                <pre class="sh_java">
    @RequestMapping("/sijainti")
    public String etsi(Model model,
                       @RequestParam(required=false, defaultValue="Kumpula") String sijainti,
                       @RequestParam(required=false, defaultValue="1970") Integer vuosi) {
        model.addAttribute("sijainti", sijainti);
        model.addAttribute("vuosi", vuosi);
        return "index";
    }</pre>

                <div class="tehtava">
                    <header>
                        <h1>
                            <a data-toggle="collapse" class="collapsed" href="#t-nakyma-ja-lomake">
                                Näkymä ja lomake
                            </a>
                        </h1>
                    </header>
                    <div id="t-nakyma-ja-lomake" class="collapse">
                        <p>Sovelluksessa oleva luokka <code>FormController</code> sisältää metodin, joka vastaanottaa minkä tahansa pyynnön, asettaa <code>model</code>-olion <code>data</code>-parametrin arvoksi <code>content</code>-muuttujan, sekä ohjaa pyynnön luomaan sivun kansiossa <code>src/main/resources/templates/</code> olevasta <code>index.html</code>-sivusta. Sivu sisältää valmiin lomakkeen, jonka avulla palvelimelle voi lähettää tietoa. Jos HTML-lomakkeet eivät ole tuttuja, tutustu esimerkiksi osoitteessa <a href="http://www.w3schools.com/html/html_forms.asp" target="_blank">http://www.w3schools.com/html/html_forms.asp</a> olevaan oppaaseen.</p>

			<p>Kun tarkastelet valmista lomaketta tarkemmin, on <code>action</code>-attribuutti hieman erilainen kuin normaalisti. Thymeleafissa lomakkeen <code>action</code>-attribuutti määritellään muodossa <code>th:action="@{/submit}"</code>, minkä avulla osoite voidaan muuttaa automaattisesti sovelluksen sijainnin muuttuessa.</p>

                        <p>Muokkaa sovellusta siten, että lomakkeella lähetetty data muuttaa palvelimella olevaa <code>content</code>-muuttujaa, ja että käyttäjälle näytetään aina <code>content</code>-muuttujan uusin arvo. Jos taas pyynnössä ei tule <code>data</code>-nimistä parametria, säilytetään <code>content</code>-muuttujan arvo sellaisenaan. Varmista lopuksi, että käyttäjä näkee sivun myös ilman lomakkeen lähetystä.</p>

                        <p>Käytännössä sivun tulee toimia seuraavasti:</p>

                        <ul>
                            <li>Kun sivu avataan ensimmäisen kerran, käyttäjä näkee tekstin "i got nothing.."</li>
                            <li>Kun lomakkeella lähetetään dataa, esimerkiksi "testi", käyttäjä näkee tekstin "i got testi"</li>
                            <li>Kun sivu avataan tämän jälkeen uudestaan, käyttäjä näkee vieläkin tekstin "i got testi"</li>
                        </ul>
                    </div>
                </div>


                <h3>Pyynnöistä ja poluista</h3>


                <p>HTML-sivuilla olevien lomakkeiden avulla käyttäjä voi lähettää dataa sekä GET- että POST-tyyppisellä pyynnöllä. Pyynnön tyyppi määritellään lomakkeen <code>method</code>-osiossa, esimerkiksi seuraavalla lomakkella tehdään POST-tyyppinen pyyntö, jossa palvelimen polkuun <code>/persons</code> lähetetään parametri nimeltä <code>name</code> -- (palvelimen päälläollessa käytännössä <code>http://localhost:8080/persons</code>). Käytännössä GET-tyyppisiä pyyntöjä ei tule käyttää ohjelmiston sisäisen tilan muokkaamiseen (esimerkiksi henkilöiden poistamiseen), sillä esimerkiksi web-indeksoijat tekevät GET-tyyppisiä pyyntöjä ja seuraavat sivujen linkkejä.</p>

                <pre class="sh_xml">
        &lt;form th:action="@{/persons}" method="POST"&gt;
            &lt;input type="text" name="name"/&gt;
            &lt;input type="submit"/&gt;
        &lt;/form&gt;</pre>

                <p>Allaoleva kontrollerimetodi vastaanottaa sekä GET- että POST-tyyppisiä pyyntöjä.</p>

                <pre class="sh_java">
    @RequestMapping("/persons")
    public String post(@RequestParam String name) {
        // tee jotain parametrille name
        return "index";
    }</pre>


                <p>Pyynnön tyypin voi kertoa eksplisiittisesti osana <code>@RequestMapping</code>-annotaatiota. Alla oleva metodi käsittelee vain POST-tyyppisiä pyyntöjä.</p>

                <pre class="sh_java">
    @RequestMapping(value = "/persons", method = RequestMethod.POST)
    public String post(@RequestParam String name) {
        // tee jotain parametrille name
        return "index";
    }</pre>

                <p>POST-tyyppiset pyynnöt ovat hieman ongelmallisia jos pyynnön vastauksena palautetaan näytettävä sivu. Tällöin käyttäjä voi sivun uudelleenlatauksen (esim. painamalla F5) yhteydessä lähettää aiemmin lähettämänsä datan vahingossa uudelleen. Esimerkiksi edellisessä tehtävässä, jos painat F5-näppäintä sen jälkeen kun olet lähettänyt lomakkeen, huomaat tämän ilmiön.</p>

                <p>On tyylikkäämpää toteuttaa lomakkeen dataa vastaanottavat kontrollerit siten, että ne vastaanottavat pyynnön ja pyytävät selainta hakemaan sivun uudestaan. Tämä tapahtuu palauttamalla kontrollerimetodista merkkijono <code>redirect:</code>, johon on liitetty haluttava polku. Esimerkiksi merkkijonon <code>redirect:/persons</code> palauttaminen luo tilanteen, missä selaimelle lähetetään viesti, jossa sitä ohjeistetaan tekemään GET-tyyppinen haku osoitteeseen <code>/persons</code>. Tätä toteutustapaa kutsutaan <a href="http://en.wikipedia.org/wiki/Post/Redirect/Get" target="_blank">Post/Redirect/Get</a>-suunnittelumalliksi, ja sillä mm. estetään lomakkeiden uudelleenlähetys, jonka lisäksi vähennetään toiminnallisuuden toisteisuutta.</p>

                <p>Ylläolevan esimerkin voi toteuttaa uudestaan siten, että lomake vastaanotetaan yhdessä kontrollerimetodissa ja näkymä palautetaan toisessa. Lisätään annotaatioon <code>@RequestMapping</code> parametri <code>method</code>, jolla kerrotaan pyyntötyyppi, jota kontrollerimetodi kuuntelee.</p>

                <pre class="sh_java">
    @RequestMapping(value = "/persons", method = RequestMethod.GET)
    public String get() {
        return "index";
    }

    @RequestMapping(value = "/persons", method = RequestMethod.POST)
    public String post(@RequestParam String name) {
        // tee jotain parametrille name
        return "redirect:/persons";
    }</pre>

                <p>Kontrollerimetodiin <code>get</code> voisi luonnollisesti lisätä myös Model-parametrin, johon voisi asettaa näkymään lisättävää tietoa.</p>

                <p>Jatketaan esimerkkiä vielä hieman. Oletetaan, että käsittelemme henkilöitä, joilla jokaisella on jonkinlainen yksilöllinen tunnus, ja haluamme näyttää henkilöön liittyvän sivun. Eräs vaihtoehto olisi lisätä pyynnön parametriin näytettävän henkilön tunnus, minkä perusteella pyyntöä käsittelevä metodi hakisi tarvittavan henkilön.</p>

                <p>Toinen vaihtoehto on ajatella pyyntöpolkua haettavan henkilön, tai resurssin tunnistajana, ja hakea henkilön tietoja esimerkiksi osoitteen <code>/persons/5</code> kautta, missä tunnus <code>5</code> on haettavan henkilön tunnus. Parametrien erottaminen pyyntöpolusta onnistuu <code>@PathVariable</code>-annotaation avulla. Yllä oleva esimerkki jatkuu siten, että muokkaamme <code>get</code>-metodin nimen muotoon <code>list</code>, ja lisäämme toisen metodin nimeltä <code>get</code>, jonka avulla voidaan hakea yksittäinen henkilö. Kokonaisuudessaan henkilöiden noutamiseen ja lisäämiseen tarvittava kontrolleriluokka on seuraavanlainen.</p>


                <pre class="sh_java">
package wad.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

@Controller
public class PersonController {

    // ..

    @RequestMapping(value = "persons", method = RequestMethod.GET)
    public String list(Model model) {
        // hae kaikki henkilöt ja lisää ne modeliin
        // palauta sopiva sivu
        return "persons"; // erillinen persons.html
    }

    @RequestMapping(value = "persons/{id}", method = RequestMethod.GET)
    public String get(Model model, @PathVariable String id) {
        // etsi henkilö tunnuksella id, lisää se modeliin
        // palauta sopiva sivu
        return "person"; // erillinen person.html
    }

    @RequestMapping(value = "persons", method = RequestMethod.POST)
    public String post(@RequestParam String name) {
        // luo uusi henkilö nimen perusteella
        return "redirect:/persons";
    }
}</pre>

                <p>Huomaamme kuitenkin metodeissa hieman toistoa. Voimme siirtää osan <code>@RequestMapping</code>-määrittelystä luokkatasolle seuraavasti. Tällöin kaikki alla olevassa luokassa olevat metodit kuuntelevat polkua <code>persons</code> tai sen alipolkuja.</p>


                <pre class="sh_java">
// ..

@Controller
@RequestMapping(value = "persons")
public class PersonController {

    @RequestMapping(method = RequestMethod.GET)
    public String list(Model model) {
        // ..
    }

    @RequestMapping(value = "/{id}", method = RequestMethod.GET)
    public String get(Model model, @PathVariable String id) {
        // ..
    }

    @RequestMapping(method = RequestMethod.POST)
    public String post(@RequestParam String name) {
        // ..
    }
}</pre>

                <h3>Olioiden luominen pyynnöstä</h3>

                <p>Jatketaan edellistä esimerkkiä vielä hieman. Oletetaan, että haluamme käsitellä <code>Person</code>-luokan ilmentymiä. Jos luokan attribuuttien nimet ovat samat pyynnössä olevien parametrien kanssa, voidaan pyynnön parametreista luoda olio automaattisesti. Oletetaan, että käytössämme on seuraava <code>Person</code>-luokka.</p>

                <pre class="sh_java">
//..
public class Person {

    private String name;

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }
}</pre>

                <p>Luokalle tulee olla ns. getterit ja setterit, sillä Spring käyttää niitä arvojen asettamiseen. Näiden luominen on automaattista NetBeansissa: kun olet luonut oliomuuttujat, klikkaa lähdekoodi-ikkunaa oikealla hiirennapillä, ja valitse <code>Insert code</code>.</p>

                <p>Kun käytössämme on luokka <code>Person</code>, voimme muokata aiempaa kontrolleriluokkaamme siten, että lomakkeen vastaanottava <code>post</code> metodi luo pyynnöstä automaattisesti <code>Person</code>-olion. Tämä tapahtuu <code>@ModelAttribute</code>-annotaatiolla.</p>

                <pre class="sh_java">
    @RequestMapping(method = RequestMethod.POST)
    public String post(@ModelAttribute Person person) {
        // tee luodulle oliolle jotain

        return "redirect:/persons";
    }</pre>

                <div class="tehtava">
                    <header>
                        <h1>
                            <a data-toggle="collapse" class="collapsed" href="#t-vieraslista">
                                Vieraslista
                            </a>
                        </h1>
                    </header>
                    <div id="t-vieraslista" class="collapse">
                        <p>Tehtävässä kehitetään vieraslistausta. Tässä tehtävässä on kaksi osaa, joista kummastakin saa tehtäväpisteen.</p>

                        <h1>Vieraiden lisääminen</h1>

                        <p>Muokkaa <code>GuestController</code>-luokkaa siten, että kun osoitteeseen <code>/guests</code> tehdään POST-pyyntö, jonka mukana lähetetään vierasta kuvaavat <code>name</code> ja <code>menu</code>-parametrit, vieraslistaan (lista nimeltä <code>guests</code>) lisätään uusi vieras. Lisää vieras jos ja vain jos name-parametri ei ole tyhjä.</p>

                        <p>Huomioi, että luokka <code>GuestController</code> kuuntelee jo <code>/guests</code>-osoitetta!</p>

                        <p>Kun uusi vieras on lisätty, pyyntö tulee <em>uudelleenohjata</em> vieraat listaavalle kontrollerimetodille.</p>


                        <h1>Vieraiden poisto</h1>

                        <p>Toteuta vieraiden poistotoiminnallisuus.</p>

                        <p>Poistotoiminnallisuuden tulee tapahtua POST-tyyppisen pyynnön avulla vieraskohtaisiin osoitteisiin. Esimerkiksi, vieraan, jonka tunnus (id) on "x9z41f", poisto tapahtuu tekemällä pyyntö osoitteeseen <code>/guests/x9z41f/delete</code>. Annotaatiosta <code>@PathVariable</code> on tässä hyötyä. Huom! Älä hyväksy GET-tyyppisiä pyyntöjä, jotka yrittävät poistaa vierasta listalta!</p>

                        <p>Kun vieras on poistettu, uudelleenohjaa pyyntö vieraat listaavalle kontrollerimetodille.</p>
                    </div>
                </div>


                <h3>Olioiden ja kokoelmien käyttäminen näkymässä</h3>

                <p>Edellisessä tehtävässä käytetyssä HTML-sivussa oli muutamia mystisiä kommentteja. Selvennetään niistä muutamia.</p>

                <p>Jos model-olioon on lisätty olio, pääsemme olion muuttujiin käsiksi piste-operaattorin <code>.</code> avulla. Esimerkiksi lause <code>${person.name}</code> hakee <code>person</code>-nimiseen olioon liittyvän <code>name</code>-muuttujan arvoa. Muuttujien arvojen hakemisessa käytetään gettereitä ja settereitä, joten ne kannattaa olla luokkamäärittelyssä.</p>

                <p>Käytännössä siis jos Person-luokan ilmentymä lisätään pyynnön model-olioon, pääsee Thymeleaf sen <code>getName</code>-metodiin käsiksi.</p>

                <pre class="sh_java">
    ...
    Person p = new Person();
    p.setName("James Gosling");
    model.addAttribute("person", p);
    ...
                </pre>

                <p>Kun olio on lisätty pyynnön attribuutiksi nimellä <code>person</code>, voidaan siihen liittyviin get-metodeihin viitata muodossa <code>${person.<em>ominaisuus</em>}</code>. Tämä tekisi metodikutsun <code>getOminaisuus()</code>. Metodia <code>getName()</code> voi taas kutsua seuraavasti:</p>

                <pre class="sh_xml">
    ...
    &lt;body&gt;
        &lt;p&gt;Ja seuraavana vuorossa on: &lt;span th:text="${person.name}"&gt;jack bauer?&lt;/span&gt;&lt;/p&gt;
    &lt;/body&gt;
    ...
                </pre>

                <p>Yllä oleva esimerkki luo seuraavanlaisen tulostuksen.</p>

                <pre class="naytto">
Ja seuraavana vuorossa on: James Gosling
                </pre>

                <p>Thymeleaf sisältää toiminnallisuudet mm. perusohjelmoinnissa käytettävien kontrollirakenteiden käyttöön sekä erilaisten tietotyyppien kuten päivämäärän formatointiin. Tällä kurssilla hyödynnämme lähinnä kontrollirakenteita, joista toistolauseke lienee tärkein.</p>

                <p>Komentoa <code>th:each</code> käytetään Collection-rajapinnan toteuttavien kokoelmien läpikäyntiin. Sen määrittely saa muuttujan nimen, johon kokoelmasta otettava alkio kullakin iteraatiolla tallennetaan, sekä läpikäytävän kokoelman. Perussyntaksiltaan <code>th:each</code> on seuraavanlainen.</p>

                <pre class="sh_xml">
    ...
    &lt;pre&gt;
        &lt;p th:each="alkio : ${joukko}"&gt;
            &lt;span th:text="${alkio}"&gt;hello world!&lt;/span&gt;
        &lt;/p&gt;
    &lt;/pre&gt;
    ...
                </pre>

                <p>Yllä käytämme attribuuttia nimeltä <code>joukko</code>, ja tulostamme yksitellen sen sisältämät alkiot.</p>

                <p><em>Huom! Eräs klassinen virhe on määritellä iteroitava joukko merkkijonona <code>th:each="alkio : joukko"</code>. Tämä ei luonnollisesti toimi.</em></p>

                <p>Iteroitavan joukon alkioiden ominaisuuksiin pääsee käsiksi aivan samalla tavalla kuin muiden model-olioon lisättävien attribuuttien. Tutkitaan seuraavaa esimerkkiä, jossa listaan lisätään kaksi henkilöä, lista lisätään pyyntöön, ja lopulta luodaan Thymeleafin avulla.</p>


                <pre class="sh_java">
    ...
    Person p = new Person();
    p.setName("James Gosling");

    Person p2 = new Person();
    p2.setName("Martin Odersky");

    List&lt;Person&gt; list = new ArrayList&lt;&gt;();
    list.add(p);
    list.add(p2);

    model.addAttribute("persons", list);
    ...
                </pre>

                <pre class="sh_xml">
    ...
    &lt;p&gt;And the talks are given by:&lt;/p&gt;
    &lt;ol&gt;
        &lt;li th:each="person : ${persons}"&gt;
            &lt;span th:text="${person.name}"&gt;has no name&lt;/span&gt;
        &lt;/li&gt;
    &lt;/ol&gt;
    ...
                </pre>

                <p>Käyttäjälle lähetettävä sivu näyttää palvelimella tapahtuneen prosessoinnin jälkeen seuraavalta.</p>


                <pre class="sh_xml">
    ...
    &lt;p&gt;And the talks are given by:&lt;/p&gt;
    &lt;ol&gt;
            &lt;li&gt;&lt;span&gt;James Gosling&lt;/span&gt;&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;Martin Odersky&lt;/span&gt;&lt;/li&gt;
    &lt;/ol&gt;
    ...
                </pre>


                <h2>Tietokannan käyttäminen</h2>

                <p>Vaikka sovelluksemme ovat melko huikeita, on samalla hieman tylsää, että sovelluksiin liittyvä tieto katoaa aina kun palvelin käynnistetään uudelleen. Tietokannat ovat palvelinohjelmistosta erillisiä sovelluksia, joiden ensisijainen tehtävä on varmistaa, että käytettävä tieto ei katoa. Otetaan ensiaskeleet tietokannan käyttöön web-palvelinohjelmistoissa -- tutustumme tietokantoihin tarkemmin myöhemmin kurssilla. Käytämme tietokantatoiminnallisuuden toteuttamisessa <a href="http://projects.spring.io/spring-data-jpa/" target="_blank">Spring Data JPA</a>-komponenttia, johon löytyy myös aloituspaketti käyttämästämme Spring Bootista.</p>

		<aside class="info">

		  <br/>

		  <h1>Spring Data JPA:n käyttöönotto</h1>

		  <p>Saadaksemme Spring Data JPA:n käyttöömme, tulee meidän lisätä se <code>pom.xml</code>-tiedostoon. Spring Bootin kautta löytyy näppärä paketti <code>spring-boot-starter-data-jpa</code>, joka vähentää yksittäisten riippuvuuksien lisäämistä. Tämän lisäksi tarvitsemme testikäyttöön sopivan tietokannan -- valitaan <a href="http://hsqldb.org/" target="_blank">HSQLDB</a>, jonka voi ladata muistiin sovelluksen käynnistyessä.</p>

		  <p>Lisätään projektiin seuraavat riippuvuudet:</p>

		  <pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.hsqldb&lt;/groupId&gt;
    &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>

		  <p>Kun projektin riippuvuudet noudetaan Mavenin avulla, on tietokanta valmis testikäyttöön.</p>

		</aside>

                <p>Jotta voimme tallentaa luokan ilmentymiä tietokantaan, meidän tulee asettaa luokalle <code>@Entity</code>-annotaatio, sekä tehdä sille tunnuskenttä, jonka avulla se voidaan yksilöidä. Voimme käyttää tunnuskentän luomiseen Spring Data JPA:n valmiiksi tarjoamaa <code>AbstractPersistable</code>-yliluokkaa, jota perittäessä kerromme uniikin tunnuksen tyypin. Esimerkiksi <code>Person</code>-luokasta voidaan tehdä tietokantaan tallennettava seuraavilla muutoksilla.</p>

                <pre class="sh_java">
package wad.domain;

import javax.persistence.Entity;
import org.springframework.data.jpa.domain.AbstractPersistable;

@Entity
public class Person extends AbstractPersistable&lt;Long&gt; {

    private String name;

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }
}</pre>

                <p>Kun käytössämme on tietokantaan tallennettava luokka, voimme luoda tietokannan käsittelyyn käytettävän <em>rajapinnan</em>. Kutsutaan tätä rajapintaoliota nimellä <code>PersonRepository</code>.</p>

                <pre class="sh_java">
// pakkaus

import wad.domain.Person;
import org.springframework.data.jpa.repository.JpaRepository;

public interface PersonRepository extends JpaRepository&lt;Person, Long&gt; {

}</pre>

                <p>Rajapinta perii Spring Data-projektin <code>JpaRepository</code>-rajapinnan; samalla kerromme, että tallennettava olio on tyyppiä <code>Person</code> ja että tallennettavan olion tunnus on <code>Long</code>-tyyppiä. Tämä tyyppi on sama kuin aiemmin <code>AbstractPersistable</code>-luokan perinnässä parametriksi asetettu tyyppi. Spring osaa käynnistyessään myös etsiä mm. JpaRepository-rajapintaluokan periviä luokkia. Jos niitä löytyy, se luo niiden pohjalta tietokannan käsittelyyn sopivan olion sekä asettaa olion ohjelmoijan haluamiin muuttujiin. Nämä muuttujat määritellään annotaatiolla <code>@Autowired</code> -- jokaiselle muuttujalle tulee oma annotaatio -- palaamme myöhemmin kurssilla tarkemmin tähän ns. olioiden automaattiseen asettamiseen.</p>

                <p>Kun olemme luoneet rajapinnan <code>PersonRepository</code>, voimme lisätä sen käyttöömme esimerkiksi kontrolleriluokkaan. Tämä tapahtuu seuraavasti.</p>

                <pre class="sh_java">
// ...

@Controller
@RequestMapping(value = "persons")
public class PersonController {

    @Autowired
    private PersonRepository personRepository;

    // ...
}</pre>

                <p>Nyt tietokantaan pääsee käsiksi <code>personRepository</code>-olion kautta. Osoitteessa <a href="http://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/JpaRepository.html" target="_blank">http://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/JpaRepository.html</a> on JpaRepository-rajapinnan API-kuvaus, mistä löytyy rajapinnan tarjoamien metodien kuvauksia. Voimme esimerkiksi toteuttaa tietokannassa olevien olioiden listauksen sekä yksittäisen olion haun seuraavasti:</p>

                <pre class="sh_java">
// ...

@Controller
@RequestMapping(value = "persons")
public class PersonController {

    @Autowired
    private PersonRepository personRepository;

    @RequestMapping(method = RequestMethod.GET)
    public String list(Model model) {
        model.addAttribute("list", personRepository.findAll());
        return "persons"; // erillinen persons.html
    }

    @RequestMapping(value = "/{id}", method = RequestMethod.GET)
    public String get(Model model, @PathVariable Long id) {
        model.addAttribute("person", personRepository.findOne(id));
        return "person"; // erillinen person.html
    }
}</pre>


                <h3>Tietokantatransaktiot ja tietokantaolioiden muuttaminen</h3>

                <p>Kun tietokannasta lataa olion, sen muuttaminen ei automaattisesti vie muutoksia takaisin tietokantaan. Esimerkiksi, seuraavassa kontrollerimetodissa <code>person</code>-oliolle tehdyt muutokset eivät tallennu tietokantaan.</p>

                <pre class="sh_java">
    @RequestMapping(value = "{id}/example", method = RequestMethod.POST)
    public String post(@PathVariable Long id) {
        Person p = personRepository.findOne(id);
        p.setName("example");
        // ..
        return "redirect:/person/" + id;
    }</pre>

                <p>Jos muutokset halutaan tallentaa tietokantaan, tulee olio joko tallentaa erikseen <code>personRepository</code>-olion <code>save</code>-metodilla, tai kontrollerimetodille asettaa annotaatio <code>@Transactional</code>. Annotaatio <code>@Transactional</code> määrittelee metodin toiminnallisuuden sellaiseksi, että kaikki metodin sisällä tapahtuvat asiat tapahtuvat tietokantatransaktion sisällä, jonka aikana tehdyt muutokset viedään tietokantaan metodin suorituksen lopuksi. Seuraavassa esimerkissä haetun henkilön nimi päivittyy tietokantaan.</p>

                <pre class="sh_java">
    @Transactional
    @RequestMapping(value = "{id}/example")
    public String post(@PathVariable Long id) {
        Person p = personRepository.findOne(id);
        p.setName("example");
        // ..
        return "redirect:/person/" + id;
    }</pre>



                <div class="tehtava">
                    <header>
                        <h1>
                            <a data-toggle="collapse" class="collapsed" href="#t-tehtavalista">
                                Tehtävälista
                            </a>
                        </h1>
                    </header>
                    <div id="t-tehtavalista" class="collapse">

                      <p>Tässä tehtävässä toteutetaan tehtävälistatoiminnallisuutta. Tehtäväpohjassa on valmis tietokantakonfiguraatio, missä käytetään muistiin ladattavaa tietokantaa -- tietokanta tyhjenee palvelimen sammuessa.</p>

                        <h1>Tehtävien listaaminen</h1>

                        <p>Toteuta <code>TaskController</code>-luokkaan <code>/tasks</code>-osoitteeseen tulevia GET-tyyppisiä pyyntöjä kuunteleva kontrollerimetodi. Pyynnön tulee lisätä <code>model</code>-parametriin <code>tasks</code> kaikki tietokannasta löytyvät tehtävät. Tässä <code>taskRepository</code>-olion <code>findAll</code>-metodi on hyödyksi. Palauta käyttäjälle kansiossa <code>src/main/resources/templates</code> olevasta <code>index.html</code>-tiedostosta luotu näkymä.</p>

                        <h1>Tehtävän lisääminen</h1>

                        <p>Toteuta <code>TaskController</code>-luokkaan <code>/tasks</code>-osoitteeseen tulevia POST-tyyppisiä pyyntöjä kuunteleva kontrollerimetodi. Pyynnön mukana tulee <code>name</code> ja <code>done</code>-parametrit, joiden pohjalta luodaan uusi tehtävä. Jos tehtävän nimi (<em>name</em>) ei ole tyhjä ja se ei ole null, tulee tehtävä tallentaa tietokantaan. Tässä <code>taskRepository</code>-olion <code>save</code>-metodi on hyödyksi.</p>

                        <p>Kun uusi tehtävä on lisätty, uudelleenohjaa pyyntö aiemmin toteuttamallesi tehtävät listaavalle kontrollerimetodille.</p>

                        <h1>Tehtävän poistaminen</h1>

                        <p>Toteuta <code>TaskController</code>-luokkaan <code>/tasks/{id}/delete</code>-osoitteeseen POST-tyyppisiä pyyntöjä kuunteleva kontrollerimetodi. Poistettavan tehtävän <code>id</code> on osana osoitetta. Tässä <code>taskRepository</code>-olion <code>delete</code>-metodi on hyödyksi.</p>

                        <p>Kun tehtävä on poistettu, uudelleenohjaa pyyntö aiemmin toteuttamallesi tehtävät listaavalle kontrollerimetodille.</p>

                        <h1>Tehtävän muuttaminen tehdyksi</h1>

                        <p>Toteuta <code>TaskController</code>-luokkaan <code>/tasks/{id}/done</code>-osoitteeseen POST-tyyppisiä pyyntöjä kuunteleva kontrollerimetodi. Tehtävän, joka tulee asettaa tehdyksi, <code>id</code> on osana osoitetta. Tässä <code>taskRepository</code>-olion <code>findOne</code>-metodi on hyödyksi.</p>

                        <p>Kun tehtävä on on asetettu tehdyksi, uudelleenohjaa pyyntö aiemmin toteuttamallesi tehtävät listaavalle kontrollerimetodille. Huom! Jotta tietokannasta hakemaasi olioon tehdyt muutokset päivittyvät, sinun tulee joko käyttää <code>@Transactional</code>-annotaatiota, tai tallentaa olio muutosten jälkeen.</p>
                    </div>
                </div>

                <h3>Tietokannassa olevat oliot ja toisiin olioihin viittaaminen</h3>

                <p>Kuten olio-ohjelmoinnissa yleensäottaen, tietokantaan tallennettavat oliot voivat viitata toisiinsa. Oletetaan, että käytössämme on <code>Person</code>-luokan lisäksi <code>VipList</code>-luokka, joka sisältää listan henkilöitä. Yhtä Vip-listaa kohden on monta henkilöä, joten merkitään yhteys <code>@OneToMany</code>-annotaatiolla. Palaamme myös yhteystyyppeihin myöhemmin kurssilla.</p>

                <pre class="sh_java">
package wad.domain;

import java.util.List;
import javax.persistence.Entity;
import javax.persistence.OneToMany;
import org.springframework.data.jpa.domain.AbstractPersistable;

@Entity
public class VipList extends AbstractPersistable&lt;Long&gt; {

    @OneToMany
    private List&lt;Person&gt; persons;

    public List&lt;Person&gt; getPersons() {
        return this.persons;
    }

    public void setPersons(List&lt;Person&gt; persons) {
        this.persons = persons;
    }
}</pre>

                <p>Täysin uuden henkilön luominen ja lisääminen vip-listalle tapahtuu seuraavasti. Oletetaan, että käytössämme on <code>personRepository</code>-olio henkilöiden hallintaan ja <code>vipListRepository</code>-vip-listojen hallintaan.</p>

                <pre class="sh_java">
    @Transactional
    @RequestMapping(value = "viplists/{id}/persons", method = RequestMethod.POST)
    public String post(@PathVariable Long id, @ModelAttribute Person person) {
        // tallennetaan henkilö ja otetaan viite tallennettuun olioon haltuun
        person = personRepository.save(person);
        // haetaan vip-lista ja lisätään henkilö listalle
        vipListRepository.findOne(id).getPersons().add(person);

        // ohjataan pyyntö sopivaan näkymään
        return "redirect:/viplists";
    }</pre>

                <p>Henkilön poistaminen vip-listalta tapahtuu vastaavasti.</p>

                <pre class="sh_java">
    @Transactional
    @RequestMapping(value = "viplists/{id}/persons/{personId}/delete", method = RequestMethod.POST)
    public String removePerson(@PathVariable Long id, @PathVariable Long personId) {
        person = personRepository.findOne(personId);
        vipListRepository.findOne(id).getPersons().remove(person);

        // ohjataan pyyntö sopivaan näkymään
        return "redirect:/viplists";
    }</pre>

                <p>Huom! Vaikka käytämme ensimmäisellä viikolla POST-pyyntöjä resurssien (esimerkiksi henkilöiden) poistamiseen, on käytäntö melko huono. Opimme myöhemmin parempia tapoja.</p>

                <p>Jos henkilö halutaan poistaa kokonaisuudessaan, tulee hänet ensin poistaa listoilta, joihin hän on lisätty. Palaamme taustasyihin myöhemmin...</p>

                <div class="tehtava">
                    <header>
                        <h1>
                            <a data-toggle="collapse" class="collapsed" href="#t-albumilista">
                                Albumilista
                            </a>
                        </h1>
                    </header>
                    <div id="t-albumilista" class="collapse">

                        <p>Muokattavaan albumilistasovellukseen on toteutettu jo albumien lisääminen ja listaaminen. Tässä tehtävässä lisätään albumeihin kappaleita. Älä huoli <code>wad.profiles</code>-pakkauksen alla olevista tiedostoista tai muista projektiin lisätyistä uusista riippuvuuksista :).</p>

                        <h1>Kappaleen lisääminen</h1>

                        <p>Lisää <code>AlbumController</code>-luokkaan kontrollerimetodi, joka kuuntelee POST-tyyppisiä pyyntöjä osoitteeseen <code>/albums/{albumId}/tracks</code>, missä <code>albumId</code> on olemassaolevan albumin tunnus. Pyynnöissä tulee mukana <code>name</code>-niminen parametri, jonka arvona on lisättävän kappaleen nimi.</p>

                        <p>Tallenna lisättävä kappale tietokantaan ja lisää se albumille, jonka tunnus (<em>id</em>) on sama kuin polussa oleva {albumId}.</p>

                        <p>Kun kappale on lisätty albumille, ohjaa pyyntö edelleen albumit listaavalle kontrollerimetodille.</p>


                        <h1>Kappaleen poistaminen</h1>


                        <p>Lisää <code>AlbumController</code>-luokkaan kontrollerimetodi, joka kuuntelee POST-tyyppisiä pyyntöjä osoitteeseen <code>/albums/{albumId}/tracks/{trackId}/delete</code>, missä <code>albumId</code> on olemassaolevan albumin tunnus, ja <code>trackId</code> on poistettavan kappaleen tunnus.</p>

                        <p>Kun kontrollerimetodia kutsutaan, tulee sen poistaa annettu kappale annetulta albumilta. Huomaa, että kappale tulee sekä poistaa albumilta, että poistaa kappaletietokannasta.</p>

                        <p>Kun kappale on poistettu, ohjaa pyyntö edelleen albumit listaavalle kontrollerimetodille.</p>
                    </div>
                </div>

                <h2>Sovelluksen siirtäminen verkkoon</h2>

                <p>Albumilistamme, kuten muutkin sovelluksemme, on melko jepa, mutta olisi kiva näyttää sitä myös jollekin muulle. Tutustutaan tämän viikon lopuksi sovelluksen verkkoon siirtämiseen. Tarvitset tässä tunnukset <a href="https://www.heroku.com/" target="_blank">Heroku</a>-palveluun, joka tarjoaa ilmaisen sijoituspaikan vähän resursseja kuluttaville sovelluksille.</p>

                <p>Kun olet luonut tunnuksen Herokuun, asenna osoitteesta <a href="https://toolbelt.heroku.com/" target="_blank">https://toolbelt.heroku.com/</a> työvälineet sovelluksen Herokuun siirtämiseen. Seuraa myös sivun "Getting started"-ohjetta, ja suorita sen <code>heroku login</code>-osio.</p>

                <p>Mene tämän jälkeen Albumilista-tehtävän kansioon, missä on myös tiedosto <code>pom.xml</code>. Kirjoita kansiossa komento <code>git init</code>, mikä lisää kansioon versionhallintakansion <code>.git</code>.</p>

                <pre>        
avihavai@aavikkokettu:<em>polku</em>/W1E08.Albumilista$ git init
Initialized empty Git repository in <em>polku</em>/W1E08.Albumilista/.git/</pre>

                <p>Kirjoita tämän jälkeen komento <code>heroku create</code>, mikä luo paikan minne sovelluksen voi lähettää.</p>

                <pre>       
avihavai@aavikkokettu:<em>polku</em>/W1E08.Albumilista$ heroku create
Creating aqueous-lowlands-6350... done, stack is cedar
http://aqueous-lowlands-6350.herokuapp.com/ | git@heroku.com:aqueous-lowlands-6350.git</pre>

                <p>Komennolla <code>git remote add heroku git@heroku.com:aqueous-lowlands-6350.git</code> lisätään juuri luotu heroku-sijainti projekti käyttöömme. Huomaa, että <code>git@heroku.com:aqueous-lowlands-6350.git</code> on sama kuin komennon <code>heroku create</code> tulostama sijainti.</p>

                <pre>       
avihavai@aavikkokettu:<em>polku</em>/W1E08.Albumilista$ git remote add heroku git@heroku.com:aqueous-lowlands-6350.git
avihavai@aavikkokettu:<em>polku</em>/W1E08.Albumilista$</pre>        

                <p>Nyt voimme lisätä sovelluksen verkkoon. Jos tehtäväkansiossa on target-kansio, poista se tässä välissä. Kirjoita seuraavaksi komento <code>git add .</code>, jonka jälkeen komento <code>git commit -m "initial commit"</code>. Näillä komennoilla lisäät sovelluksen nykyisen version versionhallintaan. Kirjoita tämän jälkeen <code>git push heroku master</code>, mikä lähettää sovelluksen verkkoon.</p>

                <pre>       
avihavai@aavikkokettu:<em>polku</em>/W1E08.Albumilista$ git add .
avihavai@aavikkokettu:<em>polku</em>/W1E08.Albumilista$ git commit -m "initial commit"
[master (root-commit) 2cbc76b] initial commit
 tulostusta...
avihavai@aavikkokettu:<em>polku</em>/W1E08.Albumilista$ git push heroku master
 tulostusta...
-----> Discovering process types
       Procfile declares types -> web

-----> Compressing... done, 135.6MB
-----> Launching... done, v6
       http://aqueous-lowlands-6350.herokuapp.com/ deployed to Heroku
 hieman tulostusta</pre>

                <p>Nyt, voimme käydä tarkistamassa sovelluksen herokun palvelussa. Yllä olevassa esimerkissä sovellus on lisätty osoitteeseen <a href="http://aqueous-lowlands-6350.herokuapp.com/" target="_blank">http://aqueous-lowlands-6350.herokuapp.com/</a>.</p>
            </section>
            <!-- END WEEK1 -->


            <!-- BEGIN WEEK2 -->
            <section class="weeklimit" data-week-id="2">
                <header>
                    <h1 id="viikko2">Viikko 2</h1>
                </header>
		
                <aside class="info">
		  
		  <br/>
                  <h1>Muutama sana sovelluksen logikonfiguraatiosta</h1>
		  
                  <p>Sovelluksen sisäisen sielunelämän näkeminen vaatii sovelluksen logikonfiguraation määrittelyä. Oma konfiguraatiotiedosto <code>application.properties</code> löytyy kansiosta <code>src/main/resources</code>, ja siellä määritellään muunmuassa Thymeleafin käyttöön liittyviä komentoja.</p>
		  
		  <p>Tämän lisäksi, tiedostolla voidaan ohjata muunmuassa minkälaisia viestejä sovelluksen logeissa näytetään. Esimerkiksi tietokantakyselyitä Spring Data JPA:n alla tekevän Hibernate-kirjaston tietokantakyselyt saadaan näkyviksi seuraavilla komennoilla. Komento <code>logging.file=</code> ohjaa viestit konsoliin.</p>
		  
                  <pre>
logging.level.org.springframework.web.servlet.DispatcherServlet=DEBUG
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type=TRACE
logging.file=</pre>

                  <p>Jos haluat tietoosi <em>kaiken</em> mitä sovelluksessa tapahtuu, muokkaa logikonfiguraatio seuraavanlaiseksi:</p>
		  
                  <pre>
logging.level.=TRACE
logging.file=</pre>

                </aside>
		
                <hr/>

                <h1>Kerrosarkkitehtuuri</h1>

                <p>Kerrosarkkitehtuuria noudattamalla pyritään tilanteeseen, missä sovellus on jaettu itsenäisiin kerroksiin, jotka toimivat vuorovaikutuksessa muiden kerrosten kanssa. Käyttöliittymäkerros sisältää näkymät (esim. Thymeleafin html-sivut) sekä mahdollisen logiikan tiedon näyttämiseen (esim tägit html-sivuilla). Käyttöliittymä näkyy käyttäjän selaimessa, ja käyttäjän selain tekee palvelimelle pyyntöjä käyttöliittymässä tehtyjen klikkausten ja muiden toimintojen pohjalta. Palvelimella toimivan sovelluksen kontrollerikerros ottaa vastaan nämä pyynnöt, ja ohjaa ne eteenpäin sovelluksen sisällä. Tällä kurssilla kerrosarkkitehtuurilla tarkoitetaan yleisesti ottaen seuraavaa jakoa:</p>

                <ul>
                    <li>Käyttöliittymäkerros</li>
                    <li>Kontrollerikerros</li>
                    <li>Sovelluslogiikka ja palvelut</li>
                    <li>Tietokanta-abstraktio ja tietokantapalvelut</li>
                </ul>

                <p>Kerrosarkkitehtuuria noudattaessa ylempi kerros hyödyntää alemman kerroksen tarjoamia toiminnallisuuksia, mutta alempi kerros ei hyödynnä ylempien kerrosten tarjoamia palveluita. Puhtaassa kerrosarkkitehtuurissa kaikki kerrokset ovat olemassa, ja kutsut eivät ohita kerroksia ylhäältä alaspäin kulkiessaan. Tällä kurssilla noudatamme avointa kerrosarkkitehtuuria, missä kerrosten ohittaminen on sallittua.</p>


                <p>Tutustutaan seuraavaksi näihin hieman tarkemmin.</p>


                <h2>Kontrollerikerros</h2>

                <p>Kontrollerien ensisijaisena vastuuna on pyyntöjen kuuntelu, pyyntöjen ohjaaminen sopiville palveluille, sekä tuotetun tiedon ohjaaminen oikealle näkymälle tai näkymän generoivalle komponentille.</p>

                <p>Jotta palveluille ei ohjata epäoleellista dataa, esimerkiksi huonoja arvoja sisältäviä parametreja, on kontrolleritason vastuulla myös pyynnössä olevien parametrien validointi.</p>

                <h3>Pyyntöparametrien validointi</h3>

                <p>Lomakkeiden ja lähetettävän datan validointi, eli oikeellisuuden tarkistaminen, on tärkeää. Ensimmäinen askel -- jonka olemme jo ottaneet -- on tallennettavan datan esittäminen ohjelmaan liittyvien käsitteiden kautta. Olemme käyttäneet datan tallentamisessa olioita, joihin on määritelty sopivat kenttien tyypit. Tämä helpottaa työtämme jo hieman: esimerkiksi numerokenttiin ei saa asetettua merkkijonoja. Käyttämämme Spring Bootin mukana tulee <a href="http://hibernate.org/" target="_blank">Hibernate</a>-projektin komponentti, joka tarjoaa validointitoiminnallisuuden.</p>

                <p>Validaatiosääntöjen määrittely tapahtuu annotaatioilla. Muokataan alla määriteltyä luokkaa <code>Person</code> siten, että henkilöllä tulee olla henkilötunnus, nimi ja sähköpostiosoite.</p>


                <pre class="sh_java">
// pakkaus jne
public class Person {

    private String socialSecurityNumber;
    private String name;
    private String email;

    // getterit ja setterit
}</pre>


                <p>Sovitaan että henkilötunnus ei saa koskaan olla tyhjä ja sen tulee olla tasan 11 merkkiä pitkä. Nimen tulee olla vähintään 5 merkkiä pitkä, ja korkeintaan 30 merkkiä pitkä, ja sähköpostiosoitteen tulee olla validi sähköpostiosoite. Annotaatio <code>@NotBlank</code> varmistaa ettei annotoitu attribuutti ole tyhjä -- lisätään se kaikkiin kenttiin. Annotaatiolla <code>@Length</code> voidaan määritellä pituusrajoitteita muuttujalle, ja annotaatiolla <code>@Email</code> varmistetaan, että attribuutin arvo on varmasti sähköpostiosoite.</p>


                <pre class="sh_java">
// pakkaus

import org.hibernate.validator.constraints.Email;
import org.hibernate.validator.constraints.Length;
import org.hibernate.validator.constraints.NotBlank;

public class Person {

    @NotBlank
    @Length(min = 11, max = 11)
    private String socialSecurityNumber;

    @NotBlank
    @Length(min = 5, max = 30)
    private String name;

    @NotBlank
    @Email
    private String email;

    // getterit ja setterit</pre>


                <h3>Olion validoinnin päälle kytkeminen tapahtuu kontrollerissa</h3>

                <p>Kontrollerimetodit validoivat olion jos kontrollerimetodissa olevalle <code>@ModelAttribute</code>-annotaatiolla merkatulle oliolle on asetettu myös annotaatio <code>@Valid</code> (<code>javax.validation.Valid</code>).</p>

                <pre class="sh_java">
    @RequestMapping(method = RequestMethod.POST)
    public String create(@Valid @ModelAttribute Person person) {
        // .. esimerkiksi tallennus ja uudelleenohjaus
    }</pre>

                <p>Spring validoi olion pyynnön vastaanottamisen yhteydessä, mutta validointivirheet eivät ole kovin kaunista luettavaa. Yllä olevalla kontrollerimetodilla virheellisen nimen kohdalla saamme hieman kaoottisen ilmoituksen.</p>

                <pre>
Whitelabel Error Page

This application has no explicit mapping for /error, so you are seeing this as a fallback.

<em>aika</em>
There was an unexpected error (type=Bad Request, status=400).
Validation failed for object='person'. Error count: 1</pre>

		<p>Virheelle täytyy selvästi tehdä jotain..</p>


                <h3>Validointivirheiden käsittely</h3>


                <p>Validointivirheet aiheuttavat poikkeuksen, joka näkyy ylläolevana virheviestinä, jos niitä ei erikseen käsitellä. Validointivirheiden käsittely tapahtuu luokan <code>BindingResult</code> avulla, joka toimii validointivirheiden tallennuspaikkana. Luokan <code>BindingResult</code> kautta voimme käsitellä virheitä. <code>BindingResult</code>-olio kuvaa aina yksittäisen olion luomisen ja validoinnin onnistumista, ja se tulee asettaa heti validoitavan olion jälkeen. Seuraavassa esimerkki kontrollerista, jossa validoinnin tulos lisätään automaattisesti <code>BindingResult</code>-olioon.</p>

                <pre class="sh_java">
    @RequestMapping(method = RequestMethod.POST)
    public String create(@Valid @ModelAttribute Person person, BindingResult bindingResult) {
        if(bindingResult.hasErrors()) {
            // validoinnissa virheitä: virheiden käsittely
        }

        // muu toteutus
    }</pre>

                <p>Ylläolevassa esimerkissä kaikki validointivirheet tallennetaan <code>BindingResult</code>-olioon. Oliolla on metodi <code>hasErrors</code>, jonka perusteella päätämme jatketaanko pyynnön prosessointia vai ei. Yleinen muoto lomakedataa tallentaville kontrollereille on seuraavanlainen:</p>

                <pre class="sh_java">
    @RequestMapping(method = RequestMethod.POST)
    public String create(@Valid @ModelAttribute Person person, BindingResult bindingResult) {
        if(bindingResult.hasErrors()) {
            return "lomakesivu";
        }

        // .. esimerkiksi tallennus

        return "redirect:/index";
    }</pre>

                <p>Yllä oletetaan että lomake lähetettiin näkymästä <em>"lomakesivu"</em>: käytännössä validoinnin epäonnistuminen johtaa nyt siihen, että pyyntö ohjataan takaisin lomakesivulle.</p>


                <h3>Thymeleaf-lomakkeet ja BindingResult</h3>


                <p>Lomakkeiden validointivirheet saadaan käyttäjän näkyville Thymeleafin avulla. Lomakkeet määritellään kuten normaalit HTML-lomakkeet, mutta niihin lisätään muutama apuväline. Lomakkeen attribuutti <code>th:object</code> kertoo olion, johon lomakkeen kentät tulee pyrkiä liittämään (huom! tämän tulee olla määriteltynä myös lomakkeen palauttavassa kontrollerimetodissa -- palaamme tähän kohta). Sitä käytetään yhdessä kontrolleriluokan <code>ModelAttribute</code>-annotaation kanssa. Lomakkeen kentät määritellään attribuutin <code>th:field</code> avulla, jossa oleva <code>*{arvo}</code> liitetään lomakkeeseen liittyvään olioon. Oleellisin virheviestin näkymisen kannalta on kuitenkin attribuuttiyhdistelmä <code>th:if="${#fields.hasErrors('arvo')}" th:errors="*{arvo}"</code>, joka näyttää virheviestin jos sellainen on olemassa.</p>

                <p>Luodaan lomake aiemmin nähdyn <code>Person</code>-olion luomiseen.</p>


                <pre class="sh_xml">
&lt;form action="#" th:action="@{/persons}" th:object="${person}" method="POST"&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;SSN: &lt;/td&gt;
            &lt;td&gt;&lt;input type="text" th:field="*{socialSecurityNumber}" /&gt;&lt;/td&gt;
            &lt;td th:if="${#fields.hasErrors('socialSecurityNumber')}" th:errors="*{socialSecurityNumber}"&gt;SSN Virheviesti&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;Name: &lt;/td&gt;
            &lt;td&gt;&lt;input type="text" th:field="*{name}" /&gt;&lt;/td&gt;
            &lt;td th:if="${#fields.hasErrors('name')}" th:errors="*{name}"&gt;Name Virheviesti&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;Email: &lt;/td&gt;
            &lt;td&gt;&lt;input type="text" th:field="*{email}" /&gt;&lt;/td&gt;
            &lt;td th:if="${#fields.hasErrors('email')}" th:errors="*{email}"&gt;Email Virheviesti&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;&lt;button type="submit"&gt;Submit&lt;/button&gt;&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form&gt;</pre>

                <p>Yllä oleva lomake lähettää lomakkeen tiedot osoitteessa <code>&lt;sovellus&gt;/persons</code> olevalle kontrollerimetodille. Lomakkeelle tullessa tarvitsemme erillisen tiedon käytössä olevasta oliosta. Alla on näytetty sekä kontrollerimetodi, joka ohjaa GET-pyynnöt lomakkeeseen, että kontrollerimetodi, joka käsittelee POST-tyyppiset pyynnöt. Huomaa erityisesti <code>@ModelAttribute</code>-annotaatio kummassakin metodissa. Metodissa <code>view</code> olion nimi on <code>person</code>, joka vastaa lomakkeessa olevaa <code>th:object</code>-attribuuttia. Tämän avulla lomake tietää, mitä oliota käsitellään.</p>

                <pre class="sh_java">
    @RequestMapping(method = RequestMethod.GET)
    public String view(@ModelAttribute Person person) {
        return "lomake";
    }

    @RequestMapping(method = RequestMethod.POST)
    public String create(@Valid @ModelAttribute Person person, BindingResult bindingResult) {
        if(bindingResult.hasErrors()) {
            return "lomake";
        }

        // .. tallennus ja uudelleenohjaus
    }</pre>

                <p>Jos lomakkeella lähetetyissä kentissä on virheitä, virheet tallentuvat <code>BindingResult</code>-olioon. Tarkistamme kontrollerimetodissa <code>create</code> ensin virheiden olemassaolon -- jos virheitä on, palataan takaisin lomakkeeseen. Tällöin validointivirheet tuodaan lomakkeen käyttöön <code>BindingResult</code>-oliosta, jonka lomakkeen kentät täytetään <code>@ModelAttribute</code>-annotaatiolla merkitystä oliosta. Huomaa että virheet ovat pyyntökohtaisia, ja uudelleenohjauspyyntö kadottaa virheet.</p>

                <p><strong>Huom!</strong> Springin lomakkeita käytettäessä lomakesivut haluavat käyttöönsä olion, johon data kytketään jo sivua ladattaessa. Yllä lisäsimme pyyntöön <code>Person</code>-olion seuraavasti:</p>

                <pre class="sh_java">
    @RequestMapping(method = RequestMethod.GET)
    public String view(@ModelAttribute Person person) {
        return "lomake";
    }</pre>

                <p>Toinen vaihtoehto on luoda kontrolleriluokkaan erillinen metodi, jonka sisältämä arvo lisätään automaattisesti pyyntöön. Tällöin lomakkeen näyttävä kontrollerimetodi ei tarvitse erikseen ModelAttribute-parametria. Tällöin toteutus olisi esimerkiksi seuraavanlainen:</p>

                <pre class="sh_java">
    @ModelAttribute
    private Person getPerson() {
        return new Person();
    }
        
    @RequestMapping(method = RequestMethod.GET)
    public String view() {
        return "lomake";
    }

    @RequestMapping(method = RequestMethod.POST)
    public String create(@Valid @ModelAttribute Person person, BindingResult bindingResult) {
        if(bindingResult.hasErrors()) {
            return "lomake";
        }

        // .. tallennus ja uudelleenohjaus
    }</pre>


                <p>Thymeleafin avulla tehdyistä lomakkeista ja niiden yhteistyöstä Springin kanssa löytyy lisää osoitteesta <a href="http://www.thymeleaf.org/doc/tutorials/2.1/thymeleafspring.html#creating-a-form" target="_blank">http://www.thymeleaf.org/doc/tutorials/2.1/thymeleafspring.html#creating-a-form</a>.</p>


                <h3>Validointi ja entiteetit</h3>

                <p>Vaikka edellisessä esimerkissä käyttämäämme <code>Person</code>-luokkaa ei oltu merkitty <code>@Entity</code>-annotaatiolla -- eli se ei ollut tallennettavissa JPAn avulla tietokantaan -- mikään ei estä meitä lisäämästä sille <code>@Entity</code>-annotaatiota. Toisaalta, lomakkeet voivat usein sisältää tietoa, joka liittyy useaan eri talletettavaan olioon. Tällöin voi luoda erillisen lomakkeen tietoihin liittyvän <em>lomakeolio</em>, jonka pohjalta luodaan tietokantaan tallennettavat oliot kunhan validointi onnistuu. Erilliseen lomakeobjektiin voi täyttää myös kannasta haettavia listoja ym. ennalta.</p>

                <p>Kun validointisäännöt määritellään entiteetille, tapahtuu validointi kontrollerin lisäksi myös tietokantatallennusten yhteydessä.</p>


		<aside class="info">
		  <br/>
		  <h1>Spring Loaded</h1>

		  <p>Tehtäväpohjissa olevassa <code>pom.xml</code>-konfiguraatiossa on mukana <a href="https://github.com/spring-projects/spring-loaded" target="_blank">Spring Loaded</a>-kirjasto, jonka ansiosta -- kun se toimii -- lähdekoodissa tehtyjä muutoksia ladataan automaattisesti palvelimelle. Komponentti ei kuitenkaan ole vielä erinomaisessa kunnossa. Jos ohjelma ei toimi koneellasi, tai sovellukset eivät lähde käyntiin (erit. jos käy käyttöjärjestelmänä on Windows), voi seuraavat rivit kommentoida pois <code>pom.xml</code>-tiedostosta:</p>
		 
<pre class="sh_xml">
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;springloaded&lt;/artifactId&gt;
        &lt;version&gt;1.2.4.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
&lt;executions&gt;
    &lt;execution&gt;
        &lt;goals&gt;
            &lt;goal&gt;repackage&lt;/goal&gt;
        &lt;/goals&gt;
    &lt;/execution&gt;
&lt;/executions&gt;
</pre>

		  <p>Toisaalta, jos käytät esimerkiksi tietojenkäsittelytieteen laitoksella olevia laitteita, on hyvä kokeilla käynnistää sovellukset komentoriviltä komennolla <code>mvn spring-boot:run</code> ja kokeilla tehdä pieniä muutoksia esimerkiksi kontrolleriluokkien koodiin -- ja testata muutoksia heti selaimessa ilman palvelimen uudelleenkäynnistystä.</p>

		  <p>Jos kyseinen vaihtoehto ei toimi, muita mahdollisuuksia ovat mm. <a href="http://www.hotswapagent.org/" target="_blank">HotswapAgent</a> ja <a href="http://zeroturnaround.com/software/jrebel/" target="_blank">JRebel</a>, joista jälkimmäinen on maksullinen.</p>


		</aside>

                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1 class="panel-title">
                                <a data-toggle="collapse" class="collapsed" href="#t-ilmoittautuminen">
                                    Ilmoittautuminen
                                </a>
                            </h1>
                        </header>
                        <div id="t-ilmoittautuminen" class="collapse">

                            <p>Tehtävän mukana tulee sovellus, jota käytetään ilmoittatumiseen. Tällä hetkellä käyttäjä voi ilmoittautua juhliin oikeastaan minkälaisilla tiedoilla tahansa. Tehtävänäsi on toteuttaa parametreille seuraavanlainen validointi:</p>

                            <ol>
                                <li>Nimen (<code>name</code>) tulee olla vähintään 4 merkkiä pitkä ja enintään 30 merkkiä pitkä.</li>
                                <li>Osoitteen (<code>address</code>) tulee olla vähintään 4 merkkiä pitkä ja enintään 50 merkkiä pitkä.</li>
                                <li>Sähköpostiosoitteen (<code>email</code>) tulee olla validi sähköpostiosoite.</li>
                            </ol>


                            <p>Tehtäväpohjan mukana tuleviin sivuihin on toteutettu valmiiksi lomake. Tehtävänäsi on toteuttaa validointitoiminnallisuus pakkauksessa <code>wad.domain</code> olevaan luokkaan <code>Registration</code>.</p>

                            <p>Jos yksikin tarkastuksista epäonnistuu, tulee käyttäjälle näyttää rekisteröitymislomake uudelleen. Muista lisätä kontrolleriin validoitavalle parametrille annotaatio <code>@Valid</code>. Virheviestien ei tule näkyä vastauksessa jos lomakkeessa ei ole virhettä. Käyttöliittymä on tehtävässä valmiina.</p>

                        </div>
                    </div>
                </div>

                <h3>Uudelleenohjaukset kontrollerimetodeissa</h3>

                <p>Kun käyttäjä ohjataan tekemään uusi pyyntö <code>redirect:</code>-komennon avulla, palvelin palauttaa selaimelle HTTP statuskoodin 303 (tai 302) ja osoitteen. Tämä aiheuttaa sen, että selain tekee pyynnön uuteen osoitteeseen. Koska HTTP on <em>tilaton protokolla</em>, ei sillä ole välineistöä käyttäjän pyyntöjen yhdistämiseen: aiemmassa pyynnössä käytössä oleva data ei ole käytössä seuraavassa pyynnössä.</p>

                <p>Tämä on yleensä täysin hyväksyttävää, ja toivottavaakin, mutta joissain tapauksissa ohjelmoija haluaa aiemmasta pyynnöstä tietoja myös seuraavaan pyyntöön. Tyypillinen käyttötapaus on tietyn informaatioviestin lisääminen sivulle, johon käyttäjä ohjataan. Yksi vaihtoehto on <code>RedirectAttributes</code>-parametrin lisääminen kontrollerimetodille. RedirectAttributes-olioon voi lisätä attribuutteja, jotka halutaan käyttäjän seuraavan pyynnön käyttöön. Käytännössä <code>RedirectAttributes</code>-olio tallentaa attribuutit <em>sessioon</em>, josta ne lisätään <code>Model</code>-olion attribuutteihin seuraavan pyynnön yhteydessä.</p>

                <p>Pohditaan tilannetta, jossa olemme luomassa uutta <code>Person</code>-oliota. Kun olio on luotu, käyttäjä ohjataan suoraan sivulle, jossa on juuri luodun olion tiedot. Tämän lisäksi, kun käyttäjä tulee sivulle ensimmäisen kerran, sivulla näytetään myös viesti "New person created!". Oletetaan, että <code>Person</code>-luokka on seuraavanlainen.</p>

                <pre class="sh_java">
// pakkaus

// importit

@Entity
public class Person extends AbstractPersistable&lt;Long&gt; {

    @NotBlank
    @Length(min = 11, max = 11)
    private String socialSecurityNumber;

    @NotBlank
    @Length(min = 5, max = 30)
    private String name;

    @NotBlank
    @Email
    private String email;

    // getterit ja setterit</pre>


                <p>Muokataan <code>PersonController</code>-luokan <code>create</code> metodia siten, että se saa parametrina <code>RedirectAttributes</code>-olion. Parametrina saatu <code>Person</code>-olio tallennetaan. Tämän jälkeen asetamme <code>RedirectAttributes</code>-oliolle kaksi attribuuttia.</p>

                <p>Normaali attribuutti, joka lisätään metodilla <code>addAttribute</code> on käytössä tämän pyynnön loppuun asti. Alla olevassa esimerkissä lisäämme attribuutin <code>id</code>, jonka Spring myöhemmin asettaa osaksi osoitetta, johon käyttäjä ohjataan. Tällöin pyyntö ohjautuu juuri luotua <code>Person</code>-oliota käsittelevälle sivulle. Toinen attribuutti, joka lisätään metodilla <code>addFlashAttribute</code>, on käytössä vain seuraavan pyynnön ajan. Attribuutti <code>message</code> löytyy automaattisesti seuraavan pyynnön model-oliosta.</p>

                <pre class="sh_java">
// pakkaus ja importit

@Controller
@RequestMapping("/persons")
public class PersonController {

    @Autowired
    private PersonRepository personRepository;

    // lomakkeen näyttäminen

    @RequestMapping(method = RequestMethod.POST)
    public String create(RedirectAttributes redirectAttributes,
            @Valid @ModelAttribute Person person,
            BindingResult bindingResult) {
        if(bindingResult.hasErrors()) {
            return "form";
        }

        person = personRepository.save(person);

        redirectAttributes.addAttribute("id", person.getId());
        redirectAttributes.addFlashAttribute("message", "New person created!");
        return "redirect:person/{id}";
    }

// muut metodit
                </pre>

                <p>Jos osoitetta <code>persons/{id}</code> kuuntelee kontrollerimetodi, se saa käyttöönsä attribuutin <code>message</code> <em>ensimmäisellä kerralla kun käyttäjä päätyy sivulle</em>. Kontrollerimetodi, joka kuuntelee osoitetta <code>persons/{id}</code> voi olla esimerkiksi seuraavanlainen.</p>

                <pre class="sh_java">
    // ...
    @RequestMapping(value = "/{personId}", method = RequestMethod.GET)
    public String viewPerson(Model model, @PathVariable Long personId) {
        model.addAttribute("person", personRepository.findOne(personId));
        return "form";
    }

    // ...
                </pre>

                <p>Sivu <code>person.html</code> voi näyttää esimerkiksi seuraavanlaiselta (huomaa mielikuvituksen puute):</p>

                <pre class="sh_xml">
&lt;!DOCTYPE html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"/&gt;
        &lt;title th:text="${person.name}"&gt;person name&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;&lt;span th:text="${person.name}"&gt;person name&lt;/span&gt; &lt;span th:if="${message}" th:text="${message}"&gt;le viesti&lt;/span&gt;&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre>


                <p>Oleellista tässä on se, että kun käyttäjä luo uuden <code>Person</code> olion, hänet ohjataan sivulle, joka näyttää käyttäjän tiedot. Sivun voi tallentaa kirjanmerkiksi, sillä sivu on aina olemassa. Kuitenkin ensimmäisellä kerralla käyttäjän tullessa sivulle, eli juuri silloin, kun käyttäjä on luotu, sivulla näkyy myös käyttäjäystävällinen viesti <code>"New person created!"</code>.</p>

                <div class="tehtava">
                    <header>
                        <h1>
                            <a data-toggle="collapse" class="collapsed" href="#t-tilauspalvelu">
                                Tilauspalvelu
                            </a>
                        </h1>
                    </header>
                    <div id="t-tilauspalvelu" class="collapse">

                        <p>Parannellaan erään tilauspalvelun toimintaa.</p>

                        <h1>Validointi</h1>

                        <p>Tällä hetkellä käyttäjän syöttämiä tietoja ei validoida millään tavalla. Lisää sovellukseen tilauksen (<code>Order</code>) validointi seuraavasti:</p>

                        <ul>
                            <li>Nimen (<code>name</code>) tulee olla vähintään 4 merkkiä ja enintään 30 merkkiä pitkä.</li>
                            <li>Osoitteen (<code>address</code>) tulee olla vähintään 4 merkkiä ja enintään 50 merkkiä pitkä.</li>
                            <li>Tilatut esineet (<code>items</code>) ei saa olla tyhjä.</li>
                        </ul>

                        <p>Jos joku edelläolevista ehdoista ei täyty, näytä käyttäjälle lomake siten, että siinä näkyy virheviestit ja jo syötetyt tiedot. Käyttöliittymä on rakennettu puolestasi, joten sinun tarvitsee muokata vain luokkia <code>OrderController</code> ja <code>Order</code>. Huom! Kannattanee käyttää <code>@NotEmpty</code>-annotaatiota esineiden tyhjyyden tarkistamiseen.</p>


                        <h1>POST, Redirect, GET</h1>


                        <p>Muuta sovellusta siten, että lomakkeen lähetyksen onnistuessa käyttäjä ohjataan erilliseen osoitteeseen, jossa näkyy hänen juuri tekemänsä ostos. Käyttäjän tulee pystyä asettamaan osoite kirjanmerkiksi, eli sen tulee olla pysyvä. Kun käyttäjä ohjautuu sivulle ensimmäistä kertaa, sivulla tulee näkyä viesti <code>Order placed!</code>. Toteuta uudelleenohjaus käyttämällä <code>RedirectAttributes</code> luokkaa osana toteutusta: aseta attribuutiksi <code>orderId</code> luodun tilauksen <code>id</code>, sekä lisää pyyntöön flash-attribuutti <code>message</code>, joka sisältää viestin <code>Order placed!</code>. Joudut myös muokkaamaan metodin palauttamaa merkkijonoa sopivasti.</p>

                    </div>
                </div>


                <h3>PUT ja DELETE HTML-lomakkeissa</h3>

                <p>Selaimet tekevät vain GET- ja POST-tyyppisiä pyyntöjä, mutta HTTP-spesifikaatiossa on myös mm. DELETE ja PUT metodit.</p>

		<p>Haluamme toteuttaa kontrollerin metodit siten, että käytetyt metodit vastaavat todellista toiminnallisuutta. Esimerkiksi elementin poistaminen on hyvä toteuttaa DELETE-tyyppisillä pyynnöillä: tällöin kuvataan todellista toimintaa. Sovelluskehykset tarjoavat tuen pyyntötyyppien muokkaukseen siten, että lomakkeisiin asetetaan pyynnön tyypin määrittelevä attribuutti.</p>

                <p>Pyyntötyypin muuttaminen onnistuu <code>th:method</code>-attribuutin avulla. Tällöin lomakkeet voidaan muokata siten, että niiden mukana tulevat tiedot kertovat Springille, että pyyntö tulee käsitellä PUT- tai DELETE-pyyntöjä käsittelevissä metodeissa. 

. Esimerkiksi seuraavaa lomaketta voisi käyttää henkilön poistamiseen.</p>

                <pre class="sh_xml">
    &lt;form ... th:method="DELETE"&gt;
        &lt;input type="submit"&gt;
    &lt;/form:form&gt;
                </pre>

                <p>Käytännössä tämä luo lomakkeelle piilokentän, jonka nimenä on <code>_method</code> ja arvona <code>DELETE</code>; pyyntö muunnetaan ennen pyynnön ohjaamista kontrollerimetodille.</p>

                <pre class="sh_xml">
    &lt;form ... method="post"&gt;
        &lt;input type="hidden" name="_method" value="DELETE"/&gt;
        &lt;input type="submit"/&gt;
    &lt;/form&gt;
                </pre>


                <p>Huom! Kun toteutat PUT- tai DELETE-tyyppisiä pyyntöjä käsitteleviä kontrollerimetodeja, ohjaa käyttäjä tekemään uusi GET-pyyntö metodin lopussa.</p>



                <h2>Palvelukerros</h2>


                <p>Palvelukerros tarjoaa kontrollerikerrokselle palveluita, joita kontrollerikerros voi käyttää. Palvelut voivat esimerkiksi abstrahoida kolmannen osapuolen tarjoamia komponentteja tai rajapintoja, tai sisältää toiminnallisuutta, jonka toteuttaminen kontrollerissa ei ole järkevää esimerkiksi sovelluksen ylläpidettävyyden kannalta. Tutkitaan seuraavaa luokkaa, joka tutkii <a href="http://mbar.fi/apidoc/" target="_blank">MBarin avoimesta rajapinnasta</a> onko tälle päivälle tapahtumia. Palvelu hyödyntää Springin <a href="http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html" target="_blank">RestTemplate</a>-luokkaa, minkä avulla HTTP-pyyntöjen tekeminen on hieman suoraviivaisempaa.</p>

                <pre class="sh_java">
// pakkaus
import org.springframework.web.client.RestTemplate;

public class MBarEvents {

    public Boolean hasEventsToday() {
        RestTemplate restTemplate = new RestTemplate();
        String result = restTemplate.getForObject("http://mbar.fi/api/v1/event/?datefilter=today", String.class);
        return result.contains("start_time");
    }
}</pre>

                <p>Jos vastauksessa on merkkijono <code>start_time</code>, on päivälle merkitty tapahtuma, ja metodi palauttaa arvon <code>true</code>.</p>

                <p>Vaikka ylläolevan toiminnallisuuden voisi sisällyttää kontrollerikerrokseen, kontrollerikerros ennen mittaa täyttyisi tällöin epämääräisistä koodipätkistä. Haluamme saada luokan kontrollerikerroksen käyttöön, mutta kuitenkin niin, että meidän ei tarvitse luoda sitä itse. Lisätään ylläolevalle luokalle annotaatio <code>@Service</code> (<em>palvelu</em>), jolloin se näyttää seuraavalta.</p>

                <pre class="sh_java">
// pakkaus
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

@Service
public class MBarEvents {

    public Boolean hasEventsToday() {
        RestTemplate restTemplate = new RestTemplate();
        String result = restTemplate.getForObject("http://mbar.fi/api/v1/event/?datefilter=today", String.class);
        return result.contains("start_time");
    }
}</pre>

                <p>Nyt, mikä tahansa kontrolleriluokkamme voi käyttää palvelua. Palvelun käyttöönotto tapahtuu <code>@Autowired</code>-annotaation avulla.</p>


                <pre class="sh_java">
// ..

@Controller
@RequestMapping("/events")
public class EventController {

    @Autowired
    private MBarEvents mbarEvents;

    @RequestMapping(method = RequestMethod.GET)
    public String list(Model model) {
        model.addAttribute("mbar", mbarEvents.hasEventsToday());
        return "sopiva näkymä";
    }

    ...</pre>        

                <p>Annotaatioiden <code>@Autowired</code> ja <code>@Service</code> perusteella Spring osaa päätellä että luokasta <code>MBarEvents</code> tulee luoda ilmentymä, sekä injektoida sen kontrolliluokkaamme.</p>


                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-rakkausmittari">
                                    Rakkausmittari
                                </a>
                            </h1>
                        </header>
                        <div id="t-rakkausmittari" class="collapse">

                            <p>Tehtävässä hyödynnetään ysärihittiä ja jatkokehitetään sovellusta, jota käytetään kahden henkilön yhteensopivuuden laskemiseen.</p>

                            <p>Lisää ensiksi LoveService-luokalle <code>@Service</code>-annotaatio, ja <em>injektoi</em> se luokkaan <code>LoveController</code>. Toteuta tämän jälkeen kontrolleriluokkaan metodi, joka ottaa POST-tyyppisen pyynnön vastaan, ja luo pyynnössä olevista parametreista <code>Pair</code>-olion.</p>

                            <p>Kun Pair-olio on vastaanotettu, käytä kontrolleriin injektoitua <code>LoveService</code>-oliota yhteensopivuuden laskemiseksi.</p>

                            <p>Lopuksi, ohjaa käyttäjä tekemään GET-pyyntö <code>/loves</code>-osoitteeseen. Lisää <code>RedirectAttributes</code>-luokan avulla seuraavaan pyyntöön yhteensopivuutta kuvaava arvo sekä pyynnön parametreista generoitu <code>Pair</code>-luokka. Kun lisäät edellä mainittuja <code>RedirectAttributes</code>-olioon, käytä yhteensopivuusarvon nimenä merkkijonoa <code>match</code> ja pair-olion nimenä merkkijonoa <code>pair</code>. </p>

                        </div>
                    </div>
                </div>


                <p>Käytännössä palvelin ja sovelluskehys ottaa vastuuta luokkien hallinnoinnista. Sovelluskehys syöttää riippuvuudet niitä tarvittaessa. Molemmat toiminnallisuudet ovat oleellisia kerrosarkkitehtuurin kerrosten toisistaan erottamisessa.</p>

                <aside class="extra">
                    <h1>Dependency Injection ja Inversion of Control</h1>

                    <p>Jokaisella oliolla on oma selkeä vastuualueensa, ja niiden sekoittamista tulee välttää. Inversion of Control ja Dependency Injection ovat suunnitelumalleja, joilla pyritään vähentämään olioiden turhia riippuvuuksia.</p>

                    <p>Perinteisissä ohjelmistoissa ilmentymien luominen on ohjelmoijan vastuulla. Huomasimme jo aiemmin että Spring luo käyttöömme luokkia joita tarvitsemme: Kontrollin käännöllä tarkoitetaan ohjelman toiminnan hallinnan vastuun siirtämistä sovelluskehykselle ja ohjelmaa suorittavalle palvelimelle (<em>inversion of control</em>). Spring injektoi <code>@Autowired</code>-annotaatiolla merkittyihin oliomuuttujiin ilmentymät luokista, jotka se lataa käyttöönsä palvelinohjelmiston käynnistyessä (<em>dependency injection</em>). Luokat ladataan annotaatioiden perusteella.</p>

                    <p>Lue lisää aiheesta <a href="http://martinfowler.com/articles/injection.html" target="_blank">Martin Fowlerin</a> artikkelista.</p>
                </aside>

                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-chat">
                                    Chat
                                </a>
                            </h1>
                        </header>
                        <div id="t-chat" class="collapse">

                            <p>Sovelluksessa on valmis Chat-palvelu, sekä valmis komponentti kolmannen osapuolen chattikaverin käyttämiseen, jota ei kuitenkaan ole vielä liitetty sovellukseen. Tässä kolmannen osapuolen palvelu integroidaan osaksi chat-palvelua.</p>

                            <p>Sovelluksen rakenne on seuraava. Luokka <code>MessageController</code> ottaa vastaan pyyntöjä käyttöliittymältä, ja ohjaa niitä <code>MessageService</code>-palvelulle. MessageService tarjoaa metodit viestien listaamiseen ja uuden viestin tallentamiseen: tallentaminen tapahtuu <code>MessageRepository</code>-rajapintaa käyttämällä.</p>

                            <p>Muokkaa <code>MessageService</code>-luokan tarjoamaa viestin tallennusmetodia siten, että kun käyttäjän kirjoittama viesti on tallennettu, viesti annetaan <code>ChatService</code>-oliolle, jonka palauttama viesti myös tallennetaan. Injektoi <code>ChatService</code>-palvelu <code>MessageService</code>-palveluun. Huom! Aseta injektoidun ChatService-olion nimeksi <code>chatService</code>.</p>

                            <p>Kun sovellus toimii, keskustelun pitäisi näyttää esimerkiksi seuraavanlaiselta:</p>

                            <pre>
You: hello
Mitsuku: How are you today?
You: good, all peanuts
Mitsuku: Glad to hear it.</pre>
                        </div>
                    </div>
                </div>


                <h2>Tietokantakerros</h2>


                <p>Kun tietokantoja käytetään olio-ohjelmoinnissa, hyödynnetään usein valmiita ORM-työkaluja (<em>Object Relational Mapping</em>). Nämä tarjoavat ohjelmistokehittäjälle mm. toiminnallisuutta tietokantataulujen luomiseen määritellyistä luokista. Työkalut hallinnoivat luokkien välisiä viittauksia ja ylläpitävät tietokannan eheyttä, jolloin ohjelmoijan vastuulle jää sovellukselle tarpeellisten kyselyiden toteuttaminen niiltä osin kun niitä ei tarjota valmiiksi.</p>

                <p>Relaatiotietokantojen käsittelyyn on kehitetty joukko ORM-sovelluksia. Oracle/Sun standardoi olioiden tallentamisen relaatiotietokantoihin <a href="http://en.wikipedia.org/wiki/Java_Persistence_API" target="_blank">JPA</a> (<em>Java Persistence API</em>) -standardilla. JPA:n toteuttavat kirjastot (esim. <a href="http://www.hibernate.org/" target="_blank">Hibernate</a>) abstrahoivat relaatiotietokannan, ja helpottavat kyselyjen tekemistä suoraan ohjelmakoodista. Koska huomattava osa tietokantatoiminnallisuudesta on hyvin samankaltaista ("tallenna", "lataa", "poista", ...), on perustoiminnallisuus toteutettu valmiiksi Spring Data JPA:n puolelle ja ohjelmoija määrittelee usein vain sopivan rajapintaluokan. Esimerkiksi aiemmin nähdyn <code>Person</code>-luokan tallentamistoiminnallisuuteen tarvitaan seuraavanlainen rajapinta.</p>

                <pre class="sh_java">
// pakkaus ja importit
public interface PersonRepository extends JpaRepository&lt;Person, Long&gt; {
}</pre>

                <p>Kun rajapintaa käytetään, Spring osaa injektoida sopivan toteutuksen ohjelman käyttöön.</p>

                <h3>Tallennettavat oliot</h3>

                <p>JPA-standardin mukaan oliot tulee määritellä <em>entiteetiksi</em>, jotta niitä voi tallentaa JPA:n avulla tietokantaan.</p>

                <p>Jokaisella tietokantaan tallennettavalla oliolla tulee olla annotaatio <code>@Entity</code> sekä <code>@Id</code>-annotaatiolla merkattu attribuutti, joka toimii tietokantataulun ensisijaisena avaimena. JPA:ta käytettäessä <code>id</code>-attribuutti on usein numeerinen (<code>Long</code> tai <code>Integer</code>), mutta merkkijonojen käyttö on yleistymässä. Näiden lisäksi, luokan tulee toteuttaa <code>Serializable</code>-rajapinta.</p>

                <p>Numeeriselle avainattribuutille voidaan lisäksi määritellä annotaatio <code>@GeneratedValue(strategy = GenerationType.AUTO)</code>, joka antaa id-kentän arvojen luomisen vastuun tietokannalle. Tietokantatauluun tallennettava luokka näyttää seuraavalta:</p>


                <pre class="sh_java">
// pakkaus

import java.io.Serializable;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity
public class Person implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String name;

    // getterit ja setterit</pre>

                <p>Tietokantaan luotavien sarakkeiden ja tietokantataulun nimiä voi muokata annotaatioiden avulla. Annotaatiot <code>@Column</code> ja <code>@Table</code> auttavat tässä.</p>

                <pre class="sh_java">
// pakkaus

import java.io.Serializable;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table(name = "Person")
public class Person implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name = "id")
    private Long id;
    @Column(name = "name")
    private String name;
    // getterit ja setterit</pre>

                <p>Ylläoleva konfiguraatio määrittelee luokasta <code>Person</code> tietokantataulun nimeltä "Person", jolla on sarakkeet "id" ja "name". Sarakkeiden tyypit päätellään muuttujien tyyppien perusteella.</p>


                <p>Spring Data JPA:n AbstractPersistable-luokka käytettäessä ylläolevan luokan määrittely kutistuu hieman.</p>

                <pre class="sh_java">
// pakkaus ja importit

@Entity
@Table(name = "Person")
public class Person extends AbstractPersistable&lt;Long&gt; {

    @Column(name = "name")
    private String name;
    // getterit ja setterit</pre>


                <h3>Ajan tallentaminen</h3>

                <p>Aikaa kuvaavat attribuutit tulee annotoida <code><a href="http://docs.oracle.com/javaee/6/api/javax/persistence/Temporal.html" target="_blank">@Temporal</a></code>-annotaatiolla, joka määrittelee mikä osa ajasta tallennetaan. Annotaatiolle annetaan parametrina <code><a href="http://docs.oracle.com/javaee/6/api/javax/persistence/TemporalType.html" target="_blank">TemporalType</a></code>-tyyppinen arvo, joka kertoo tarkemman tallennusmuodon. Arvo <code>TemporalType.DATE</code> tallentaa päivämäärän (esim. 2012-09-15), <code>TemporalType.TIME</code> tallentaa kellonajan (esim. 18:00:00), ja arvo <code>TemporalType.TIMESTAMP</code> tallentaa päivän ja ajan (esim. 2012-09-15 18:00:00).</p>

                <p>Annotaatiolla <code>@Temporal</code> merkityn attribuutin tulee olla joko tyyppiä <code>java.util.Date</code> tai tyyppiä <code>java.util.Calendar</code>. Alla on määritelty entiteettiluokka <code>GroceryItem</code>, joka kuvaa elintarviketta. Elintarvikkeella on myös parasta ennen-päivämäärä (bestBefore).</p>

                <pre class="sh_java">
// pakkaus ja importit

@Entity
public class GroceryItem extends AbstractPersistable&lt;Long&gt; {

    private String name;
    @Temporal(TemporalType.DATE)
    private Date bestBefore;

    // getterit ja setterit
}</pre>



                <h3>Transaktioiden hallinta</h3>

		<p>Transaktioiden avulla varmistetaan, että joko kaikki halutut operaatiot suoritetaan, tai yhtäkään niistä ei suoriteta.</p>

                <p>Tietokantatransaktiot määritellään metodi- tai luokkatasolla annotaation <code>@Transactional</code> avulla. Annotaatiolla <code>@Transactional</code> merkittyä metodia suoritettaessa metodin alussa aloitetaan tietokantatransaktio, jossa tehdyt muutokset viedään tietokantaan metodin lopussa. Jos annotaatio <code>@Transactional</code> määritellään luokkatasolla, se koskee jokaista luokan metodia.</p>

                <p>Annotaatiolle <code>@Transactional</code> voidaan määritellä parametri <code>readOnly</code>, jonka avulla määritellään kirjoitetaanko muutokset tietokantaan. Jos parametrin <code>readOnly</code> arvo on <code>true</code>, metodiin liittyvä transaktio perutaan metodin lopussa (rollback). Tällöin metodi ei yksinkertaisesti voi muuttaa tietokannassa olevaa tietoa. </p>

                <p>Spring Data JPA:n käyttämissä luokissa on määritelty luokkatason transaktiot, joten yksittäiset tallennusoperaatiot toimivat myös ilman <code>@Transactional</code>-annotaatiota.</p>

                <p>Transaktiot määritellään tyypillisesti palvelutasolla.</p>


                <h3>Omien kyselyiden toteuttaminen</h3>

                <p>Spring Data JPA ei tarjoa kaikkia kyselyitä valmiiksi. Jos tarvitset tietynlaisen kyselyn, sinun tulee yleensäottaen myös määritellä se. Laajennetaan aiemmin määriteltyä rajapintaa <code>PersonRepository</code> siten, että sillä on metodi <code>List&lt;Person&gt; findByName(String name)</code> -- eli hae henkilöt, joilla on tietty nimi.</p>


                <pre class="sh_java">
// pakkaus

import org.springframework.data.repository.JpaRepository;

public interface PersonRepository extends JpaRepository&lt;Person, Long&gt; {
    List&lt;Person&gt; findByName(String name);
}</pre>

                <p>Ylläoleva esimerkki on esimerkki kyselystä, johon Spring Data ei tarvitse erillistä toteutusta. Se arvaa että kysely olisi muotoa <code>SELECT p FROM Person p WHERE p.name= :name</code> ja luo sen valmiiksi. Lisää Spring Data JPA:n kyselyistä löytyy sen <a href="http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation" target="_blank">dokumentaatiosta</a>.</p>


                <aside class="extra">
                    <h1>Kyselyt Java Persistence Apin kautta</h1>

                    <p>Java Persistence APIn kautta tehdyt kyselyt eivät ole natiivia SQL:ää, vaan seuraavat JPQL-määritelmää (Java Persistence Query Language), joka kuitenkin muistuttaa SQL:ää. JPQL-kielestä löytyy lisää tietoa osoitteesta <a href="http://docs.oracle.com/javaee/6/tutorial/doc/bnbtg.html" target="_blank">http://docs.oracle.com/javaee/6/tutorial/doc/bnbtg.html</a>.</p>

                </aside>


                <p>Tehdään toinen esimerkki, jossa joudumme oikeasti luomaan oman kyselyn. Lisätään rajapinnalle <code>PersonRepository</code> metodi <code>findJackBauer</code>, joka suorittaa kyselyn <code>"SELECT p FROM Person p WHERE p.name = 'Jack Bauer'"</code>.</p>


                <pre class="sh_java">
// pakkaus

import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.JpaRepository;

public interface PersonRepository extends JpaRepository&lt;Person, Long&gt; {
    List&lt;Person&gt; findByName(String name);
    @Query("SELECT p FROM Person p WHERE p.name = 'Jack Bauer'")
    Person findJackBauer();
}</pre>

                <p>Käytössämme on nyt myös metodi <code>findJackBauer</code>, joka suorittaa <code>@Query</code>-annotaatiossa määritellyn kyselyn. Tarkempi kuvaus kyselyiden määrittelystä osana rajapintaa löytyy Spring Data JPAn <a href="http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.at-query" target="_blank">dokumentaatiosta</a>.</p>


                <h3>Toisiin olioiden viittaaminen</h3>


                <p>Toisiin entiteetteihin viittaaminen tapahtuu kuten normaalistikin, mutta ohjelmoijan tulee lisäksi määritellä osallistumisrajoitteet. Osallistumisrajoitteet -- yksi moneen (<em>one to many</em>), moni yhteen (<em>many to one</em>), moni moneen (<em>many to many</em>) lisätään annotaatioiden avulla. Luodaan esimerkiksi luokka <code>Person</code>, joka voi omistaa joukon esineitä. Kukin esine on vain yhden henkilön omistama -- suhde siis yksi moneen -- annotaatio <code>@OneToMany</code>.</p>

                <pre class="sh_java">
@Entity
public class Person extends AbstractPersistable&lt;Long&gt; {

    private String name;
    @OneToMany
    private List&lt;Item&gt; items;</pre>

                <p>Yllä olevaa esimerkkiä käytettäessä luokalle <code>Item</code> luodaan tietokantatauluun automaattisesti sarake, johon tallennetaan omistavan <code>Person</code>-olion yksilöivä tunnus.</p>

                <p>Moni-moneen yhteys tapahtuu tietokantatauluja suunniteltaessa liitostaulun avulla. JPA:ssa moni-moneen yhteydet määritellään annotaatiolla <code>@ManyToMany</code>. Tällöin yhteys tulee merkitä kummallekin puolelle. Jos henkilö voi omistaa useita esineitä, ja esineellä voi olla useita omistajia, toteutus on seuraavanlainen.</p>

                <pre class="sh_java">
@Entity
public class Person extends AbstractPersistable&lt;Long&gt; {

    private String name;
    @ManyToMany
    private List&lt;Item&gt; items;
    ...</pre>

                <pre class="sh_java">
@Entity
public class Item extends AbstractPersistable&lt;Long&gt; {

    private String name;
    private Double weight;
    @ManyToMany(mappedBy = "items")
    private List&lt;Person&gt; owners;</pre>

                <p>Yllä oleva määritelmä luo liitostaulun Item- ja Person-taulujen välille. Item-luokassa olevassa @ManyToMany-annotaatiossa oleva parametri <code>mappedBy = "items"</code> kertoo että Item-luokan <code>owners</code>-kenttä kytketään luokan Person listaan <code>items</code>.</p>


                <h3>Tietokantatoiminnallisuuden käyttäminen palveluista</h3>

                <p>Haluamme usein tallentaa olion joka viittaa olioon, josta viitataan takaisin. </p>

                <p>Pohditaan tätä kontekstissa, jossa tavoitteena on lisätä uusia Person-olioita olemassaolevaan huoneeseen. Huoneella on lista siinä olevista henkilöistä. Yksi ratkaisu on seuraava. </p>

                <pre class="sh_java">
    @Transactional
    public void assignPerson(Long personId, Long roomId) {
        Room room = roomRepository.findOne(roomId);
        Person person = personRepository.findOne(personId);

        person.setRoom(room);
        room.getOccupants().add(person);
    }</pre>

                <p>Koska ylläolevassa esimerkissä koodi suoritetaan transaktion sisällä, ladattuihin olioihin tehdyt muutokset viedään tietokantaan transaktion lopussa.</p>

                <p><strong>Poistaminen</strong></p>


                <p>Pohditaan seuraavaksi tilannetta, jossa haluaisimme poistaa tietyn henkilön. Ensimmäinen hahmotelma on kutakuinkin seuraavanlainen:</p>

                <pre class="sh_java">
    @Transactional
    public void removePerson(Long personId) {
        personRepository.delete(personId);
    }</pre>

                <p>Yllä olevassa lähestymistavassa ongelmana on kuitenkin se, että huoneet eivät kadota viittausta henkilöön. Käytännössä henkilö jää "haamuksi" järjestelmään tai saamme virheen poistoa yrittäessä. Jos haluamme poistaa huoneisiin liittyvät viittaukset henkilöön, joudumme tekemään sen käsin.</p>

                <pre class="sh_java">
    @Transactional
    public void removePerson(Long personId) {
        Person person = personRepository.findOne(personId);
        person.getRoom().getOccupants().remove(person);
        personRepository.delete(person);
    }</pre>



                <h3>Milloin oliot haetaan</h3>


                <p>Tietokanta-abstraktioita tarjoavat komponentit kuten Hibernate päättävät mitä tehdään haettavaan olioon liittyville viitteille. Yksi vaihtoehto on hakea viitatut oliot automaattisesti kyselyn yhteydessä ("Eager"), toinen vaihtoehto taas on hakea viitatut oliot vasta kun niitä pyydetään eksplisiittisesti esimerkiksi get-metodin kautta ("Lazy").</p>

                <p>Tyypillisesti one-to-many ja many-to-many -viitteet haetaan vasta niitä tarvittaessa, ja one-to-one ja many-to-one viitteet heti. Oletuskäyttäytymistä voi muuttaa <a href="http://docs.oracle.com/javaee/6/api/javax/persistence/FetchType.html" target="_blank">FetchType</a>-parametrin avulla. Esimerkiksi alla ehdotamme, että <code>apartments</code>-lista noudetaan heti.</p>

                <pre class="sh_java">
// pakkaus

@Entity
public class Person extends AbstractPersistable&lt;Long&gt; {

    private String name;

    // oletamme, että Apartment-entiteetti on olemassa
    @OneToMany(fetch=FetchType.EAGER)
    @JoinColumn 
    private List&lt;Apartment&gt; apartments; 

    // getterit ja setterit
}
                </pre>

                <p>Käytännössä tietokannasta tarvittaessa haku toteutetaan muokkaamalla get-metodia siten, että tietokantakysely tapahtuu metodia kutsuttaessa. Staattisesti tyypitetyissä ohjelmointikielissä tämä käytännössä vaatii sitä, että luokkien rakennetta muutetaan joko ajonaikaisesti tai lähdekooditiedostojen kääntövaiheessa -- käyttämämme komponentit tekevät tämän puolestamme.</p>




                <aside class="info">

		  <br/>
		  
                  <h1>N+1 Kyselyn ongelma</h1>
		  
                  <p>Viitattujen olioiden lataaminen vasta niitä tarvittaessa on yleisesti ottaen hyvä idea, mutta sillä on myös kääntöpuolensa. Pohditaan tilannetta, missä kirjalla voi olla monta kirjoittajaa, ja kirjoittajalla monta kirjaa -- <code>@ManyToMany</code>. Jos haemme tietokannasta listan kirjoja (1 kysely), ja haluamme tulostaa kirjoihin liittyvät kirjoittajat, tehdään jokaisen kirjan kohdalla erillinen kysely kyseisen kirjan kirjoittajille (n kyselyä). Tätä ongelmaa kutsutaan N+1 -kyselyn ongelmaksi.</p>
		  
                  <p>Jos kirjoja tarvitaan sekä ilman kirjoittajaa että kirjoittajan kanssa, on FetchType-parametrin asettaminen <code>EAGER</code>-tyyppiseksi yksi vastaus. Tällöin kuitenkin osassa tapauksista haetaan ylimääräistä dataa tietokannasta. Toinen vaihtoehto on luoda erillinen kysely yhdelle vaihtoehdoista, ja lisätä kyselyyn vinkki (<a href="http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-hints" target="_blank">Spring Data JPA, applying query hints</a>) kyselyn toivotusta toiminnallisuudesta.</p>
                </aside>
		

                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-lentokentat">
                                    Lentokentät ja lentokoneet
                                </a>
                            </h1>
                        </header>
                        <div id="t-lentokentat" class="collapse">

                            <p>Jatkokehitetään tässä tehtävässä sovellusta lentokoneiden ja lentokenttien hallintaan. Projektissa on jo valmiina ohjelmisto, jossa voidaan lisätä ja poistaa lentokoneita. Tavoitteena on lisätä toiminnallisuus lentokoneiden kotikenttien asettamiseksi.</p>

                            <h1>Tallennettavat: <code>Aircraft</code> ja <code>Airport</code>.</h1>

                            <p>Lisää luokkaan <code>Aircraft</code> attribuutti <code>airport</code>, joka kuvaa lentokoneen kotikenttää, ja on tyyppiä <code>Airport</code>. Koska usealla lentokoneella voi olla sama kotikenttä, käytä attribuutille <code>airport</code> annotaatiota <code>@ManyToOne</code>. Lisää attribuutille myös <code>@JoinColumn</code>-annotaatio, jonka avulla kerrotaan että tämä attribuutti viittaa toiseen tauluun. Lisää luokalle myös oleelliset get- ja set-metodit.</p>

                            <p>Lisää seuraavaksi <code>Airport</code>-luokkaan attribuutti <code>aircrafts</code>, joka kuvaa kaikkia koneita, keiden kotikenttä kyseinen kenttä on, ja joka on tyyppiä <code>List&lt;Aircraft&gt;</code>. Koska yhdellä lentokentällä voi olla useita koneita, lisää attribuutille annotaatio <code>@OneToMany</code>. Koska luokan <code>Aircraft</code> attribuutti <code>airport</code> viittaa tähän luokkaan, aseta annotaatioon <code>@OneToMany</code> parametri <code>mappedBy="airport"</code>. Nyt luokka <code>Airport</code> tietää että attribuuttiin <code>aircrafts</code> tulee ladata kaikki <code>Aircraft</code>-oliot, jotka viittaavat juuri tähän kenttään.</p>

                            <p>Lisää lisäksi <code>Airport</code>-luokan <code>@OneToMany</code>-annotaatioon parametri <code>fetch = FetchType.EAGER</code>, jolloin lentokenttään liittyvät lentokoneet haetaan kyselyn yhteydessä.</p>

                            <p>Lisää lopuksi luokalle <code>Airport</code> oleelliset get- ja set-metodit.</p>


                            <h1>Lentokentän asetus lentokoneelle</h1>

                            <p>Lisää sovellukselle toiminnallisuus lentokentän lisäämiseen lentokoneelle. Käyttöliittymä sisältää jo tarvittavan toiminnallisuuden, joten käytännössä sinun tulee toteuttaa luokalle <code>AircraftController</code> metodi <code>String assignAirport</code>. Kun käyttäjä lisää lentokoneelle lentokenttää, käyttöliittymä lähettää POST-tyyppisen kyselyn osoitteeseen <code>/aircrafts/{aircraftId}/airports</code>, missä <code>aircraftId</code> on lentokoneen tietokantatunnus. Pyynnön mukana tulee lisäksi parametri <code>airportId</code>, joka sisältää lentokentän tietokantatunnuksen.</p>

                            <p>Toteuta metodi siten, että haet aluksi pyynnössä saatuja tunnuksia käyttäen lentokoneen ja lentokentän, tämän jälkeen asetat lentokoneelle lentokentän ja lentokentälle lentokoneen, ja lopuksi tallennat haetut oliot.</p>

                            <p>Ohjaa lopuksi pyyntö osoitteeseen <code>/aircrafts</code></p>

                            <p>Kun olet valmis, lähetä sovellus TMC:lle tarkistettavaksi.</p>
                        </div>
                    </div>

                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-elokuvatietokanta">
                                    Elokuvatietokanta
                                </a>
                            </h1>
                        </header>
                        <div id="t-elokuvatietokanta" class="collapse">

                            <p>Tämä on avoin tehtävä jossa saat itse suunnitella huomattavan osan ohjelman sisäisestä rakenteesta. Ainoat määritellyt asiat ohjelmassa ovat käyttöliittymä ja domain-oliot, jotka tulevat tehtäväpohjan mukana. Tehtäväpohjassa on myös valmis konfiguraatio.</p>

                            <p>Tehtävästä on mahdollista saada yhteensä 4 pistettä.</p>

                            <p>Huom! Kannattanee aloittaa näyttelijän lisäämisestä ja poistamisesta. Suunnittele ensin sopiva tietokantaolio, sekä sille sopivat repository-oliot. Jatka tämän jälkeen kontrollerin toteutuksella -- sekä mahdollisesti palvelukerroksen lisäämisellä. Kannattanee hyödyntää valmiiksi tarjotuissa käyttöliittymätiedostoissa olevaa koodia osana tietokantaolioiden attribuuttien määrittelyä.</p>

                            <h1>pisteytys</h1>

                            <ol class="pisteytys">
                                <li>+ 1p: Näyttelijän lisääminen ja poistaminen onnistuu. Käyttöliittymän olettamat osoitteet ja niiden parametrit:<br/>
                                    <ul>
                                        <li><code>GET /actors</code> - näyttelijöiden listaus, ei parametreja pyynnössä. Lisää pyyntöön attribuutin <code>actors</code>, joka sisältää kaikki näyttelijät ja luo sivun <code>/src/main/resources/templates/actors.html</code> pohjalta näkymän.</li>

                                        <li><code>POST /actors</code> - parametri <code>name</code>, jossa on lisättävän näyttelijän nimi. Lisäyksen tulee lopulta ohjata pyyntö osoitteeseen <code>/actors</code>.</li>

                                        <li><code>DELETE /actors/{actorId}</code> - polun parametri <code>actorId</code>, joka sisältää poistettavan näyttelijän tunnuksen. Poiston tulee lopulta ohjata pyyntö osoitteeseen <code>/actors</code>.</li>
                                    </ul>
                                </li>

                                <p></p>

                                <li>+ 1p: Elokuvan lisääminen ja poistaminen onnistuu. Käyttöliittymän olettamat osoitteet ja niiden parametrit:<br/>
                                    <ul>
                                        <li><code>GET /movies</code> - elokuvien listaus, ei parametreja pyynnössä. Lisää pyyntöön attribuutin <code>movies</code>, joka sisältää kaikki elokuvat ja luo sivun <code>/src/main/resources/templates/movies.html</code> pohjalta näkymän.</li>

                                        <li><code>POST /movies</code> - elokuvan lisäys, parametrit <code>name</code>, joka sisältää lisättävän elokuvan nimen, ja <code>lengthInMinutes</code>, joka sisältää elokuvan pituuden minuuteissa. Lisäyksen tulee lopulta ohjata pyyntö osoitteeseen <code>/movies</code>.</li>

                                        <li><code>DELETE /movies/{movieId}</code> - polun parametri <code>movieId</code>, joka sisältää poistettavan elokuvan tietokantatunnuksen. Poiston tulee lopulta ohjata pyyntö osoitteeseen <code>/movies</code>.</li>
                                    </ul>
                                </li>

                                <p></p>

                                <li>+ 2p: Näyttelijän voi lisätä elokuvaan (kun näyttelijä tai elokuva poistetaan, tulee myös poistaa viitteet näyttelijästä elokuvaan ja elokuvasta näyttelijään). Käyttöliittymän olettamat osoitteet ja niiden parametrit:<br/>
                                    <ul>

                                        <li><code>GET /actors/{actorId}</code> - polun parametri <code>actorId</code>, joka sisältää näytettävän näyttelijän tietokantatunnuksen. Asettaa pyyntöön sekä attribuutin <code>actor</code> jossa näyttelijä-olio että attribuutin <code>movies</code>, jossa kaikki elokuvat, sekä luo sivun <code>/src/main/resources/templates/actor.html</code> pohjalta näkymän.</li>

                                        <li><code>POST /actors/{actorId}/movies</code> - polun parametri <code>actorId</code>, joka sisältää kytkettävän näyttelijän tietokantatunnuksen, ja parametri <code>movieId</code>, joka sisältää kytkettävän elokuvan tietokantatunnuksen. Lisäämisen tulee lopulta ohjata pyyntö osoitteeseen <code>/actors</code>.</li>
                                    </ul>
                                </li>
                            </ol>
                        </div>
                    </div>
                </div>


                <h3>Tietokantakyselyn tulosten järjestäminen ja rajoittaminen</h3>

                <p>Tietokantakyselyn tulokset halutaan usein hakea tai järjestää tietyn kriteerin mukaan. Jos tietokantadatan läpikäynti toteutettaisiin osana palvelua, tekisimme oikeastaan juuri sen työn, missä tietokannat loistavat.</p>

                <p>Esimerkiksi alla oleva lisäys tarjoaa metodin henkilöiden etsimiseen, joilla ei ole huonetta (oletamme että Person-luokalla on attribuutti Room).</p>

                <pre class="sh_java">
public interface PersonRepository extends JpaRepository&lt;Person, Long&gt; {
    List&lt;Person&gt; findByRoomIsNull();
}</pre>

                <p>Vastaavasti voisimme hakea esimerkiksi nimen osalla: <code>findByNameContaining(String osa)</code>.</p>

                <p>Spring Data JPAn rajapinta <a href="http://docs.spring.io/spring-data/jpa/docs/1.4.1.RELEASE/api/org/springframework/data/jpa/repository/JpaRepository.html" target="_blank">JpaRepository</a> mahdollistaa muutaman lisäparametrin käyttämisen osassa pyyntöjä. Voimme esimerkiksi käyttää parametria <a href="http://docs.spring.io/spring-data/commons/docs/1.5.2.RELEASE/api/org/springframework/data/domain/PageRequest.html" target="_blank">PageRequest</a>, joka tarjoaa apuvälineet sivuttamiseen sekä pyynnön hakutulosten rajoittamiseen. Alla olevalla PageRequest-oliolla haluasimme ensimmäiset 50 hakutulosta attribuutin name mukaan käänteisessä järjestyksessä.</p>

                <pre class="sh_java">
    Pageable pageable = new PageRequest(0, 50, Sort.Direction.DESC, "name");</pre>

                <p>Voimme muokata metodia <code>findByRoomIsNull</code> hyväksymään <code>Pageable</code>-rajapinnan toteuttavan olion parametriksi, jolloin metodi palauttaa <a href="http://docs.spring.io/spring-data/data-commons/docs/1.6.1.RELEASE/api/org/springframework/data/domain/Page.html" target="_blank">Page</a>-luokan ilmentymän.</p>

                <pre class="sh_java">
public interface PersonRepository extends JpaRepository&lt;Person, Long&gt; {
    Page&lt;Person&gt; findByRoomIsNull(Pageable pageable);
}</pre>

                <p>Yhdistämällä kaksi edellistä, voisimme hakea kaikki huoneettomat henkilöt sopivasti järjestettynä:</p>

                <pre class="sh_java">
//...
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
//...

    // tämä palvelussa
    Pageable pageable = new PageRequest(0, 50, Sort.Direction.DESC, "name");
    Page&lt;Person&gt; personPage = personRepository.findByRoomIsNull(pageable);
    List&lt;Person&gt; persons = personPage.getContent();
                </pre>



                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-viimeisetviestit">
                                    Viimeiset viestit
                                </a>
                            </h1>
                        </header>
                        <div id="t-viimeisetviestit" class="collapse">

                            <p>Tehtävässä on käytössä Chat-tehtävästä tuttu sovellus. Muokkaa sovellusta siten, että MessageServicen <code>list</code>-metodi palauttaa uusimmat 10 viestiä. Käytä tässä hyödyksi yllä nähtyä Pageable-oliota.</p>

                        </div>
                    </div>
                </div>

            </section>
            <!-- END WEEK2 -->


            <!-- BEGIN WEEK3 -->
            <section class="weeklimit" data-week-id="3">
                <header>
                    <h1 id="viikko3">Viikko 3</h1>
                </header>

<!--
		<aside class="info">
		  <br/>
		  <h1>Palvelimen tuottamien virheviestien tulkinta</h1>


		</aside>
-->

                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-uniraportit">
                                    Uniraportit
                                </a>
                            </h1>
                        </header>
                        <div id="t-uniraportit" class="collapse">

                            <p>Kerrataan edellisten viikkojen teemoja, ja toteutetaan Unipalvelu, johon käyttäjä voi tallentaa tietoja nukkumisestaan. Tehtävässä kerrataan aiemmin oppimiamme asioita.</p>


                            <h1>Domain-luokka ja Repository</h1>

                            <p>Muokkaa pakkauksessa <code>wad.domain</code> olevaa luokkaa <code>Sleep</code> niin, että se toteuttaa alla olevan rungon. Tee luokasta entiteetti ja periytä se luokasta <code>AbstractPersistable</code> siten, että luokan ID-kentän tyypiksi tulee <code>Long</code>. Muista myös luoda getterit ja setterit attribuuteille.

                            <pre class="sh_java sh_sourceCode">
import org.springframework.format.annotation.DateTimeFormat;

//...
    @DateTimeFormat(pattern = "d.M.y H:m")
    private Date start;

    @DateTimeFormat(pattern = "d.M.y H:m")
    private Date end;

    private String feeling;
// ..
                            </pre>


                            <p><code>@DateTimeFormat</code> annotaatiolla Spring muuntaa tekstihahmon <code>d.M.y H:m</code> muotoisen merkkijonoesityksen päivämäärästä ja ajasta (kuten 23.9.2014 18:41) <code>Date</code>-olioksi. Voimme siis syöttää lomakkeessa merkkijonon, joka muutetaan suoraan <code>Date</code>ksi.</p>


                            <h2>Attribuuteista:</h2>

                            <ul>
                                <li><code>start</code> - Käytä annotaatiota <code>@Temporal</code> tyypillä <code>TIMESTAMP</code>. Validoi myös että attribuutti ei ole null.</li>
                                <li><code>end</code> - Kuten edeltävä attribuutti.</li>
                                <li><code>feeling</code> - Validoi ettei attribuutti ole tyhjä tai null.</li>
                            </ul>


                            <h2>Repository</h2>

                            <p>Tee entiteetille repository-rajapinta <code>SleepRepository</code> pakkaukseen <code>wad.repository</code>. Rajapinnan tulee tuttuun tapaan periä Spring Data JPA:n rajapintaluokka <code>JpaRepository</code> siten, että tallennettava olio on tyyppiä <code>Sleep</code> ja avaimena on <code>Long</code>.</p>


                            <h1>Kontrollerit (2p)</h1>

                            <p>Toteuta pakkaukseen <code>wad.controller</code> kontrolleriluokka <code>SleepController</code>. Injektoi luokkaan <code>@Autowired</code>-annotaatiota käyttäen <code>SleepRepository</code>-toteutus. Luokan metodien tulee toimia seuraavanlaisesti:</p>

                            <p>Huom! Tarkista aiemmasta materiaalista mitä GET-pyynnön yhteydessä tulee antaa luotavalle näkymälle kun sivulla on Thymeleafin validoima lomake-elementti -- tarvitset Sleep-olion jo GET-pyyntöön.</p>

                            <ul>
                                <li>
                                    <code>public String list(Model model)</code>
                                    <ol>
                                        <li>Vastaa GET-pyyntöihin osoitteessa <code>sleeps</code>.</li>
                                        <li>Hakee tietokannasta listan kaikista <code>Sleep</code> entiteeteistä ja lisää ne <code>model</code>iin attribuutilla <code>sleeps</code>.</li>
                                        <li>Palauttaa näkymästä <code>/src/main/resources/templates/sleeps.html</code> luodun sivun.</li>
                                    </ol>
                                </li>
                                <li>
                                    <code>public String create(RedirectAttributes redirectAttrs, Sleep sleep, BindingResult result)</code>
                                    <ol>
                                        <li>Vastaa POST-pyyntöihin osoitteessa <code>sleeps</code>.</li>
                                        <li>Parametrina saadaan lomakkeesta generoitu <code>Sleep</code> entiteetti. Käytä <code>@ModelAttribute</code>-annotaatiota ja varmista, että entiteetti on validi. Tarkista tiedon lähettämiseen käytetystä html-sivusta minkä niminen @ModelAttribute-annotaatiota seuraavan olion tulee olla.</li>
                                        <li>Mikäli <code>result</code> oliossa on virheitä, palauta näkymästä <code>/src/main/resources/templates/sleeps.html</code> luotu sivu virheiden näyttämistä varten. Luo erillisen <code>getSleep</code>-metodi, joka asettaa modeliin automaattisesti <code>Sleep</code>-olion -- näin näet myös virheet sivulla.</li>
                                        <li>Mikäli virheitä ei ole, metodi tallentaa <code>Sleep</code> entiteetin tietokantaan ja ohjaa käyttäjän osoitteeseen <code>/sleeps/{id}</code>, missä id-kentän arvoksi tulee juuri luodun olion tunnus. Käytä tässä hyödyksi <code>RedirectAttributes</code>-oliota. <strong>Huom!</strong> Jos et muista <code>addAttribute</code> ja <code>addFlashAttribute</code> -komentojen eroa, kertaa ne aiemman viikon materiaalista!</li>
                                    </ol>
                                </li>
                                <li>
                                    <code>public String read(Model model, Long id)</code>
                                    <ol>
                                        <li>Vastaa GET-pyyntöihin osoitteessa <code>sleeps/{id}</code>, polussa tulee haettavan <code>Sleep</code> entiteetin ID.</li>
                                        <li>Hakee palvelukerroksesta vastaavan entiteetin ja lisää sen <code>model</code>iin attribuutilla <code>sleep</code>.</li>
                                        <li>Palauttaa näkymästä <code>/src/main/resources/templates/sleep.html</code> luodun sivun.</li>
                                    </ol>
                                </li>
                                <li>
                                    <code>public String delete(Long id)</code>
                                    <ol>
                                        <li>Vastaa DELETE-pyyntöihin osoitteessa <code>sleeps/{id}</code>, polussa tulee poistettavan <code>Sleep</code> entiteetin ID.</li>
                                        <li>Poistaa kyseisen <code>Sleep</code> entiteetin tietokannasta.</li>
                                        <li>Ohjaa käyttäjän osoitteeseen <code>sleeps</code>.</li>
                                    </ol>
                                </li>
                            </ul>

                            <p>Testaa nyt ohjelma kokonaisuudessaan ja kun testit menevät läpi, lähetä sovellus TMC:lle.</p>
                        </div>
                    </div>
                </div>


                <h1>REST</h1>
                
                
                <p>Huomattava osa ohjelmointirajapinnoista on toteutettu siten, että niiden muuttaminen ei ole helppoa. Kun ohjelmistokehittäjät luovat rajapintoja käyttäviä komponentteja, tehdään tyypillisesti rajapintakohtaisia päätöksiä ja toteutuksia, jotka luonnollisesti hajoavat <em>jos</em> käytettävä rajapinta muuttuu. Organisaatioilla kuten Facebook, Twitter ja Flickr on jokaisella oma ohjelmointirajapinta. Esimerkiksi käyttäjän ystävien hakeminen <a href="https://dev.twitter.com/rest/public" target="_blank">Twitter-rajapinnasta</a> tapahtuu osoitteesta <code>api.twitter.com/1.1/friends/list.json</code> -- käyttäjän täytyy tunnistautua ennen hakua, kun taas <a href="https://developers.facebook.com/docs/graph-api" target="_blank">Facebookin rajapinnan</a> avulla käyttäjän kaverit löytyvät osoitteesta <code>graph.facebook.com/v2.4/{tunnus}/friendlists</code>, missä {tunnus} on käyttäjän tunnus -- tässäkin tapauksessa käyttäjän täytyy tunnistautua ennen hakua. Hakuosoitteiden muoto, tunnistautuminen ja vastausdata ovat tyypillisesti organisaatiokohtaisia.</p>
                
                <p>Tähän liittyy useita ongelmia, joista ensisijaiset liittyvät rajapinnan käyttöönottoon liittyvään työmäärään. Koska rajapinnan muoto ja data on organisaatiokohtaista, tehdään jokaista rajapintaa varten oma asiakasohjelmisto. Olisiko mahdollista toteuttaa rajapinta tai rajapinnan osia siten, että rajapintaa käyttävät toteutukset olisivat yleiskäyttöisiä?</p>
                
                <p>REST-rajapinnat (<a href="http://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank">representational state transfer</a>) liittyvät <em>resursseihin</em> (henkilöt, kirjat, laskentaprosessit, laskentatulokset -- mikä tahansa voi käytännössä olla resurssi). Resursseilla on resurssikokoelmat ja yksittäiset resurssit yksilöivä <em>osoite</em> -- resurssikokoelmat voivat löytyä esimerkiksi osoitteiden <code>/persons</code>, <code>/books</code>, <code>/processes</code> tai <code>/results</code> takaa; yksittäisille resursseille määritellään uniikit osoitteet (esimerkiksi <code>/persons/1</code>). Tämän lisäksi, käsiteltävä data -- esimerkiksi JSON tai XML -- on yhdenmukaista; dataa voi lähettää ja vastaanottaa samassa muodossa. Lopulta, rajapinnat ovat <em>löydettäviä ja navigoitavia</em> -- palvelimen palauttama data voi sisältää esimerkiksi hypermedialinkkejä muihin resursseihin. Resurssien käsittelyyn (muokkaaminen, lisääminen, poisto, ...) käytetään HTTP-protokollan metodeja.</p>
                
                <p>REST on hyödyllinen malli mm. olemassaolevien jo hieman ikääntyneiden palveluiden kapselointiin sekä uusien rajapintojen tarjoamiseen. Sovelluskehittäjä voi kehittää uuden käyttöliittymän ja käyttää vanhaan sovellukseen liittyvää toiminnallisuutta REST-rajapinnan kautta. REST-palvelun ovat nykyään hyvin yleisiä ja niiden luomiseen on tehty huomattava määrä apuohjelmia.</p>

                <aside class="info">
		  <br/>

                  <h1>Tiedon alkulähteille</h1>
		  
                  <p>Tutustu Roy T. Fieldingin ja Richard N. Taylorin artikkeliin <a href="resources/principled-design-of-the-modern-web-architecture.pdf" target="_blank">"Principled Design of the Modern Web Architecture"</a>, jossa REST määritellään. Vaikka emme tässä kappaleessa täytä kaikkia REST-rajapintoihin liittyviä vaatimuksia -- ainakaan aluksi -- on Roy Fielding sitä mieltä, että <a href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven" target="_blank">oleellista on mahdollisuus resurssien välillä navigointiin</a>.</p>
		  
                  <p><em>"A truly RESTful API looks like hypertext. Every addressable unit of information carries an address, either explicitly (e.g., link and id attributes) or implicitly (e.g., derived from the media type definition and representation structure). Query results are represented by a list of links with summary information, not by arrays of object representations (query is not a substitute for identification of resources)."</em></p>

                </aside>
                

                <h2>Omat REST-rajapinnat</h2>
                
                <p>Tutkitaan seuraavaa kirjojen ylläpitämiseen tarkoitettua kuvitteellista rajapintaa.</p>

                <ul>
                    <li>GET-pyyntö osoitteeseen <code>/books</code> palauttaa kaikkien kirjojen tiedot.</li>
                    <li>GET osoitteeseen <code>/books/{id}</code>, missä <code>{id}</code> on yksittäisen kirjan yksilöivä tunniste, palauttaa kyseisen kirjan tiedot.</li>
                    <li>PUT osoitteeseen <code>/books/{id}</code>, missä <code>{id}</code> on yksittäisen kirjan yksilöivä tunniste, muokataan kyseisen kirjan tietoja. Kirjan uudet tiedot lähetetään osana pyyntöä.</li>
                    <li>DELETE osoitteeseen <code>/books/{id}</code> poistaa kirjan tietyllä tunnuksella.</li>
                    <li>POST osoitteeseen <code>/books</code> luo uuden kirjan pyynnön rungossa lähetettävän datan pohjalta. Palvelun vastuulla on päättää kirjalle tunnus.</li>
                </ul>

                <p>Kuten huomaat, osoitteissa käytetään substantiivejä -- ei <code>books?id={id}</code> vaan <code>/books/{id}</code>, ja pyyntötyypeistä voi päätellä halutun operaation. DELETE-tyyppisellä pyynnöllä poistetaan, POST-tyyppisellä pyynnöllä lisätään, PUT-tyyppisellä pyynnöllä päivitetään tietoja, ja GET-tyyppisellä pyynnöllä haetaan. Kuten HTTP-kommunikaatiossa yleensäkin, <em>GET-pyynnöt eivät muokkaa tallennettua dataa</em>.</p>

                <p>REST-rajapinnan käyttämä dataformaatti on toteuttajan päätettävissä. Nykyään huomattava osa palveluista käyttää <a href="http://en.wikipedia.org/wiki/JSON" target="_blank">JSON</a>-dataformaattia, sillä sen käyttäminen osana selainohjelmistoja on suoraviivaista JavaScriptin kautta. Myös palvelinohjelmistot tukevat olioiden muuttamista JSON-muotoon.</p>

                <p>Oletetaan että edelläkuvattu kirjojen käsittelyyn tarkoitettu rajapinta käsittelee JSON-muotoista dataa. Kirjaa kuvaava luokka on seuraavanlainen:</p>
                
                <pre class="sh_java">
package wad;

public class Book {
    private Long id;
    private String name;

    public Long getId() {
        return this.id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return this.name;
    }

    public String setName(String name) {
        this.name = name;
    }
}</pre>
                
                <p>Kun luokasta on tehty olio, jonka <code>id</code>-muuttujan arvo on <code>2</code> ja nimi <code>"Harry Potter and the Chamber of Secrets"</code>, on sen JSON-esitys seuraavanlainen:</p>

                <pre>
{
  "id":2,
  "name":"Harry Potter and the Chamber of Secrets"
}</pre>
                
                <p>Käytännössä siis JSON-notaatio määrittelee olion alkavalla aaltosululla <code>{</code>, jota seuraa oliomuuttujien nimet ja niiden arvot. Lopulta olio päätetään sulkevaan aaltosulkuun <code>}</code>. Oliomuuttujien nimet ovat hipsuissa <code>"</code> sillä ne käsitellään merkkijonoina; muuttujien arvot voivat olla hipsuissa, riippuen arvon tyypistä. Tarkempi kuvaus JSON-notaatiosta löytyy esimerkiksi sivulta <a href="http://json.org/" target="_blank">json.org</a>.</p>


                <p>Pyynnön rungossa lähetettävän JSON-muotoisen datan muuttaminen olioksi tapahtuu annotaation <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RequestBody.html" target="_blank">@RequestBody</a> avulla. Annotaatio @RequestBody edeltää kontrollerimetodin parametrina olevaa oliota, johon sovelluskehittäjä pyytää Spring-sovelluskehystä asettamaan JSON-muotoisen datan arvot.</p>

                <pre class="sh_java">
    @RequestMapping(method=RequestMethod.POST)
    public String postBook(@RequestBody Book book) {
        bookRepository.save(book);
        return "redirect:/books";
    }</pre>

                <p>Vastauksen saa lähetettyä käyttäjälle JSON-muodossa (tai muussa muodossa, riippuen käytössä olevista riippuvuuksista) lisäämällä pyyntöä käsittelevään metodiin annotaation <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/ResponseBody.html" target="_blank">@ResponseBody</a>. Annotaatio @ResponseBody pyytää Spring-sovelluskehystä asettamaan palvelimen tuottaman datan selaimelle lähetettävän vastauksen runkoon. Jos vastaus on olio, muutetaan se automaattisesti esimerkiksi JSON-muotoiseksi vastaukseksi.</p>

                <pre class="sh_java">
    @RequestMapping(method=RequestMethod.GET)
    @ResponseBody
    public Book getBook() {
        Book book = new Book();
        book.setName("Spring API");
        return book;
    }</pre>

                <p>Edellä mainitut annotaatiot voi myös yhdistää. Oletetaan, että käytössä on <code>bookRepository</code>-niminen olio, jonka metodi <code>save</code> lisää kirjalle yksilöivän tunnuksen ja varastoi sen myöhempää käyttöä varten. Metodi myös palauttaa viitteen uuteen kirja-olioon. Uuden kirjan lisääminen tapahtuisi tällöin seuraavasti.</p> 

                <pre class="sh_java">
    @RequestMapping(method=RequestMethod.POST)
    @ResponseBody
    public Book postBook(@RequestBody Book book) {
        return bookRepository.save(book);
    }</pre>
                
                <p>Nyt palvelulle voi lähettää JSON-muotoista dataa; vastaus on myös JSON-muotoinen, mutta luotavaan kirjaan on liitetty sen yksilöivä tunnus.</p>

                <p>Voimme lisätä annotaatioon @RequestMapping lisätietoa metodin tuottamasta datasta. Attribuutti <code>consumes</code> kertoo minkälaista dataa metodin kuuntelema osoite hyväksyy. Metodi voidaan rajoittaa vastaanottamaan JSON-muotoista dataa merkkijonolla <code>"application/json"</code>. Vastaavasti metodille voidaan lisätä tietoa datasta, jota se tuottaa. Attribuutti <code>produces</code> kertoo tuotettavan datatyypin. Alla määritelty metodi sekä vastaanottaa että tuottaa JSON-muotoista dataa.</p>

                <pre class="sh_java">
    @RequestMapping(method=RequestMethod.POST, 
                      consumes="application/json", produces="application/json")
    @ResponseBody
    public Book postBook(@RequestBody Book book) {
        return bookStorage.create(book);
    }</pre>


                <p>Käytännössä kannattaa käyttää <code>@RestController</code>-annotaatiota kontrolleriluokan määrittelyssä. Tämä asettaa jokaisen luokan metodiin annotaation <code>@ResponseBody</code> sekä sopivan datatyypin -- tässä tapauksessa "application/json".</p>

                <p>Toteutetaan seuraavaksi kaikki tarvitut metodit kirjojen tallentamiseen. Kontrolleri hyödyntää erillistä luokkaa, joka tallentaa kirjaolioita tietokantaan, sekä tarjoaa tuen aiemmin määrittelemiemme books-osoitteiden ja pyyntöjen käsittelyyn -- PUT-metodi on jätetty omaa kokeilua varten.</p>


                <pre class="sh_java">
// importit

@RestController
@RequestMapping("books")
public class BookController {

    @Autowired
    private BookRepository bookRepository;

    @RequestMapping(method=RequestMethod.GET)
    public List&lt;Book&gt; getBooks() {
        return bookRepository.findAll();
    }

    @RequestMapping(value="/{id}", method=RequestMethod.GET)
    public Book getBook(@PathVariable Integer id) {
        return bookRepository.findOne(id);
    }

    @RequestMapping(value="/{id}", method=RequestMethod.DELETE)
    public Book deleteBook(@PathVariable Integer id) {
        return bookRepository.delete(id);
    }    

    @RequestMapping(method=RequestMethod.POST)
    public Book postBook(@RequestBody Book book) {
        return bookRepository.save(book);
    }
}</pre>

                <aside class="info">
		  <br/>
                  <h1>Apuvälineitä rajapinnan tarjoavan sovelluksen testaamiseen</h1>
		  
                  <p>Palvelinohjelmistot, jotka tarjoavat vain avoimen rajapinnan kolmannen osapuolen ohjelmistoille, eivät tyypillisesti sisällä erillistä käyttöliittymää. Tällöin niiden testaaminen tapahtuu tyypillisesti sekä automaattisilla testeillä, että erilaisilla selainohjelmistoilla. Yksi hyvin hyödyllinen apuväline on <a href="https://www.getpostman.com/" target="_blank">Postman</a>, jonka saa lisättyä Google Chromeen Googlen web-storesta.</p>
		  
                  <p>Postmanin hyödyntäminen on erittäin suositeltavaa -- kannattaa katsoa sen johdatusvideo, joka löytyy Postmanin sivulta. Katso myös <a href="https://www.youtube.com/watch?v=7YcW25PHnAA" target="_blank">RESTiä käsittelevä</a> Youtube-video, missä Postmania käytetään hieman.</p>
                </aside>
		
                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-tulospalvelu">
                                    Tulospalvelu
                                </a>
                            </h1>
                        </header>
                        <div id="t-tulospalvelu" class="collapse">

                            <p>Tässä tehtävässä toteutetaan pelitulospalvelu, joka tarjoaa REST-rajapinnan pelien ja tuloksien käsittelyyn. <strong>Huom! Kaikki syötteet ja vasteet ovat JSON-muotoisia olioita.</strong> Tehtäväpohjassa on toteutettu valmiiksi luokat <code>Game</code> ja <code>Score</code> sekä käytännölliset <code>Repository</code>-rajapinnat.</p>

                            <h1>GameController</h1>

                            <p>Pelejä käsitellään luokan <code>Game</code> avulla.</p>

                            <p>Toteuta pakkaukseen <code>wad.controller</code> luokka <code>GameController</code>, joka tarjoaa REST-rajapinnan pelien käsittelyyn:</p>
                            <ul>
                                <li><code>POST /games</code> luo uuden pelin sille annetun pelin tiedoilla ja palauttaa luodun pelin tiedot. (Huom. vieläkin! Pyynnön <strong>rungossa</strong> oleva data on aina JSON-muotoista. Vastaukset tulee myös palauttaa JSON-muotoisina.)</li>
                                <li><code>GET /games</code> listaa kaikki talletetut pelit.</li>
                                <li><code>GET /games/{name}</code> palauttaa yksittäisen pelin tiedot <strong>pelin nimen perusteella</strong>.</li>
                                <li><code>DELETE /games/{name}</code> poistaa nimen mukaisen pelin. Palauttaa poistetun pelin tiedot.</li>
                            </ul>

                            <h1>ScoreController</h1>

                            <p>Jokaiselle pelille voidaan tallettaa pelikohtaisia tuloksia (luokka <code>Score</code>). Jokainen pistetulos kuuluu tietylle pelille, ja tulokseen liittyy aina pistetulos <code>points</code> numerona sekä pelaajan nimimerkki <code>nickname</code>.</p>

                            <p>Toteuta luokka <code>wad.controller.ScoreController</code>, joka tarjoaa REST-rajapinnan tuloksien käsittelyyn:</p>

                            <ul>
                                <li><code>POST /games/{name}/scores</code> luo uuden tuloksen pelille <code>name</code> ja asettaa tulokseen pelin tiedot. Tuloksen tiedot lähetetään kyselyn rungossa.</li>
                                <li><code>GET /games/{name}/scores</code> listaa pelin <code>name</code> tulokset.</li>
                                <li><code>GET /games/{name}/scores/{id}</code> palauttaa tunnuksella <code>id</code> löytyvän tuloksen <code>name</code>-nimiselle pelille.</li>
                                <li><code>DELETE /games/{name}/scores/{id}</code> poistaa avaimen <code>id</code> mukaisen tuloksen peliltä <code>name</code> (pelin tietoja ei tule pyynnön rungossa). Palauttaa poistetun tuloksen tiedot.</li>
                            </ul>

                        </div>
                    </div>
                </div>


                <h2>Valmiin palvelun käyttäminen</h2>

                <p>Palvelinohjelmistoista valmiiseen REST-rajapintaan pääsee kätevästi käsiksi <a href="http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html" target="blank">RestTemplate</a>-luokan avulla. Voimme luoda oman komponentin kirjojen hakemiseen.</p>
                
<pre class="sh_java">
// importit

@Service
public class BookService {

    private RestTemplate restTemplate;
    
    public BookService() {
        this.restTemplate = new RestTemplate();
    }

    // tänne luokan tarjoamat palvelut
}</pre>

                

                <ul>
                    <li>GET osoitteeseen <em>/books</em> palauttaa kaikkien kirjojen tiedot <em>tai</em> osajoukon kirjojen tiedoista -- riippuen toteutuksesta.</li>
                    <pre class="sh_java">
// kirjojen hakeminen
List&lt;Book&gt; books = restTemplate.getForObject("<em>osoite</em>/books", List.class);</pre>
                    <li>GET osoitteeseen <em>/books/{id}</em>, missä {id} on yksittäisen kirjan yksilöivä tunniste, palauttaa kyseisen kirjan tiedot.</li>
                    <pre class="sh_java">
// tunnuksella 5 määritellyn kirjan hakeminen
Book book = restTemplate.getForObject("<em>osoite</em>/books/{id}", Book.class, 5);</pre>
                    <li>PUT osoitteeseen <em>/books/{id}</em>, missä {id} on yksittäisen kirjan yksilöivä tunniste, muokkaa kyseisen kirjan tietoja tai lisää kirjan kyseiselle tunnukselle (toteutuksesta riippuen, lisäystä ei aina toteutettu). Kirjan tiedot lähetetään pyynnön rungossa.</li>

                    <pre class="sh_java">
// tunnuksella 5 määritellyn kirjan hakeminen
Book book = restTemplate.getForObject("<em>osoite</em>/books/{id}", Book.class, 5);
book.setName(book.getName() + " - DO NOT BUY!");

// kirjan tietojen muokkaaminen
restTemplate.put("<em>osoite</em>/books/{id}", book, 5);</pre>
                    <li>DELETE osoitteeseen <em>/books/{id}</em> poistaa kirjan tietyllä tunnuksella.</li>

                    <pre class="sh_java">
 // tunnuksella 32 määritellyn kirjan poistaminen
restTemplate.delete("<em>osoite</em>/books/{id}", 32);</pre>
                    <li>POST osoitteeseen <em>/books</em> luo uuden kirjan pyynnön rungossa lähetettävän datan pohjalta. Palvelun vastuulla on päättää kirjalle tunnus.</li>

                    <pre class="sh_java">
Book book = new Book();
book.setName("Harry Potter and the Goblet of Fire");

// uuden kirjan lisääminen
book = restTemplate.postForObject("<em>osoite</em>/books", book, Book.class);</pre>
                </ul>


                <p>Jos palvelua haluaa käyttää selainohjelmistosta, onnistuu se esimerkiksi <a href="http://jquery.com/" target="_blank">jQuery</a>-projektin avulla. Yksittäisen kirjan tietojen hakeminen ja nimen näyttäminen käyttäjälle onnistuu yksinkertaisimmillaan seuraavasti:</p>

                <pre class="sh_java">
$.get("<em>osoite</em>/books/5", function( data ) {
  alert( "Tunnuksella 5 löytyi kirja nimeltä: " + data.name );
});</pre>

                <p>Usein sivustot käyttävät useampaa palvelua samaan aikaan. Harjoitellaan seuraavaksi hieman tällaisen palvelun tekemistä. </p>

                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-gamerater">
                                    GameRater
                                </a>
                            </h1>
                        </header>
                        <div id="t-gamerater" class="collapse">

                            <p>Palvelu <em>GameRater</em> lisää aiempaan tulospalveluun mahdollisuuden arvostella yksittäisiä pelejä antamalla niille numeroarvosanan 0-5. Arvostelu tehdään kuitenkin erilliseen palveluun, emmekä siis laajenna edellistä palvelua suoraan.</p>

                            <p><em>GameRater</em>-palvelun tulee käyttää <em>Tulospalvelu</em>-palvelun REST-rajapintaa, jonka avulla se tarjoaa samanlaisen rajapinnan pelien ja tulosten käsittelyyn. Ainoastaan pelien arvostelut käsitellään ja talletetaan tässä palvelussa! Arvosteluihin käytettävä entiteetti <code>Rating</code> ja siihen liittyvät palveluluokat on valmiina tehtäväpohjassa.</p>

                            <p><strong>Huom!</strong> Joudut tutkimaan tehtäväpohjassa annettua koodia, jotta voit hyödyntää sitä. Joudut myös lukemaan tehtävän <em>Tulospalvelu</em> kuvausta tämän tehtävän toteutuksessa.</p>

                            <p><strong>Huom!</strong> Valmis <em>Tulospalvelu</em>-palvelu löytyy osoitteesta <code>http://wepa-scoreservice-heroku.herokuapp.com/games</code>, joten voit tehdä tämän tehtävän täysin riippumatta tulospalvelu-tehtävästä.</p>


                            <h1>GameRestClient ja GameController</h1>

                            <p>Tee luokka <code>wad.service.GameRestClient</code>, joka toteuttaa rajapinnan <code>GameService</code>. Luokan tulee käyttää <em>Tulospalvelu</em>-palvelua kaikissa rajapinnan määrittelemissä toiminnoissa. REST-rajapinnan käyttö onnistuu Springin <code>RestTemplate</code>-luokan avulla.</p>

                            <p><strong>Huom!</strong> <code>GameRestClient</code>-luokan <code>setUri</code>-metodi ottaa parametriksi yllä annetun URL-osoitteen valmiiseen <em>Tulospalvelu</em>-palveluun.</p>

                            <p>Luo luokka <code>wad.controller.GameController</code>, joka tarjoaa <strong>täsmälleen samanlaisen</strong> JSON/REST-rajapinnan kuin <em>Tulospalvelu</em>-palvelun <code>GameController</code>, mutta siten, että jokainen toiminto käyttää valmista <em>Tulospalvelu</em>-palvelua rajapinnan <code>GameService</code> kautta.</p>

                            <p><strong>Huom!</strong> Muista asettaa <code>GameService</code>-rajapinnan kautta URL-osoite valmiiseen <code>http://wepa-scoreservice-heroku.herokuapp.com/games</code>-osoitteeseen ohjelman käynnistyessä, esimerkiksi controller-luokan <code>@PostConstruct</code>-metodissa.</p>


                            <h1>RatingController</h1>

                            <p>Jokaiselle pelille voidaan tallettaa pelikohtaisia arvosteluja entiteetin <code>Rating</code> avulla. Arvosteluun liittyy numeroarvosana <code>rating</code> (0-5).</p>

                            <p>Arvostelut liittyvät peleihin, jotka on talletettu eri palveluun, joten entiteetin <code>Rating</code> viittaus peliin täytyy tallettaa suoraan avaimena. Koska peleihin viitataan REST-rajapinnassa pelin nimellä, talletetaan jokaiseen <code>Rating</code>-entiteettiin pelin nimi attribuuttiin <code>gameName</code>. Tämän attribuutin avulla voidaan siis löytää arvosteluja pelin nimen perusteella.</p>

                            <p>Toteuta luokka <code>wad.controller.RatingController</code>, joka tarjoaa REST-rajapinnan arvostelujen käsittelyyn:</p>

                            <ul>
                                <li><code>POST /games/{name}/ratings</code> luo uuden arvostelun pelille <code>name</code> - ainoa vastaanotettava attribuutti on <code>rating</code></li>
                                <li><code>GET /games/{name}/ratings</code> listaa talletetut arvostelut pelille <code>name</code></li>
                                <li><code>GET /games/{name}/ratings/{id}</code> palauttaa yksittäisen arvostelun tiedot pelin nimen <code>name</code> ja avaimen <code>id</code> perusteella</li>
                                <li><code>DELETE /games/{name}/ratings/{id}</code> poistaa avaimen <code>id</code> mukaisen arvostelun</li>
                            </ul>

                        </div>
                    </div>
                </div>
                
                

                <aside class="info">
		  <br/>
		  
                  <h1>Navigoitavuus</h1>
		  
                  <p>Tähän asti toteuttamiemme palveluiden tarjoamat rajapinnat eivät ole sisältäneet linkkejä, joiden avulla resurssien välillä navigointi olisi ollut helppoa tai mahdollista. Tutustumme kohta menetelmään, jonka avulla näiden palveluiden tekeminen helpottuu huomattavasti; toinenkin tekniikka on olemassa -- osoitteessa <a href="http://spring.io/guides/gs/rest-hateoas/" target="_blank">http://spring.io/guides/gs/rest-hateoas/</a> kuvataan eräs menetelmä navigoitavan REST-rajapinnan toteuttamiseen.</p>
                  
                </aside>
		
		
                <h2>REST-palvelun kypsyystasot</h2>

                <p>Martin Fowler käsittelee artikkelissaan <a href="http://martinfowler.com/articles/richardsonMaturityModel.html" target="_blank">Richardson Maturity Model</a> REST-rajapintojen kypsyyttä. Richardson Maturity Model (RMM) jaottelee REST-toteutuksen kolmeen tasoon, joista kukin tarkentaa toteutusta.</p>

                <p>Aloituspiste on tason 0 palvelut, joita ei pidetä REST-palveluina. Näissä palveluissa HTTP-protokollaa käytetään lähinnä väylänä viestien lähettämiseen ja vastaanottamiseen, ja HTTP-protokollan käyttötapaan ei juurikaan oteta kantaa. Esimerkki tason 0 palvelusta on yksittäinen kontrollerimetodi, joka päättelee toteutettavan toiminnallisuuden pyynnössä olevan sisällön perusteella.</p>

                <p>Tason 1 palvelut käsittelevät palveluita resursseina. Resurssit kuvataan palvelun osoitteena (esimerkiksi <code>/books</code>-resurssi sisältää kirjoja), ja resursseja voidaan hakea tunnisteiden perusteella (esim. <code>/books/nimi</code>). Edelliseen tasoon verrattuna käytössä on nyt konkreettisia resursseja; olio-ohjelmoijan kannalta näitä voidaan pitää myös olioina joilla on tila.</p>

                <p>Tasolla 2 resurssien käsittelyyn käytetään kuvaavia HTTP-pyyntötyyppejä. Esimerkiksi resurssin pyyntö tapahtuu GET-metodilla, ja resurssin tilan muokkaaminen esimerkiksi PUT, POST, tai DELETE-metodilla. Näiden lisäksi palvelun vastaukset kuvaavat tapahtuneita toimintoja. Esimerkiksi jos palvelu luo resurssin, vastauksen tulee olla statuskoodi <code>201</code>, joka viestittää selaimelle resurssin luomisen onnistumisesta. Oleellista tällä tasolla on pyyntötyyppien erottaminen sen perusteella että muokkaavatko ne palvelimen dataa vai ei (GET vs. muut).</p>

                <p>Kolmas taso sisältää tasot 1 ja 2, mutta lisää käyttäjälle mahdollisuuden ymmärtää palvelun tarjoama toiminnallisuus palvelimen vastausten perusteella. Webissä huomiota herättänyt termi <a href="https://weblogs.java.net/blog/mkarg/archive/2010/02/14/what-hateoas-actually-means" target="_blank">HATEOAS</a> käytännössä määrittelee miten web-resursseja tulisi löytää webistä.</p>


                <p>RESTin isä, Roy Fielding, pitää vain tason 3 sovellusta oikeana REST-sovelluksena. Ohjelmistosuunnittelun näkökulmasta jokainen taso parantaa sovelluksen ylläpidettävyyttä -- <em>Level 1 tackles the question of handling complexity by using divide and conquer, breaking a large service endpoint down into multiple resources; Level 2 introduces a standard set of verbs so that we handle similar situations in the same way, removing unnecessary variation; Level 3 introduces discoverability, providing a way of making a protocol more self-documenting.</em> (<a href="http://martinfowler.com/articles/richardsonMaturityModel.html" target="_blank">lähde</a>)</p>


                <p><em>Huom! Sovellusta suunniteltaessa ja toteuttaessa ei tule olettaa että RMM-tason 3 sovellus olisi parempi kuin RMM-tason 2 sovellus. Sovellus voi olla huono riippumatta toteutetusta REST-rajapinnan muodosta -- jossain tapauksissa rajapintaa ei oikeasti edes tarvita; asiakkaan tarpeet ja toiveet määräävät mitä sovelluskehittäjän kannattaa tehdä.</em></p>



                <h2>Spring Data Rest</h2>

                <p>Spring-sovelluskehys sisältää projektin <a href="http://projects.spring.io/spring-data-rest/" target="_blank">Spring Data REST</a>, minkä avulla REST-palveluiden tekeminen helpottuu hieman. Lisäämällä projektin <code>pom.xml</code>-konfiguraatioon riippuvuus <code>spring-boot-starter-data-rest</code> saamme Spring Boot-paketoidun version kyseisestä projektista käyttöömme.</p>

                <pre class="sh_xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>

                <p>Nyt Repository-luokkamme tarjoavat automaattisesti REST-rajapinnan, jonka kautta resursseihin pääsee käsiksi. REST-rajapinta luodaan oletuksena sovelluksen juureen, ja tehdään luomalla monikko domain-olioista. Esimerkiksi, jos käytössä on luokka <code>Book</code>, sekä sille määritelty <code>BookRepository</code>, joka perii Spring Data JPA:n rajapinnan, generoidaan rajapinnan <code>/books</code> alle toiminnallisuus kirja-olioiden muokkaamiseen.</p>

                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-esinevarasto">
                                    Esinevarasto
                                </a>
                            </h1>
                        </header>
                        <div id="t-esinevarasto" class="collapse">

                            <p>Luo rajapinta <code>ItemRepository</code>, joka tarjoaa <code>Item</code>-olioiden tietokantatallennustoiminnallisuuden. Lisää tämän jälkeen Spring Data REST-riippuvuus pom.xml-tiedostoon, ja tarkista REST-rajapintasi toiminta esimerkiksi Postman REST Clientin avulla. Wat is this magic?</p>

                        </div>
                    </div>
                </div


                <p>Usein käytännössä sovelluksemme kuitenkin toimivat jo palvelun juuripalvelussa, ja haluaisimme esimerkiksi tarjota rajapinnan erillisessä osoitteesssa. Spring Data REST-projektin konfiguraatiota voi muokata erillisen <code>RepositoryRestMvcConfiguration</code>-luokan kautta. Alla olevassa esimerkissä REST-rajapinta luodaan osoitteen <code>/api/v1</code>-alle. Annotaatio <code>@Configuration</code> kertoo Springille että luokka sisältää konfiguraatiota, ja perittävä luokka kertoo mistä konfiguraatiosta on kyse.</p>

                <pre class="sh_java">
// pakkaus

import java.net.URI;
import java.net.URISyntaxException;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.rest.core.config.RepositoryRestConfiguration;
import org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration;

@Configuration
public class RestConfig extends RepositoryRestMvcConfiguration {

    @Override
    protected void configureRepositoryRestConfiguration(RepositoryRestConfiguration config) {
        super.configureRepositoryRestConfiguration(config);
        try {
            config.setBaseUri(new URI("/api/v1"));
        } catch (URISyntaxException e) {
            throw new RuntimeException("Unable to bind REST API to address /api/v1");
        }
    }
}
                </pre>

                <p>Nyt jos sovelluksessa on entiteetti <code>Book</code> sekä siihen sopiva <code>BookRepository</code>, on Spring Data REST-rajapinta osoitteessa <code>/api/v1/books</code>.</p>

                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-viestiapi">
                                    ViestiApi
                                </a>
                            </h1>
                        </header>
                        <div id="t-viestiapi" class="collapse">

                            <p>Tehtävässä on käytössä viikon 2 tehtävistä tuttu viestien kirjoitus- ja lukemispalvelu. Muokkaa sovellusta siten, että sovellus tarjoaa REST-rajapinnan viestien käsittelyyn. GET-pyynnön osoitteeseen <code>/api/messages</code> tulee palauttaa lista viesteistä, POST-pyyntö osoitteeseen <code>/api/messages</code> luo uuden viestin, jne.</p>

                        </div>
                    </div>
                </div>


                <p>Käytännössä sovelluksen kehittäjä ei kuitenkaan tyypillisesti halua kaikkia HTTP-protokollan metodeja kaikkien käyttöön. Käytössä olevien metodien rajaaminen onnistuu käytettävää <code>Repository</code>-rajapintaa muokkaamalla. Alla olevassa esimerkissä <code>BookRepository</code>-rajapinnan olioita ei pysty poistamaan automaattisesti luodun REST-rajapinnan yli.</p>

                <pre class="sh_java">
// pakkaus
import wad.domain.Book;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.rest.core.annotation.RestResource;

public interface BookRepository extends JpaRepository&lt;Message, Long&gt; {

    @RestResource(exported = false)
    @Override
    public void delete(Long id);

}</pre>

                <h3>Spring Data REST ja RestTemplate</h3>

                <p>Spring Data RESTin avulla luotavien rajapintojen hyödyntäminen onnistuu RestTemplaten avulla. Esimerkiksi yllä luotavasta rajapinnasta voidaan hakea <code>Resource</code>-olioita, jotka sisältävät kirjoja. RestTemplaten metodin <code><a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html#exchange-java.lang.String-org.springframework.http.HttpMethod-org.springframework.http.HttpEntity-java.lang.Class-java.lang.Object...-" target="_blank">exchange</a></code> palauttaa vastausentiteetin, mikä sisältää hakemamme olion tiedot. Kyselyn mukana annettava <code>ParameterizedTypeReference</code> taas kertoo minkälaiseksi olioksi vastaus tulee muuntaa.</p>

                <pre class="sh_java">
RestTemplate restTemplate = new RestTemplate();
ResponseEntity&lt;Resource&lt;Book&gt;&gt; response = 
    restTemplate.exchange("<em>osoite</em>/books/1", // osoite
                          HttpMethod.GET, // metodi
                          null, // pyynnön runko; tässä tyhjä
                          new ParameterizedTypeReference&lt;Resource&lt;Book&gt;&gt;() {}); // vastaustyyppi

if (response.getStatusCode() == HttpStatus.OK) {
    Resource&lt;Book&gt; resource = response.getBody();
    Book book = resource.getContent();
}
                </pre>



                <aside class="extra">
                    <h1>HAL</h1>

                    <p>HAL on spesifikaatio siitä, miten rajapinnat tulee toteuttaa jotta ne ovat helposti löydettävissä. Spring Data RESTin avulla luodut rajapinnat toteuttavat HAL-spesifikaation -- tutustu spesifikaatioon tarkemmin osoitteessa <a href="http://stateless.co/hal_specification.html" target="_blank">http://stateless.co/hal_specification.html</a>.</p>

                </aside>


                <h1>HTTP-protokolla ja sessiot</h1>
		
                <p>HTTP on tilaton protokolla, eli se ei tarvitse jatkuvasti avoinna olevaa yhteyttä toimiakseen. Tämä tarkoittaa sitä, että HTTP ei osaa yhdistää samalta käyttäjältä tulevia pyyntöjä toisiinsa, jolloin jokainen tehty pyyntö käsitellään omana erillisenä pyyntönään. Käytännössä yhden web-sivuston hakeminen saattaa sisältää kymmeniä pyyntöjä, sillä jokaiseen sivuun liittyy joukko kuvia ja skriptitiedostoja, joista kukin on oma erillinen resurssinsa.</p>

                <p>Vaikka HTTP on tilaton protokolla, on asiakkaan tunnistamiseen käytetty pitkään erilaisia kiertotapoja. Klassinen -- mutta erittäin huono -- tapa kiertää HTTP:n tilattomuus on ollut säilyttää GET-muotoisessa osoitteessa parametreja, joiden perusteella asiakas voidaan identifioida palvelinsovelluksessa. Parametrien käyttö osoitteissa ei ole kuitenkaan ongelmatonta: osoitteessa olevia parametreja voi helposti muokata käsin, jolloin palvelinsovelluksesta saattaa löytyä tietoturva-aukkoja tai ei-toivottua käyttäytymistä.</p>

                <aside class="info">
		  <br/>
                  <h1>Case: GET-parametri tunnistautumiseen</h1>

                  <p>Eräässä järjestelmässä verkkokaupan toiminnallisuus oli toteutettu siten, että GET-parametrina säilytettiin numeerista ostoskorin identifioivaa tunnusta. Käyttäjäkohtaisuus oli toteutettu palvelinpuolella siten, että tietyllä GET-parametrilla näytettiin aina tietyn käyttäjän ostoskori. Uusien tuotteiden lisääminen ostoskoriin onnistui helposti, sillä pyynnöissä oli aina mukana ostoskorin tunnistava GET-parametri. Ostoskorit oli valitettavasti identifioitu juoksevalla numerosarjalla. Henkilöllä 1 oli ostoskori 1, henkilöllä 2 ostoskori 2 jne.. Koska käytännössä kuka tahansa pääsi katsomaan kenen tahansa ostoskoria vain osoitteessa olevaa numeroa vaihtamalla, olivat ostoskorien sisällöt välillä hyvin mielenkiintoisia.</p>
                </aside>
		
                 <p>HTTP-protokollan tilattomuus ei pakota palvelinohjelmistoja tilattomuuteen. Palvelimella tilaa pidetään yllä jollain tietyllä tekniikalla, joka taas ei näy HTTP-protokollaan asti. Yleisin tekniikka tilattomuuden kiertämiseen on evästeiden käyttö.</p>


                <h2>HTTP-protokollan tilattomuuden kiertäminen: evästeet</h2>

                <p>HTTP on tilaton protokolla, eli käyttäjän toimintaa ja tilaa ei pysty pitämään yllä puhtaasti HTTP-yhteyden avulla. Käytännössä suurin osa verkkosovelluksista kuitenkin sisältää käyttäjäkohtaista toiminnallisuutta, jonka toteuttamiseen sovelluksella täytyy olla jonkinlainen tieto käyttäjästä ja käyttäjän tilasta. HTTP/1.1 tarjoaa mahdollisuuden tilallisten verkkosovellusten toteuttamiseen evästeiden (<em>cookies</em>) avulla.</p>

                <p>Asettamalla käyttäjän tekemän pyynnön vastaukseen eväste, tulee käyttäjän jatkossa pyyntöä tehdessä aina palauttaa kyseinen eväste pyynnön otsaketietoina. Tämä tapahtuu automaattisesti selaimen toimesta. Evästeitä käytetään istuntojen (<em>session</em>) ylläpitämiseen: istuntojen avulla pidetään kirjaa käyttäjästä useampien pyyntöjen yli.</p>

                <p>Evästeet toteutetaan otsakkeiden avulla. Kun käyttäjä tekee pyynnön palvelimelle, ja palvelimella halutaan asettaa käyttäjälle eväste, palauttaa palvelun vastauksen mukana otsakkeen <code>Set-Cookie</code>, jossa määritellään käyttäjäkohtainen evästetunnus. Set-Cookie voi olla esimerkiksi seuraavan näköinen:</p>

                <pre>
Set-Cookie: SESS57a5819a77579dfb1a1466ccceee22a0=0hr0aa2ogdfgkelogg; Max-Age=3600; Domain=".helsinki.fi"
                </pre>

                <p>Ylläoleva palvelimelta lähetetty vastaus ilmoittaa pyytää selainta tallettamaan evästeen. Selaimen tulee jatkossa lisätä eväste <code>SESS57a5819a77579dfb1a1466ccceee22a0=0hr0aa2ogdfgkelogg</code> jokaiseen <code>helsinki.fi</code>-osoitteeseen. Eväste on voimassa tunnin, eli tunnin kuluttua sen voi poistaa. Tarkempi syntaksi evästeen asettamiselle on seuraava:</p>

                <pre>
Set-Cookie: nimi=arvo [; Comment=kommentti] [; Max-Age=elinaika sekunteina]
                      [; Expires=parasta ennen paiva] [; Path=polku tai polunosa jossa eväste voimassa]
                      [; Domain=palvelimen osoite (URL) tai osoitteen osa jossa eväste voimassa]
                      [; Secure (jos määritelty, eväste lähetetään vain salatun yhteyden kanssa)]
                      [; Version=evästeen versio]
                </pre>


                <p>Evästeet tallennetaan selaimen sisäiseen evästerekisteriin, josta niitä haetaan aina kun käyttäjä tekee kyselyn johonkin osoitteeseen. Evästeet lähetetään palvelimelle jokaisen viestin yhteydessä <code>Cookie</code>-otsakkeessa. </p>

                <pre>
Cookie: SESS57a5819a77579dfb1a1466ccceee22a0=0hr0aa2ogdfgkelogg
                </pre>

                <p>Evästeiden nimet ja arvot ovat yleensä monimutkaisia ja satunnaisesti luotuja niiden yksilöllisyyden takaamiseksi. Samaan osoitteeseen voi liittyä myös useampia evästeitä. Yleisesti ottaen evästeet ovat sekä hyödyllisiä että haitallisia: niiden avulla voidaan luoda yksiöityjä käyttökokemuksia tarjoavia sovelluksia, mutta niitä voidaan käyttää myös käyttäjien seurantaan ympäri verkkoa.</p>

                <aside class="info">
		  <br/>
                  <h1>Kekseliästä</h1>

                  <p>Painamalla F12 tai valitsemalla Tools -> Developer tools, pääset tutkimaan sivun lataamiseen ja sisältöön liittyvää statistiikkaa. Lisäneuvoja löytyy <a href="https://developers.google.com/chrome-developer-tools/docs/overview" target="_blank">Google Developers</a> -sivustolta.</p>

                  <p>Avaa developer tools, ja mene osoitteeseen <a href="http://www.hs.fi" target="_blank">http://www.hs.fi</a>. Valitsemalla developer toolsien välilehden <code>Resources</code>, löydät valikon erilaisista sivuun liittyvistä resursseista. Avaa <code>Cookies</code> ja valitse vaihtoehto <code>www.hs.fi</code>. Kuinka moni palvelu pitää sinusta kirjaa kun menet Helsingin sanomien sivuille?</p>

                </aside>

                <p>Springissä käyttäjäkohtaiseen <em>sessioon</em> pääsee käsiksi tarvittaessa. Jos käytettävään komponenttiin injektoidaan <code>HttpSession</code>-luokan ilmentymä, voidaan siihen lisätä tietoa joka on yllä käyttäjän session ajan. Session pituus riippuu esimerkiksi palvelimen asetuksista <code>session timeout</code> ja siitä, että salliiko käyttäjä evästeiden käytön. Yksinkertainen käyttäjäkohtainen laskuri, joka laskee pyyntöjen määrän sessiossa toteutettaisiin esimerkiksi seuraavasti.</p>

                <pre class="sh_java">
// ...
    @Autowired
    private HttpSession session;

    @RequestMapping(method = RequestMethod.GET)
    public String list(Model model) {
        Integer count = 1;
        if(session.getAttribute("count") != null) {
            count += (Integer) session.getAttribute("count");
        }
        
        session.setAttribute("count", count);
        
        model.addAttribute("count", count);
        return "counts";
    }

// ...</pre>


                <p>Session käyttö yllämainitulla tavalla on kuitenkin melko harvinaista, sillä sessiossa olevat tiedot katoavat kun käyttäjä poistaa sivun evästeet tai evästeen elinikä on kulunut loppuun.</p>

                <p>Evästeitä voi kuitenkin hyödyntää esimerkiksi väliaikaisten asioiden ja tietojen ylläpidossa. Voimme esimerkiksi luoda komponentteja, jotka ovat elossa vain session ajan. Tyypillinen esimerkki tästä on ostoskori:</p>

                <pre class="sh_java">
// importit 

@Component
@Scope(value = "session", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class ShoppingCart implements Serializable {

    private Map&lt;Item, Integer&gt; items;

    public ShoppingCart() {
        this.items = new TreeMap&lt;&gt;();
    }

    public Map&lt;Item, Integer&gt; getItems() {
        return items;
    }

    public void setItems(Map&lt;Item, Integer&gt; items) {
        this.items = items;
    }

    public boolean isEmpty() {
        return items == null || items.isEmpty();
    }
}</pre>

                <p>Ylläolevasta komponentista luotavat ilmentymät ovat elossa vain käyttäjän session ajan, eli sen aikaa kun käyttäjän eväste on elossa. Ylläolevasta ostoskorista saa lisättyä ilmentymän sovellukseen aivan kuten muistakin komponenteista, eli <code>@Autowired</code>-annotaatiolla.</p>

                <p></p>


                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-euroshopper">
                                    EuroShopper
                                </a>
                            </h1>
                        </header>
                        <div id="t-euroshopper" class="collapse">

                            <p>Tässä tehtävässä toteutetaan verkkokauppaan ostoskoritoiminnallisuus.</p>

                            <h1>Ostoskori</h1>

                            <p>Luo pakkaukseen <code>wad.domain</code> luokka <code>ShoppingCart</code>, joka tarjoaa seuraavat toiminnallisuudet.</p>

                            <ul>
                                <li> Metodi <code>getItems()</code> palauttaa <code>Map&lt;Item, Long&gt;</code>-tyyppisen olion, joka sisältää ostoskorissa olevien tuotteiden tuotekohtaisen lukumäärän.</li>
                                <li> Metodi <code>addToCart(Item item)</code> lisää ostoskoriin yhden kappaleen <code>Item</code>-tyyppistä esinettä.</li>
                                <li> Metodi <code>removeFromCart(Item item)</code> poistaa ostoskorista yhden kappaleen <code>Item</code>-tyyppistä esinettä. Jos lukumäärä laskee nollaan, <code>getItems()</code>-metodin ei tule sisältää enää kyseistä tuotetta.</li>
                            </ul>


                            <h1>Kontrolleri ostoskorille</h1>

                            <p>Tee ostoskorista sessiokohtainen, eli eri käyttäjien tulee saada eri ostoskori käyttöönsä. Annotaatiosta <code>Scope</code> on tässä hyötyä.</p>

                            <p>Luo projektiin sopiva kontrolleri, joka tarjoaa seuraavat osoitteet ja toiminnallisuudet.</p>

                            <ul>
                                <li>GET /cart asettaa model-olion "items"-nimiseen attribuuttiin ostoskorin sisällön (aiempi <code>getItems()</code>). Pyynnön vastauksena käyttäjälle näytetään sivu, joka luodaan polussa <code>/src/main/resources/templates/cart.html</code> olevasta näkymästä.</li>
                                <li>POST /cart/items/{id} lisää ostoskoriin yhden {id}-tunnuksella tietokannasta löytyvän Item-olion. Pyyntö ohjataan osoitteeseen <code>/cart</code>.</li>
                                <li>DELETE /cart/items/{id} poistaa ostoskorista yhden {id}-tunnuksella tietokannasta löytyvän Item-olion. Pyyntö ohjataan osoitteeseen <code>/cart</code>.</li>
                            </ul>

                            <h1>Tilauksen tekeminen</h1>

                            <p>Muokkaa luokkaa <code>wad.service.OrderService</code> siten, että tilaus tallennetaan tietokantaan. Tutustu luokkiin <code>Order</code>, <code>OrderItem</code> ja <code>UserDetails</code> ennen toteutusta. Varmista että esimerkiksi <code>OrderItem</code> viittaa oikeaan tietokantatauluun.</p>

                            <p>Kun tilaus on tehty, tyhjennä ostoskori.</p>

                        </div>
                    </div>
                </div>

            </section>
            <!-- END WEEK3 -->


            <!-- BEGIN WEEK4 -->
            <section class="weeklimit" data-week-id="4">
                <header>
                    <h1 id="viikko4">Viikko 4</h1>
                </header>

                <h1>Palvelukeskeiset arkkitehtuurit</h1>

                <aside class="extra">
                    <p><em>...Koska ohjelmistoista halutaan mahdollisimman nopeasti konkreettista palautetta, arkkitehti aloittaa ohjelmiston suunnittelun perustarpeista: muutamasta huoneesta, joihin palautetta antavat ihmiset muuttavat. Kun alkuperäinen suunnitelma on lähes valmis, rakennukseen muuttaa lisää ihmisiä, jotka tarvitsevat rakennukselta uusia toiminnallisuuksia. Ensisijaisina vaatimuksina ovat uudet huoneet, pesula, disko ja luonnollisesti oleskelutila, jossa on tilaa biljardipöydälle. Tällöin arkkitehti soveltaa alkuperäistä suunnitelmaansa mukauttamaan uudet ihmiset ja kehitystyö jatkuu. Kehitystyön jatkuessa alkuperäiset asukkaat alkavat valittamaan rakennusmelusta ja uhkaavat poismuutolla, jos asioihin ei saada muutosta, aiheuttaen hiusten harvenemista arkkitehdille. Toisaalta, sana uudesta biljardipöydästä kiertää, ja yhä enemmän ihmisiä muuttaa rakennukseen, ja rakennukselta vaaditaan taas uusia huoneita, mukaanlukien cartingrata ja curlinghalli.</em></p>
                </aside>

                <p>Kurssin alkupuolella ollut ohjelmistokehittäjän elämää parodioiva kuvaus kuvaa yksittäisen sovelluksen kehitystä. Sovellukseen lisättävät huoneet ovat uusia metodeja, luokkia ja kontrollereita sovelluksessa, aivan kuten pesula, disko ja muut oleelliset elintilat. Sovelluksen kasvaessa sen ylläpidettävyys ja testaus muuttuu haastavammaksi, sillä kaikki osa-alueet ovat leivottu samaan sovellukseen. Tutustutaan tässä kappaleessa toisenlaiseen ajattelutapaan; sovellusten koostamiseen palveluista.</p>


                <p>Monoliittiset "minä sisällän kaiken mahdollisen"-sovellukset ovat usein vaikeita ylläpitää, sillä uuden toiminnallisuuden lisääminen vaatii olemassaolevan sovelluksen muokkaamista sekä testaamista. Olemassaoleva sovellus voi olla kirjoitettu hyvin vähäisesssä käytössä olevalla kielellä (vrt. pankkijärjestelmät ja COBOL) ja esimerkiksi kehitystä tukevat automaattiset testit voivat puuttua siitä täysin.</p>

                <p>Yrityksen toiminta-alueiden laajentuessa sekä uusien sovellustarpeiden ilmentyessä aiemmin toteutettuihin toiminnallisuuksiin olisi hyvä päästä käsiksi, mutta siten, että toiminnallisuuden käyttäminen ei vaadi juurikaan olemassaolevan muokkausta. Kun pohdimme aiempaa rakennusesimerkkiä, lienee selvää, että esimerkiksi diskoon voisi päästää muitakin kuin rakennuksen asukkaita, kun taas yksittäiset huoneet kannattanee pitää vain muutaman henkilön käytössä.</p>

                <p>Koostamalla sovellus erillisistä palveluista saadaan luotua tilanne, missä palvelut ovat tarvittaessa myös uusien sovellusten käytössä. Palvelut tarjoavat rajapinnan (esim. REST) minkä kautta niitä voi käyttää. Samalla rajapinta kapseloi palvelun toiminnan, jolloin muiden palvelua käyttävien sovellusten ei tarvitse tietää sen toteutukseen liittyvistä yksityiskohdista. Oleellista on, että yksikään palvelu ei yritä tehdä kaikkea. Tämä johtaa myös siihen, että yksittäisen palvelun toteutuskieli ei vaikuta muiden komponenttien toimintaan -- oleellista on vain se, että palvelu tarjoaa rajapinnan jota voi käyttää ja joka löydetään.</p>

                <p>Yrityksen kasvaessa sen sisäiset toiminnat ja rakennettavat ohjelmistot sisältävät helposti päällekkäisyyksiä. Tällöin tilanne on käytännössä se, että aikaa käytetään samankaltaisten toimintojen ylläpitoon useammassa sovelluksessa -- pyörä keksitään yhä uudestaan ja uudestaan uudestaan uusia sovelluksia kehitettäessä.</p>


                <aside class="extra">

                    <h1>Amazon ja Palveluorientoituneet arkkitehtuurit</h1>

                    <p>Amazon on hyvä esimerkki yrityksestä, joka on menestynyt osittain sen takia, että se on toteuttanut tarjoamansa toiminnallisuudet palveluina. Siirtymä ei kuitenkaan ollut yksinkertainen, allaoleva viesti on katkelma Amazonin toimitusjohtajan, Jeff Bezosin, noin vuonna 2002 kirjoittamasta viestistä yritykselle (<a href="https://plus.google.com/+RipRowan/posts/eVeouesvaVX" target="_blank">lähde</a>).</p>

                    <pre>
1) All teams will henceforth expose their data and functionality 
   through service interfaces.

2) Teams must communicate with each other through these interfaces.

3) There will be no other form of interprocess communication allowed: 
   no direct linking, no direct reads of another team's data store, 
   no shared-memory model, no back-doors whatsoever. The only communication 
   allowed is via service interface calls over the network.

4) It doesn't matter what technology they use. HTTP, Corba, Pubsub, 
   custom protocols — doesn't matter.

5) All service interfaces, without exception, must be designed from the 
   ground up to be externalizable. That is to say, the team must plan 
   and design to be able to expose the interface to developers in the 
   outside world. No exceptions.

6) Anyone who doesn't do this will be fired.</pre>

                    <p>Oikeastaan, hyvin suuri syy sille, että Amazon tarjoaa nykyään erilaisia pilvipalveluita (kts. <a href="http://aws.amazon.com/" target="_blank">Amazon Web Services</a>) liittyy siihen kokemukseen, mitä yrityksen työntekijät sekä yritys on kerännyt kun yrityksen sisäistä toimintaa kehitettiin kohti palveluja tarjoavia ohjelmistotiimejä.</p>
                </aside>

                <p>SOA (<em><a href="http://en.wikipedia.org/wiki/Service-oriented_architecture" target="_blank">Service Oriented Architecture</a></em>), eli palvelukeskeinen arkkitehtuuri, on suunnittelutapa, jossa eri sovelluksen komponentit on suunniteltu toimimaan itsenäisinä avoimen rajapinnan tarjoavina palveluina. Pilkkomalla sovellukset erillisiin palveluihin pyritään luomaan tilanne, jossa palveluita voidaan käyttää myös tulevaisuudessa kehitettävien sovellusten toimesta.</p>

                <p>SOA-palveluita käyttävät esimerkiksi toiset palvelut tai selainohjelmistot. Selainohjelmistot voivat hakea palvelusta JSON-muotoista dataa Javascriptin avulla ilman tarvetta omalle palvelinkomponentille. SOA-arkkitehtuurin avulla voidaan helpottaa myös ikääntyvien sovellusten jatkokäyttöä: ikääntyvät sovellukset voidaan kapseloida rajapinnan taakse, jonka kautta sovelluksen käyttö onnistuu myös jatkossa.</p>


                <p><em>Huom! Kuten aiemminkin olemme todenneet, terveen järjen käyttäminen on tässäkin tärkeää. Huikean arkkitehtuurin ei tule olla yrityksen päätavoite, mutta se voi olla tapa päästä tavoitteeseen.</em></p>

                <aside class="extra">

                    <h1>Palveluiden löytäminen</h1>

                    <p>Palveluorientoituneiden arkkitehtuurien yleistyessä markkinoille on myös ilmestynyt ESB (<a href="http://en.wikipedia.org/wiki/Enterprise_service_bus" target="_blank">enterprise service bus</a>)-sovelluksia, joiden tehtävä on toimia viestinvälittäjänä palveluiden välillä. Viestinvälityspalveluiden käyttäminen johtaa siihen, että palvelut ovat paremmin eriytettynä toisistaan -- palvelua A käyttävä palvelu B tietää vain viestinvälittäjän sekä palvelun A tunnisteen. Palvelun A tunniste ja kuvaus voidaan saada viestinvälittäjältä, ja palvelu voi kuvata itsensä esimerkiksi RAML (<a href="http://raml.org/" target="_blank">RESTful API Modeling Language</a>)-kuvauksen tai <a href="https://helloreverb.com/developers/swagger" target="_blank">Swagger</a>in avulla.</p>

                    <p>Kantamme tällä kurssilla ESB-sovelluksiin on kuitenkin melko sama kuin Martin Fowlerilla ja Jim Webberillä; liika ylimääräinen toiminnallisuus voi vaikeuttaa palveluiden käyttöä ja kankeuttaa organisaatiota. Katso esitys <a href="http://www.infoq.com/presentations/soa-without-esb" target="_blank">Does My Bus Look Big in This?</a>.</p>

                </aside>

                <p>Toteutimme oikeastaan viime viikolla jo muutamia palveluita. Jatketaan nyt samalla teemalla.</p>

                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-huoneistot">
                                    Huoneistot
                                </a>
                            </h1>
                        </header>
                        <div id="t-huoneistot" class="collapse">

                            <p>Toteuta Spring Data RESTin avulla REST-rajapinta huoneistojen hallintaan.</p>

                            <p>Jokaisella huoneistolla tulee olla uniikki nimi (<code>name</code>), joka ei saa olla tyhjä. Huoneistojen lisäys tapahtuu tekemällä JSON-muotoinen POST-pyyntö osoitteeseen <code>/api/apartments</code> (esim. <code>{"name":"The Cupboard Under the Stairs"}</code>). Vastaavasti <code>GET</code>-pyyntö osoitteeseen <code>/api/apartments</code> palauttaa <code>HAL</code>-spesifikaatiota seuraavan JSON-vastauksen, missä huoneet on listattu.</p>

                            <p>yksittäisen huoneiston haku ja poisto tapahtuu osoitteessa <code>/api/apartments/{id}</code>, missä <code>id</code> on huoneiston uniikki tunnus.</p>

                            <p>Käytä huoneiston tunnuksena (<code>id</code>) <code>Long</code>-tyyppistä muuttujaa.</p>

                        </div>
                    </div>

                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-henkilot">
                                    Henkilöt
                                </a>
                            </h1>
                        </header>
                        <div id="t-henkilot" class="collapse">

                            <p>Toteutetaan sovellus henkilöiden luomiseen.</p>

                            <h1>Rajapinta</h1>

                            <p>Toteuta Spring Data RESTin avulla REST-rajapinta henkilöiden hallintaan.</p>

                            <p>Jokaisella henkilöllä tulee olla uniikki nimi (<code>name</code>), uniikki käyttäjätunnus (<code>username</code>) sekä uniikki salasana (<code>password</code>), joista yksikään ei saa olla tyhjä.</p>

                            <p>Henkilöiden lisäys tapahtuu tekemällä JSON-muotoinen POST-pyyntö osoitteeseen <code>/api/persons</code> (esim. <code>{"name":"Harry Potter", "username":"hedwig", "password":"nimbus2000"}</code>).</p>

                            <p>Vastaavasti <code>GET</code>-pyyntö osoitteeseen <code>/api/persons</code> palauttaa <code>HAL</code>-spesifikaatiota seuraavan JSON-vastauksen, missä henkilöt on listattu.</p>

                            <p>Yksittäinen henkilö voidaan hakea tunnuksen perusteella osoitteesta <code>/api/persons/{id}</code>, missä <code>id</code> on henkilön uniikki tunnus. Poistamisen ei kuitenkaan tule onnistua.</p>

                            <p>Käytä henkilön tunnuksena (<code>id</code>) <code>Long</code>-tyyppistä muuttujaa.</p>

                            <p><strong>Huom!</strong> Toteuta toiminnallisuus siten, että GET-pyynnön yhteydessä henkilön salasanaa ei palauteta. Vastauksen tulee siis sisältää aina vain nimi ja käyttäjätunnus. Etsi apua Googlesta, avainsanoja ovat ainakin <code>@JsonProperty</code>, <code>@JsonIgnore</code> sekä esimerkiksi haku "json ignore property on deserialization but allow on serialization".</p> 


                            <h1>Tunnistautuminen</h1>

                            <p>Lisää sovellukseen rajapinta <code>/authenticate</code>, jonka avulla voidaan tarkistaa löytyykö käyttäjärekisteristä sopiva käyttäjätunnus-salasana -pari. Rajapinnalle voidaan tehdä <code>POST</code>-tyyppinen pyyntö JSON-muodossa. JSON-data sisältää käyttäjätunnus-salasana -parin (<code>{"username":"tunnus","password":"jackbauer"}</code>). Jos tietokannasta löytyy käyttäjä annetulla käyttäjätunnuksella ja salasanalla, metodin tulee palauttaa statuskoodi <code>200</code> eli "OK", sekä käyttäjän nimi vastauksen rungossa. Jos käyttäjää ei löydy, palautettavan arvon tulee olla <code>401</code> eli "Unauthorized".</p>

                            <p>Toteuta vastaus siten että autentikointiin käytettävä kontrollerimetodi palauttaa <code><a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/http/ResponseEntity.html" target="_blank">ResponseEntity</a></code>-olion. ResponseEntitylle voi määritellä vastauksen statuskoodin sekä rungon. Alla oleva ResponseEntity-olion runko sisältää merkkijonon <code>"jack bauer"</code> ja palauttaa statuskoodin <code>200</code> eli "OK".</p>

                            <pre class="sh_java">
ResponseEntity&lt;String&gt; vastaus = new ResponseEntity&lt;&gt;("jack bauer", HttpStatus.OK);</pre>

                        </div>
                    </div>

                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-varauspalvelu">
                                    Varauspalvelu
                                </a>
                            </h1>
                        </header>
                        <div id="t-varauspalvelu" class="collapse">

                            <p>Jatkokehitetään sovellusta huoneistojen varaamiseen ja varaustilanteen tarkasteluun. Käytössäsi on huoneistojen käsittelyyn tarvittava rajapinta, jonka palveluntarjoaja on toteuttanut sinua varten. Rajapintaa käytetään <code>ApartmentService</code>-luokan avulla, joka löytyy pakkauksesta <code>wad.ext.apartments</code>.</p>

                            <p>Voit käyttää Huoneistot tehtävän vastausta osana tätä tehtävää:</p>

                            <ol>
                                <li>Paketoi tehtävä Huoneistot komennolla <code>mvn clean package</code></li>
                                <li>Käynnistä huoneistot-sovellus komennolla <code>java -Dserver.port=12345 -jar target/Huoneistot-1.0-SNAPSHOT.jar</code></li>
                                <li>Tämä käynnistää Huoneistot sovelluksen paikallisen koneesi porttiin 12345 -- sovellus siis osoitteessa <code>http://localhost:12345</code> ja sen tarjoamaa rajapintaa voi hyödyntää osoitteesta <code>http://localhost:12345/api</code>.</li>
                            </ol>

                            <h1>Rajapinnan rajoittaminen</h1>

                            <p>Tällä hetkellä sovelluksen tarjoama polussa <code>/api/reservations</code> oleva rajapinta mahdollistaa uusien varausten tekemisen sekä varausten poistamisen. Muokkaa rajapintaa siten, että sen kautta voi vain hakea tämänhetkisen varaustilanteen, mutta ei voi tehdä muutoksia siihen.</p>

                            <h1>Varaustilanteen näyttäminen</h1>

                            <p>Lisää sovellukseen kontrolleri, joka kuuntelee osoitteeseen <code>/reservations</code>-tehtäviä pyyntöjä. Kun osoitteeseen tehdään GET-tyyppinen pyyntö, tulee pyynnön modeliin lisätä sekä kaikki olemassaolevat varaukset että kaikki asunnot.</p>

                            <p>Lisää asunnot modeliin parametrin nimellä "apartments" -- huoneistoihin pääset käsiksi <code>ApartmentService</code>-toteutuksen avulla. Varausten tulee olla modelissa parametrilla "reservations". Näytä käyttäjälle polussa <code>/src/main/resources/templates/reservations.html</code> olevasta näkymästä luotu sivu.</p>

                            <p>Tämän lisäksi, kun osoitteeseen <code>/reservations</code> tehdään POST-pyyntö, missä on varauksen tiedot, varaus tulee tallentaa tietokantaan. POST-pyynnön mukana tulee muuttujat <code>reservationStart</code>, <code>reservationEnd</code> sekä <code>apartmentId</code> -- voit todennäköisesti hyödyntää luokkaa <code>Reservation</code> tässä. Kun otat pyynnön vastaan, lisää varaukseen varattavan huoneiston nimi -- voit hakea yksittäisen huoneiston tiedot huoneiston tunnuksen perusteella <code>ApartmentService</code>-palvelusta. Muistathan että POST-pyynnön jälkeen pyyntö tulee aina uudelleenohjata.</p>

                            <p>Huom! Lisää kontrollerille lisäksi <code>@PostConstruct</code>-annotaatiolla merkitty metodi, joka suoritetaan kun kontrolleri on ladattu. Aseta siinä <code>ApartmentService</code>-palvelulle osoite -- käytä aiempaa huoneistotehtävän vastausta testaukseen.</p>

                            <h1>Päällekkäisten varausten esto</h1>

                            <p>Muokkaa varaustoiminnallisuutta siten, että päällekkäisten varausten tekeminen ei onnistu. Samaa huoneistoa ei siis tule voida varata kahdesti samalle aikajaksolle tai osittain päällekkäiselle aikajaksolle.</p>


                            <h1>Maksutoiminnallisuus</h1>

                            <p>Jokaiseen varaukseen liittyy muuttuja <code>paymentStatus</code>, joka asetetaan varauksen luonnin yhteydessä <code>"UNPAID"</code>-tilaan, eli maksamattomaksi. Lisää sovellukseen toiminto, joka muuttaa varauksen maksutilaksi <code>"PAID"</code>. Tilan tulee muuttua jos osoitteeseen <code>/reservations/{id}/payment</code> tehdään POST-tyyppinen pyyntö -- tässä <code>id</code> on varauksen uniikki tunnus (<code>id</code>).</p>

                            <p>Nyt varausten maksu voitaisiin periaatteessa hoitaa erillisessä palvelussa, joka päivittäisi varauksen tilan maksun yhteydessä.</p>

                        </div>
                    </div>
                </div>


                <aside class="extra">

                    <h1>Lisää aiheesta</h1>

                    <p>Tutustu Microsoftin <a href="http://msdn.microsoft.com/en-us/library/bb833022.aspx" target="_blank">SOA-johdatukseen</a>.</p>

                </aside>


                <h1>Sovellusten testaaminen ja tuotantoon siirtäminen</h1>


                <p>Kun sovellus julkaistaan, seuraaviin asioihin kannattaa kiinnittää huomiota. </p>


                <ol>

                    <li>Palvelun (esimerkiksi käyttöliittymä, REST-API) tulee olla käyttäjien löydettävissä.</li>

                    <li>Palvelun rajapinnan (esimerkiksi käyttöliittymä, REST-API) käyttämiseen tulee olla tarjolla tukea tarvittaessa.</li>

                    <li>Palvelun tilaa tulee pystyä seuraamaan. Jos palvelu on päällä mutta siihen ei pääse käsiksi, se on turha. Palvelu on myös turha jos se on päällä, mutta joku sen sisältämä osakomponentti on rikki ja pyynnöt eivät suoritu toivotusti.</li>

                    <li>Kaikkien rajapintojen tulee olla testattu ja niiden kehityksen tulee tapahtua erillisenä tuotantopalvelusta, jolloin uusia toiminnallisuuksia voidaan testata erillään.</li>

                    <li>Palvelun tulee pystyä kestämään suuria määriä liikennettä sekä suojautumaan vihamielisiltä ohjelmistoilta ja käyttäjiltä.</li>

                </ol>

                <p>Tutustutaan tässä kappaleessa lähinnä neljänteen kohtaan.</p>


                <h2>Sovelluksen testaaminen</h2>


                <p>Kuten ohjelmistotuotannossa yleensä, myös palvelinohjelmistoja rakennettaessa testaaminen hyödyntää sekä ohjelmiston kehitystä että sen ylläpitoa. Testaaminen voidaan karkeasti jakaa kolmeen osaan: yksikkötestaukseen, integraatiotestaukseen ja järjestelmätestaukseen. Yksikkötestauksessa testataan sovellukseen kuuluvia pienimpiä yksittäisiä komponentteja ja varmistetaan että niiden tarjoamat rajapinnat toimivat tarkoitetulla tavalla. Integraatiotestauksessa testataan että komponentit toimivat yhdessä kuten niiden pitäisi, ja järjestelmätestauksessa varmistetaan, että järjestelmä toimii vaatimusten mukaan järjestelmän käyttäjille tarjotun rajapinnan (esim. selain tai REST-api) kautta.</p>


                <h3>Yksikkötestaus</h3>


                <p>Yksikkötestauksella tarkoitetaan lähdekoodiin kuuluvien yksittäisten osien testausta. Termi yksikkö viittaa ohjelman pienimpiin mahdollisiin testattaviin toiminnallisuuksiin, kuten olion tarjoamiin metodeihin. Seuratessamme <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle" target="_blank">single responsibility principle</a>ä, jokaisella oliolla ja metodilla on yksi selkeä vastuu, jota voi myös testata. Testaus tapahtuu yleensä testausohjelmistokehyksen avulla, jolloin luodut testit voidaan suorittaa automaattisesti. Yleisin Javalla käytettävä testauskehys on JUnit, jonka saa käyttöön lisäämällä siihen liittyvän riippuvuuden <code>pom.xml</code>-tiedostoon.</p>

                <pre class="sh_xml">
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;</pre>

                <p>Yksittäisen riippuvuuden määre <code>scope</code> kertoo milloin riippuvuutta tarvitaan. Määrittelemällä <code>scope</code>-elementin arvoksi <code>test</code> on riippuvuudet käytössä vain testejä ajettaessa. Uusia testiluokkia voi luoda NetBeansissa valitsemalla New -> Other -> JUnit -> JUnit Test. Tämän jälkeen NetBeans kysyy testiluokalle nimeä ja pakkausta. Huomaa että lähdekoodit ja testikoodit päätyvät erillisiin kansioihin -- juurin näin sen pitääkin olla. Kun testiluokka on luotu, on projektin rakenne kutakuinkin seuraavanlainen.</p>

                <pre>
.
|-- pom.xml
`-- src
    |-- main
    |   |-- java
    |   |   `-- wad
    |   |       `-- ... oman projektin koodit
    |   |-- resources
    |   |       `-- ... resurssit, mm. konfiguraatio ja thymeleafin templatet
    |   `-- webapp
    |           
    `-- test
        `-- java
            `-- wad
                `-- ... testikoodit!
                </pre>

                <p>Tehtäväpohjissa JUnit-testikirjasto on valmiina mukana. Yksikkötestauksesta JUnit-kirjaston avulla löytyy pieni opas kurssin <a href="https://github.com/mluukkai/OTM2013/wiki/Ohje-JUnit:in-k%C3%A4ytt%C3%B6%C3%B6n" target="_blank">Ohjelmistotekniikan menetelmät</a> sivuilta.</p>


                <h3>Integraatiotestaus</h3>

                <p>Spring tarjoaa <code>spring-test</code>-komponentin, jonka avulla JUnit-kirjasto saa @Autowired-annotaatiot toimimaan. Tämän kautta pääsemme tilanteeseen, missä voimme injektoida testimetodille esimerkiksi kokonaisen palvelun, sekä testata sen tarjoamien metodien toimintaa. Testattava palvelu voi hyödyntää muita komponentteja, jolloin testauksen kohteena on kokonaisuuden toiminta yhdessä.</p>

                <p>Spring test-komponentista on myös Spring Boot -projekti, jonka voimme ottaa käyttöömme lisäämällä seuraavan riippuvuuden pom.xml-tiedostoon. Käytetyn riippuvuuden versio liittyy Spring Boot -projektin versioon, eikä sitä tarvitse määritellä tarkemmin.</p>

                <pre class="sh_xml">
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;</pre>


                <p>Yksittäisten palvelujen testaamisessa tarvitsemme testiluokkien alkuun kaksi annotaatiota. Annotaatio <code>@RunWith(SpringJUnit4ClassRunner.class)</code> kertoo että käytämme Springiä yksikkötestien ajamiseen ja annotaatiolle <code>@SpringApplicationConfiguration</code> annetaan konfiguraation sijainti -- tässä <code>Application.class</code>, mikä tehtäväpohjissa on tyypillisestä pakkauksessa <code>wad</code>. Testiluokka, johon injektoidaan automaattisesti <code>MyService</code>-palvelu, näyttää seuraavalta.</p>


                <pre class="sh_java">
@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = Application.class)
public class ApplicationTest {

    @Autowired
    private MyService myService;

    // ... testit jne
}</pre>

                <p>Käynnistämällä Springin osana testejä, saamme käyttöömme oliokontekstin, jonka avulla voimme asettaa testattavat oliot testiluokkiin testaamista varten. Testattavien olioiden riippuvuudet asetetaan myös automaattisesti, eli jos <code>MyService</code> sisältää muita komponentteja, on ne myös automaattisesti asetettu.</p>

                <p>Voimme ylläolevalla lähestymistavalla testata myös sitä, että sovelluksemme eri osat toimivat yhteen toivotusti. Oletetaan, että käytössämme on luokka <code>PersonService</code>, joka tarjoaa metodin <code>save</code>, jonka pitäisi tallentaa parametrina annettava <code>Person</code>-olio tietokantaan. Tämän lisäksi käytössämme on <code>PersonRepository</code>, jolla on metodi <code>findByName</code>, minkä avulla voimme hakea tietokannasta henkilön sen nimen perusteella. Kummatkin toteutukset voidaan injektoida suoraan testiluokkaan, testi itsessään ensin tallentaa henkilön <code>PersonService</code>-olion avulla, ja tarkistaa sen jälkeen <code>PersonRepository</code>-oliolta että kyseinen henkilö on olemassa.</p>


                <pre class="sh_java">
// importit

@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = Application.class)
public class ApplicationTest {

    @Autowired
    private PersonService personService;

    @Autowired
    private PersonRepository personRepository;

    @Test
    public void testSavePerson() {
        Person person = new Person();
        person.setName("Jack Bauer");
        person.setAge(42);

        personService.save(person);

        Person retrieved = personService.findByName("Jack Bauer");
        assertNotNull(retrieved);
        assertEquals(42, retrieved.getAge());
    }

    // ja muita testejä
}</pre>

                <p>Ylläolevassa testissä olevat metodit <code>assertNotNull</code> ja <code>assertEquals</code> ovat JUnit-kirjaston tarjoamia toiminnallisuuksia.</p>


                <h3>Järjestelmätestaus</h3>

                <p>Järjestelmätestauksessa on tarkoitus varmistaa, että järjestelmä toimii toivotulla tavalla. Järjestelmää testataan saman rajapinnan kautta, kuin mitä sen loppukäyttäjät käyttävät. Järjestelmätestaukseen on monenlaisia työkaluja, joista käsittelemme tässä kahta. Tutustumme ensin integraatiotestauksessa käytetyn <code>spring-test</code>-komponenttiin järjestelmätason testaustoiminnallisuuteen, jonka jälkeen tutustumme harjoitustehtävän kautta <code>Selenium</code> ja <code>FluentLenium</code> -kirjastoihin.</p>

                <p>Springin tarjoama <code>spring-test</code> tarjoaa tuen järjestelmätestaamiseen. Lisäämällä testiluokkiin annotaatio <code>@WebAppConfiguration</code> testeillä on käytössä myös web-sovelluksen konteksti, jonka avulla voidaan luoda <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/test/web/servlet/MockMvc.html" target="_blank">MockMvc</a>-olio. MockMvc-oliolla pystymme tekemään pyyntöjä sovelluksen tarjoamiin osoitteisiin, tarkistelemaan pyyntöjen onnistumista, sekä tarkastelemaan vastauksena saatua dataa.</p>

                <p>Alla oleva esimerkki käynnistää sovelluksen ja tekee kolme GET-pyyntöä osoitteeseen <code>/messages</code>. Ensimmäinen pyyntö liittyy testiin, missä varmistetaan että vastaus on sisältää statuskoodin <code>200</code> eli "OK", toinen pyyntö liittyy testiin joka varmistaa että vastauksen tyyppi on JSON-muotoista dataa, ja kolmas pyyntö tarkistaa että vastauksessa on merkkijono "Awesome". Alun <code>setUp</code>-metodi luo <code>MockMvc</code>-olion injektoidun palveinkontekstin perusteella.</p>

                 <pre class="sh_java">
// muut importit

// mm. mockMvc:n get- ja post-metodit
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = Application.class)
@WebAppConfiguration
public class MessagesTest {

    private final String API_URI = "/messages";

    @Autowired
    private WebApplicationContext webAppContext;

    private MockMvc mockMvc;

    @Before
    public void setUp() {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(webAppContext).build();
    }

    @Test
    public void statusOk() throws Exception {
        mockMvc.perform(get(API_URI))
                .andExpect(status().isOk());
    }


    @Test
    public void responseTypeApplicationJson() throws Exception {
        mockMvc.perform(get(API_URI))
                .andExpect(status().isOk())
                .andExpect(content().contentType(MediaType.APPLICATION_JSON));
    }

    @Test
    public void responseContainsTextAwesome() throws Exception {
        MvcResult res = mockMvc.perform(get(API_URI))
                .andExpect(status().isOk())
                .andExpect(content().contentType(MediaType.APPLICATION_JSON))
                .andReturn();

        String content = res.getResponse().getContentAsString();
        Assert.assertTrue(content.contains("Awesome"));
    }
}</pre>

                <p>Voit myös testata modeliin asetettujen attribuuttien olemassaoloa ja oikeellisuutta. Olemassaolon voi tarkistaa <code>model()</code>-metodin kautta, ja <code>MvcResult</code>-olion kautta pääsee käsiksi modelin sisältöön.</p>

                <pre class="sh_java">
    @Test
    public void modelHasAttribute() throws Exception {
        mockMvc.perform(get(API_URI))
                .andExpect(status().isOk())
                .andExpect(model().attributeExists("messages"));
    }

    @Test
    public void modelHasAttribute() throws Exception {
        MvcResult res = mockMvc.perform(get(API_URI))
                .andExpect(status().isOk())
                .andExpect(model().attributeExists("messages"))
                .andReturn();

        // oletetaan, että kontrolleri asettaa listan Message-tyyppisiä olioita
        // modeliin

        List&lt;Message&gt; messages = (List) res.getModelAndView().getModel().get("messages");

        // tarkista lista
    }
                </pre>        


                <p>MockMvc:n avulla voi testata käytännössä suurinta osaa palvelinsovellusten toiminnallisuudesta, mutta samalla se tarjoaa pääsyn samaan rajapintaan kuin mitä selain käsitteelee.</p>



                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-lentokentatredux">
                                    Lentokentät Redux
                                </a>
                            </h1>
                        </header>
                        <div id="t-lentokentatredux" class="collapse">

                            <p>Muistamme viikolta 2 tehtävän, missä tehtiin sovellus lentokoneiden ja lentokenttien hallintaan. Tässä tehtävässä harjoitellaan hieman sekä integraatio- että järjestelmätestausta.</p>

			    <p>Huom! Tässä tehtävässä ei ole automaattisia testejä, joilla testattaisiin kirjoittamiasi testejä. Palauttaessasi tehtävän olet tarkistanut, että kirjoittamasi testit toimivat kuten tehtävänannossa on kuvattu.</p>

                            <h1>AirportServiceTest</h1>

                            <p>Sovellusessa on luokka <code>AirportService</code>, mikä sijaitsee pakkauksessa <code>wad.service</code>. Sille ei kuitenkaan ole yhtäkään testiä :(</p>

                            <p>Lisää testikansioon (<code>Test Packages</code>) pakkaus <code>wad.service</code>, ja luo sinne luokka <code>AirportServiceTest</code>.</p>

                            <p>Lisää luokalle tarvittavat annotaatiot sekä oliomuuttujat, ja toteuta luokalle testimetodit, joiden avulla testataan että haluttu lentokone todellakin lisätään lentokentälle. Haluat ainakin tietää että:</p>

                            <ul>
                                <li>Kun lentokone on lisätty lentokentälle, tietokannasta samalla tunnuksella haettavalla lentokoneella on asetettu lentokenttä, ja se on juuri se lentokenttä mihin kone on lisätty.</li>
                                <li>Kun lentokone on lisätty lentokentälle, lentokentältä löytyy myös kyseinen kone.</li>
                                <li>Kun lentokone on lisätty yhdelle lentokentälle, se ei ole muilla lentokentillä.</li>
                                <li>Lentokoneen lisääminen samalle lentokentälle useasti ei johda siihen, että lentokenttä sisältää saman koneen monta kertaa.</li>
                            </ul>

                            <p>Aina kun lisäät yksittäisen testin, voit ajaa testit klikkaamalla projektia oikealla hiirennapilla ja valitsemalla "Test".</p>                        


                            <h1>AircraftControllerTest</h1>

                            <p>Luo testikansioon pakkaus <code>wad.controller</code> ja lisää sinne luokka <code>AircraftControllerTest</code>. Lisää luokkaan tarvittavat määrittelyt, jotta voit käyttää <code>MockMvc</code>-komponenttia testeissä.</p>

                            <p>Tee seuraavat testit:</p>

                            <ul>
                                <li>Kun osoitteeseen <code>/aircrafts</code> tehdään GET-pyyntö, vastauksen status on 200 (ok) ja vastauksen model-oliossa on parametrit <code>aircrafts</code> ja <code>airports</code>.</li>
                                <li>Kun osoitteeseen <code>/aircrafts</code> tehdään POST-pyyntö, jonka parametriksi annetaan <code>name</code>-kenttä, jonka arvona on "HA-LOL", pyynnön vastaukseksi tulee uudelleenohjaus. Tee tämän jälkeen erillinen kysely tietokantaan esim. <code>AircraftRepository</code>:n avulla, ja varmista, että tietokannasta löytyy lentokone, jonka nimi on <code>HA-LOL</code>.</li>
                                <li>Kun osoitteeseen <code>/aircrafts</code> tehdään POST-pyyntö, jonka parametriksi annetaan <code>name</code>-kenttä, jonka arvona on "XP-55", pyynnön vastaukseksi tulee uudelleenohjaus. Tee tämän jälkeen GET-pyyntö osoitteeseen <code>/aircrafts</code>, ja tarkista että pyynnön vastauksena saatavan <code>model</code>-olion sisältämässä <code>"aircrafts"</code>-listassa on juuri luotu lentokone.</li>
                            </ul>

                            <p>Tässäkin tehtävässä, aina kun lisäät yksittäisen testin, voit ajaa testit klikkaamalla projektia oikealla hiirennapilla ja valitsemalla "Test".</p>                        
                        </div>
                    </div>
                </div>


                <p>Riippuen käytetystä käyttöliittymäkirjastosta, käyttöliittymä saatetaan luoda Spring-sovelluskehyksen ulkopuolella. Esimerkiksi <a href="https://en.wikipedia.org/wiki/JavaServer_Pages" target="_blank">JSP</a>-sivut luodaan käytetyllä palvelimella (esim Tomcat tai Jetty), eli ne ovat erillinen osa Spring-sovelluksesta.</p>


                <p>MockMvc:n lisäksi järjestelmätestaukseen käytetään melko paljon <a href="http://www.seleniumhq.org/" target="_blank">Selenium</a>ia ja siihen liittyviä lisäosia kuten <a href="https://github.com/FluentLenium/FluentLenium" target="_blank">FluentLenium</a>, jotka tarjoavat välineitä selaintoiminnallisuuden automatisointiin. Käytännössä edellämainitut ovat on web-selaimen toimintojen automatisointiin tarkoitettuja välineitä, jotka antavat sovelluskehittäjälle mahdollisuuden käydä läpi sovelluksen käyttöliittymää ohjelmallisesti.</p>

		<p>Lisätään FluentLenium-kirjaston vaatimat riippuvuudet, oletetaan että testit kirjoitetaan JUnit-testikirjaston avulla (FluentLenium tarjoaa myös muita vaihtoehtoja).</p>

                <pre class="sh_xml">
        &lt;dependency&gt;
            &lt;groupId&gt;org.fluentlenium&lt;/groupId&gt;
            &lt;artifactId&gt;fluentlenium-core&lt;/artifactId&gt;
            &lt;version&gt;0.10.3&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;xml-apis&lt;/groupId&gt;
            &lt;artifactId&gt;xml-apis&lt;/artifactId&gt;
            &lt;version&gt;1.4.01&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;</pre>


		<p><strong><em>FluentLenium testien kirjoittaminen</em></strong></p>


                <p>Ajatellaan loppukäyttäjän haluamaa toiminnallisuutta "Käyttäjä voi ilmoittautua oppitunnille". Järjestelmä tarjoaa sivun, jonka ensimmäinen linkki vie ilmoittautumissivulle. Ilmoittautumissivulla tulee olla tietty otsikko -- varmistamme, että olemme oikealla sivulla. Tämän lisäksi ilmoiuttautumissivulla on lomakekenttä, jonka <em>id</em> on "name" -- jos kentällä on <em>id</em>, voidaan se valita kirjoittamalla "#kentannimi". Täytetään kenttään arvo "Bob" ja lähetetään lomake. Tämän jälkeen sivulla tulee olla teksti "Ilmoittautuminen onnistui!".</p>


                <pre class="sh_java">
// importit

@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = Application.class)
@WebAppConfiguration
@IntegrationTest("server.port:0")
public class ElokuvatietokantaTest extends FluentTest {

    @Value("${local.server.port}")
    private int serverPort;
    private WebDriver webDriver = new HtmlUnitDriver();

    private String getUrl() {
        return "http://localhost:" + serverPort;
    }

    @Override
    public WebDriver getDefaultDriver() {
        return webDriver;
    }

    @Test
    public void canSignUp() {
        goTo(getUrl());

        click(find("a").first());
        assertEquals("Ilmoittautuminen", title());

        fill(find("#name")).with("Bob");
        submit(find("form").first());

        assertTrue(pageSource().contains("Ilmoittautuminen onnistui!"));
    }
// ...
                </pre>


                <p>Yllä annotaatio <code>@IntegrationTest("server.port:0")</code> käynnistää palvelimen integraatiotestausta satunnaisessa portissa, joka saadaan muuttujaan <code>serverPort</code> annotaation <code>@Value("${local.server.port}")</code> avulla. Luomma tämän lisäksi ajurin näkymien läpikäyntiin (rivi <code>private WebDriver webDriver = new HtmlUnitDriver();</code>, joka tarjotaan oman testiluokkamme peritylle toiminnallisuudelle (<code>FluentTest</code>) metodin <code>getDefaultDriver()</code> kautta.</p>

		<p>Yllä menemme ensin paikalliseen osoitteeseen <code>http://localhost:<em>portti</em></code>, missä portin numero on satunnaisesti valittu -- surffaamme siis haluttuun osoitteeseen. Haemme tämän jälkeen ensimmäisen linkin, eli <code>a</code>-elementin sivulta, ja klikkaamme sitä. Tämän jälkeen tarkistamme, että sivun otsake on <code>Ilmoittautuminen</code>. Tätä seuraa kentän, jonka id on "name" täyttäminen "Bob"-merkkijonolla, jonka jälkeen lomake lähetetään. Kun lomake on lähetetty, haetaan sivun lähdekoodista tekstiä "Ilmoittautuminen onnistui!". Jos tekstiä ei löydy, testi epäonnistuu.</p>

		<p>FluentLenium-kirjastoon liittyvää dokumentaatiota löytyy osoitteesta <a href="http://www.fluentlenium.org/" target="_blank">http://www.fluentlenium.org/</a>, jonka lisäksi googlesta löytyy apua seuraavaan tehtävään.</p>

                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-elokuvatredux">
                                    Elokuvat Redux
                                </a>
                            </h1>
                        </header>
                        <div id="t-elokuvatredux" class="collapse">

                            <p>Muistamme viikolta 2 myös tehtävän, missä tehtiin sovellus elokuvien ja näyttelijöiden hallintaan. Tässä tehtävässä harjoitellaan hieman järjestelmätestausta FluentLeniumin avulla. Tehtävässä ei ole automaattisia testejä, sillä sinun tehtävänä on toteuttaa ne.</p>

                            <h1>Näyttelijän lisääminen ja poistaminen</h1>

                            <p>Luo testikansioon <code>wad.selenium</code> testiluokka <code>ActorTest</code>, johon asetat Selenium-testaamiseen tarvittavat komponentit.</p>

                            <p>Toteuta testi, jolla varmistetaan että käyttäjän lisääminen ja poistaminen onnistuu. Testin tulee toimia seuraavasti:</p>

                            <ol>
                                <li>Menee näyttelijäsivulle</li>
                                <li>Tarkistaa ettei sivulla ole tekstiä "Van Damme"</li>
                                <li>Etsii kentän jonka id on "name", asettaa kenttään tekstin "Van Damme", ja lähettää lomakkeeseen liittyvän lomakkeen.</li>
                                <li>Tarkistaa että sivulla on teksti "Van Damme"</li>
                                <li>Klikkaa "Van Damme"en liittyvää poista-nappia </li>
                                <li>Tarkistaa että sivulla ei ole tekstiä "Van Damme"</li>
                            </ol>

                            <p>Toteuta seuraavaksi testi, joka tekee seuraavat askeleet:</p>

                            <ol>
                                <li>Menee näyttelijäsivulle</li>
                                <li>Tarkistaa ettei sivulla ole tekstiä "Van Damme"</li>
                                <li>Tarkistaa ettei sivulla ole tekstiä "Chuck Norris"</li>
                                <li>Etsii kentän jonka id on "name", asettaa kenttään tekstin "Chuck Norris", ja lähettää lomakkeeseen liittyvän lomakkeen.</li>
                                <li>Tarkistaa ettei sivulla ole tekstiä "Van Damme"</li>
                                <li>Tarkistaa että sivulla on teksti "Chuck Norris"</li>
                                <li>Etsii kentän jonka id on "name", asettaa kenttään tekstin "Van Damme", ja lähettää lomakkeeseen liittyvän lomakkeen.</li>
                                <li>Tarkistaa että sivulla on teksti "Van Damme"</li>
                                <li>Tarkistaa että sivulla on teksti "Chuck Norris"</li>
                                <li>Klikkaa "Van Damme"en liittyvää poista-nappia</li>
                                <li>Klikkaa henkilön "Chuck Norris" poista-nappia</li>
                                <li>Tarkistaa ettei sivulla ole tekstiä "Van Damme"</li>
                                <li>Tarkistaa että sivulla on teksti "Chuck Norris"</li>
                            </ol>


                            <h1>Elokuvan lisääminen ja näyttelijän lisääminen elokuvaan</h1>

                            <p>Luo testikansioon <code>wad.selenium</code> testiluokka <code>MovieTest</code>, johon asetat Selenium-testaamiseen tarvittavat komponentit.</p>

                            <p>Toteuta seuraavat askeleet</p>

                            <ol>
                                <li>Mene elokuvasivulle</li>
                                <li>Tarkista että sivulla ei ole tekstiä "Bloodsport"</li>
                                <li>Tarkista että sivulla ei ole tekstiä "Van Damme"</li>
                                <li>Etsi kenttä jonka id on "name" ja lisää siihen arvo "Bloodsport"</li>
                                <li>Etsi kenttä jonka id on "lengthInMinutes" ja lisää siihen arvo "92"</li>
                                <li>Lähetä kenttään liittyvä lomake</li>

                                <li>Tarkista että sivulla on teksti "Bloodsport"</li>
                                <li>Tarkista että sivulla ei ole tekstiä "Van Damme"</li>

                                <li>Mene näyttelijäsivulle</li>
                                <li>Tarkista ettei sivulla ole tekstiä "Van Damme"</li>
                                <li>Etsi kenttä jonka id on "name", aseta kenttään teksti "Van Damme", ja lähetä lomake.</li>
                                <li>Tarkistaa että sivulla on teksti "Van Damme"</li>
                                <li>Etsi linkki, jossa on teksti "Van Damme" ja klikkaa siitä.</li>
                                <li>Etsi nappi, jonka id on "add-to-movie", ja klikkaa sitä.</li>

                                <li>Mene elokuvasivulle</li>

                                <li>Tarkista että sivulla on teksti "Bloodsport"</li>
                                <li>Tarkista että sivulla on teksti "Van Damme"</li>
                            </ol>

                            <p>Suorita taas testit klikkaamalla projektia oikealla hiirennäppäimellä ja valitsemalla <code>Test</code>.</p>
                        </div>
                    </div>
                </div>


                <h2>Kehitys, Integraatio, QA, Tuotanto</h2>


                <p>Kun sovelluksia kehitetään suuremmassa ryhmässä, sovellus sijaitsee useammassa paikassa.</p>

                <ol>
                    <li>Jokaisella ohjelmistokehittäjällä on oma <em>hiekkalaatikko</em>, jossa ohjelmistoon voi tehdä muutoksia vaikuttamatta muiden tekemään työhön. Jokaisella ohjelmistokehittäjällä on yleensä samat tai samankaltaiset työkalut (ohjelmointiympäristö, ...), mikä helpottaa muiden kehittäjien auttamista. Tyypillisesti ohjelmistokehittäjien päivittäiset tehtävät on jaettu pieniksi erillisiksi kokonaisuuksiksi ryhmän toimesta. Kun yksittäinen tehtävä on valmis, tehtävään liittyvä koodi sekä testit lisätään versionhallintapalvelimelle.</li>
                    <li><em>Versionhallintapalvelin</em> sisältää mahdollisesti useampia versioita projektista. Esimerkiksi git-mahdollistaa ns. branchien käyttämisen, jolloin uusia ominaisuuksia voidaan toteuttaa erillään "päähaarasta". Kun uusi ominaisuus on valmis, voidaan se lisätä päähaaraan. Versionhallinnassa olevia koodeja voidaan myös tägätä julkaisuversioiksi.</li>
                    <li>Versionhallintapalvelin on tyypillisesti kytketty <em>integraatiopalvelimeen</em>, jonka tehtävänä on yhdistää ohjelmistokehitystiimin lähdekoodit ja suorittaa niihin liittyvät testit jokaisen muutoksen yhteydessä. Integraatiopalvelin kuuntelee käytännössä versionhallintajärjestelmässä tapahtuvia muutoksia, ja hakee uusimman lähdekoodiversion muutoksen yhteydessä.</li>
                    <li><em>Staging</em>-palvelin on lähes identtinen ympäristö tuotantoympäristöön verrattuna. Staging (usein myös QA)-ympäristöön kopioidaan ajoittain tuotantoympäristön data, ja se toimii viimeisenä testaus- ja validointipaikkana (Quality assurance) ennen tuotantoon siirtoa. QA-ympäristöä käytetään myös demo- ja harjoitteluympäristönä. Kun QA-ympäristössä oleva sovellus on päätetty toimivaksi, siirretään sovellus tuotantoympäristöön.</li>
                    <li><em>Tuotantoympäristö</em> voi olla yksittäinen palvelin, tai se saattaa olla joukko palvelimia, joihin uusin muutos propagoidaan hiljalleen. Tuotantoympäristö on tyypillisesti erillään muista ympäristöistä mahdollisten virheiden minimoimiseksi.</li>
                </ol>

                <p>Riippuen ohjelmistotalosta ja käytetystä julkaisumallista, on mahdollista esimerkiksi että erillistä <code>Staging</code>-palvelinta ei ole käytössä.</p>


                <h3>Integraatiopalvelin ja Continuous Integration</h3>



                <p>Jatkuvassa integroinnissa (<em><a href="http://www.extremeprogramming.org/rules/integrateoften.html" target="_blank">Continuous integration</a></em>) jokainen ohjelmistoprojektin jäsen lisää päivittäiset muutoksensa olemassaolevaan kokonaisuuteen.</p>

                <p>Jatkuvaa integrointia seuraten ohjelmistokehittäjä hakee kehityksen alla olevan version versionhallinnasta aloittaessaan työn. Hän toteuttaa uuden pienen ominaisuuden testeineen, testaten uutta toiminnallisuutta jatkuvasti. Kun ohjelmistokehittäjä on saanut muutoksen tehtyä, ja kaikki testit menevät läpi hänen paikallisella työasemalla, hän lähettää muutokset versionhallintaan. Kun versionhallintaan tulee muutos, jatkuvaa integrointia suorittava työkalu hakee uusimman version ja suorittaa sille sekä yksikkö- että integraatiotestit.</p>

                <p>Testejä sekä paikallisella kehityskoneella että erillisellä integraatiokoneella ajettaessa ohjelmistotiimi mahdollisesti huomaa virheet, jotka ovat piilossa kehittäjän paikallisen konfiguraation johdosta. Kehittäjä ei aina ota koko ohjelmistoa omalle koneelleen -- ohjelmisto voi koostua useista komponenteista --  jolloin kaikkien vaikutusten testaaminen paikallisesti on mahdotonta. Jos testit eivät mene läpi integraatiokoneella, korjataan muutokset mahdollisimman nopeasti.</p>

                <p>Työkaluja automaattiseen kääntämiseen ja jatkuvaan integrointiin ovat esimerkiksi <a href="https://travis-ci.org" target="_blank">Travis</a> ja <a href="https://coveralls.io" target="_blank">Coveralls</a>. Travis varmistaa että viimeisin lähdekoodiversio kääntyy ja että testit menevät läpi, ja Coveralls tarjoaa välineitä testikattavuuden ja projektin historian tarkasteluun -- tässä hyödyksi on esimerkiksi <a href="https://github.com/cobertura/cobertura" target="_blank">Cobertura</a>. Kummatkin ovat ilmaisia käyttää kun projektin lähdekoodi on avointa -- kumpikin tarjoaa myös suoran Github-tuen.</p>

                <p>Travisin käyttöönottoon vaaditaan käytännössä se, että projekti on esimerkiksi Githubissa ja että sen juurikansiossa on travisin konfiguraatiotiedosto <code>travis.yml</code>. Yksinkertaisimmillaan konfiguraatiotiedosto sisältää vain käytetyn ohjelmointikielen -- travis osaa esimerkiksi päätellä projektin tyypin <code>pom.xml</code>-tiedoston pohjalta.</p>

                <p>Näitä kumpaakin käytetään esimerkiksi <a href="https://github.com/kesapojat/tmc-snapshot-api" target="_blank">TMC Snapshot API</a>ssa, joka helpottaa ohjelmointiprosessin tutkimista.</p>


                <h2>Konfiguraatioprofiilit</h2>



                <p>Hyvin rakennetussa sovelluksessa ympäristön vaihtaminen ei vaadi muutoksia sovelluksen lähdekoodiin, vaan sovellusten ympäristöstä toiseen siirtäminen tapahtuu erilaisten profiilien avulla. Projekteissamme mukana olleet <code>wad.profiles</code>-pakkauksessa olleet luokat <code>DevProfile</code> ja <code>ProdProfile</code> sisältävät erilliset konfiguraatiot; ensimmäinen on kehityskäyttöön tarkoitettu ja hyödyntää vahvasti Spring Bootin oletusasetuksia, kun taas toinen ottaa käyttöön tietokannaksi PostgreSQL-kannan sovellukselle annettujen parametrien pohjalta. Esimerkiksi kun sovellus siirretään herokuun, se käyttää tuotantoprofiilia <code>"prod"</code>. Profiilin nimi määritellään profiilitiedoston alussa olevalla <code>@Profile</code>-annotaatiolla.</p>

                <p>Profiilikohtaisten asetusten muuttaminen onnistuu sekä lähdekoodista profiilitiedostoa (esim. <code>ProdProfile</code>) muokkaamalla, että esimerkiksi <code>application.properties</code>-tiedostoa muokkaamalla. Jos sovelluskehittäjä haluaa, että testiprofiililla (esim "test") on erillinen konfiguraatiotiedosto, sellaisen voi luoda. Spring etsii automaattisesti oletuskonfiguraation <code>application.properties</code> lisäksi myös profiilikohtaisia konfiguraatiotiedostoja (esim. <code>application-test.properties</code>, missä <code>test</code> on profiilin nimi.</p>

                <p>Konfiguraatiotiedostoihin voidaan asettaa myös ohjelmiston suorituksessa tarvittavaa tietoa. Esimerkiksi jos käyttäjä haluaa että sovelluksessa on erityistä tietoa, voidaan se määritellä muuttujaksi konfiguraatiotiedostoon. Alla olevassa esimerkissä konfiguraatiotiedostossa on muuttuja <code>wad.environment</code>, jolle on asetettu arvoksi <code>PRODUCTION</code>.</p>

                <pre>
wad.environment=PRODUCTION</pre>

                <p>Nyt kun sovellus käynnistetään siten, että ylläoleva konfiguraatio ladataan, on sovelluksessa käytössä konfiguraatioparametri, jonka voi injektoida suoraan sovellukseen <code>@Value</code>-annotaation avulla.</p>

                <pre class="sh_java">
// ..
@Controller
public class DefaultController {

    @Value("${wad.environment}")
    private String location;
// ...
                </pre>

                <p>Käytännössä profiilien hallinta kannattaa toteuttaa esimerkiksi niin, että eri ympäristöissä on käytössä erillinen ympäristömuuttuja, joka kertoo käytettävän profiilin. Springiä käytettäessä ympäristömuuttuja on <code>SPRING_PROFILES_ACTIVE</code> tai <code>spring.profiles.active</code>.</p>

                <p>Ympäristömuuttujan asetus tapahtuu *nix-koneilla <code>export</code>-komennolla.</p>

                <pre>
export SPRING_PROFILES_ACTIVE=production
                </pre>

                <p>Kun Springille on asetettu profiili, voidaan testiluokille määritellä myös käytettävä profiili annotaation <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/test/context/ActiveProfiles.html" target="_blank">ActiveProfiles</a> avulla. Alla olevassa esimerkissä testiluokan testit suoritetaan siten, että käytössä on profiiliin "dev" liittyvä konfiguraatio, eli se konfiguraatio, joka on määritelty annotaatiolla <code>@Profile("dev")</code> (tai <code>@Profile(values = {"dev", "muita"})</code> jos halutaan että samaa konfiguraatiota käytetään useammassa profiilissa.</p>

                <pre class="sh_java">
@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = Application.class)
@WebAppConfiguration
@ActiveProfiles("dev")
public class ApplicationTest {
    // ...
                </pre>



            </section>
            <!-- END WEEK4 -->





            <!-- BEGIN WEEK2 -->
<!--
            <section class="weeklimit" data-week-id="2">
                <header>
                    <h1 id="viikko2">Viikko 2</h1>
                </header>


            </section>
-->
            <!-- END WEEK2 -->

        </article>

        <footer>
            <p>
                <a id="license" rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.0/"><img alt="Creative Commons License" style="border-width:0; float:left; padding:15px" src="http://i.creativecommons.org/l/by-nc-sa/2.0/88x31.png" /></a>
                <small>T&auml;m&auml; materiaali on lisensoitu Creative Commons BY-NC-SA-lisenssill&auml;, joten voit k&auml;ytt&auml;&auml; ja levitt&auml;&auml; sit&auml; vapaasti, kunhan alkuper&auml;isten tekij&ouml;iden nimi&auml; ei poisteta. Jos teet muutoksia materiaaliin ja haluat levitt&auml;&auml; muunneltua versiota, se t&auml;ytyy lisensoida samanlaisella vapaalla lisenssill&auml;. Materiaalien k&auml;ytt&ouml; kaupalliseen tarkoitukseen on ilman erillist&auml; lupaa kielletty. Tekij&auml;(t): <a href="http://www.cs.helsinki.fi/en/people/avihavai" target="_blank">Arto Vihavainen</a> sekä <a href="http://www.cs.helsinki.fi/en/rage" target="_blank">Agile Education Research</a> -tutkimusryhm&auml;.
            </p>
        </footer>

        <div class="hidden">
            <p>the end.</p>
        </div>


        <script src="js/libs/jquery/jquery.js"></script>
        <script src="js/libs/jqueryui/jquery-ui.js"></script>
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
        <script src="js/libs/syntaxhighlight/sh_main.min.js"></script>

        <script src="js/libs/chartist.min.js"></script>
        <script src="js/libs/visibility.core.js"></script>
        <script src="js/libs/visibility.timers.js"></script>
        <script src="js/libs/visibility.fallback.js"></script>
        <script src="js/js-logger.js"></script>
        <script src="js/verticalfloat.js"></script>
        <script src="js/pheromones.js"></script>
        <script src="js/wepa.js"></script>


    </body>
</html>
