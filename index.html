<!DOCTYPE html>
<html>
    <head>
        <title>Web-palvelinohjelmointi</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="js/libs/syntaxhighlight/css/sh_style.css"/>
        <link rel="stylesheet" href="css/wepa.css"/>

        <link rel="stylesheet" href="css/wepa-mooc.css"/>

    </head>
    <body>

        <!-- BEGIN NAV -->
        <header role="navigation">
            <h1>
                <button type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>

                <!-- BEGIN MOOC SNIP -->                    
<!--
                <a href="http://www.mooc.fi" class="hidden-in-hy">&#171; mooc.fi</a>
-->
                <!-- END MOOC SNIP -->
                <!-- BEGIN HY SNIP -->                    
                <!-- END HY SNIP -->

                <a href="http://www.cs.helsinki.fi"><img src="img/header_tktl.png" alt="CS Dept. Univ. Helsinki"></a>
            </h1>
            <nav class="collapse bs-navbar-collapse" role="navigation">
                <ul>
                    <li>
                        <a href="#viikko1">Viikko 1</a>
                    </li>
<!--
                    <li>
                        <a href="#viikko2">Viikko 2</a>
                    </li>
                    <li>
                        <a href="#viikko3">Viikko 3</a>
                    </li>
                    <li>
                        <a href="#viikko4">Viikko 4</a>
                    </li>
                    <li>
                        <a href="#viikko5">Viikko 5</a>
                    </li>
                    <li>
                        <a href="#viikko6">Viikko 6</a>
                    </li>
                    <li>
                        <a href="#viikko7">Viikko 7</a>
                    </li>
-->
                </ul>
            </nav>
        </header>
        <!-- // END NAV -->
        <article>

            <section id="intro" class="no-toc weeklimit" data-week-id="-1">Huom! Jos etsit syksyllä 2014 julkaistua web-palvelinohjelmoinnin oppimateriaalia, löytyy se <a href="s2014-wepa.html">täältä</a>.</section>


            <!-- BEGIN INDEX -->
            <section id="intro" class="no-toc weeklimit" data-week-id="0">
                
                <header>

                    <div class="intro-header-img"></div>

                    <h1>Web-palvelinohjelmointi</h1>

                    <p>Voinko oppia tekemään Facebookin, Flickrin tai Twitterin?</p>

                    <a class="call-to-action" href="#start" role="button">No todellakin!</a>

                </header>


<!--
                <div class="hidden">

                    <h1>Sisältö ja aikataulu</h1>

                    <p>Kurssilla tutustutaan nykyaikaisten, skaalautuvien ja virheenkestävien web-sovellusten toteuttamiseen, testaamiseen ja julkaisemiseen. Kurssilla keskitytään palvelinpuolen toiminnallisuuden toteuttamiseen. Selainpuolen toiminnallisuudella on kurssilla hyvin pieni paino. Kurssin opetuskieli on Suomi ja ohjelmointikieli Java. Kurssilla hyödynnetään <a href="http://spring.io/" target="_blank">Spring</a>-sovelluskehystä.</p>

                    <p>Kurssi sisältää seitsemän tehtäväsarjaa, joista ensimmäinen julkaistaan 2. syyskuuta 2014, ja uusia julkaistaan aina viikoittain. Seuraavaan tehtäväsarjaan eteneminen vaatii sen, että tekee vähintään 80% edeltävästä tehtäväsetistä.</p>

                    <p><a class="jump" href="#viikoittaiset-teemat" role="button">Viikoittaiset teemat &raquo;</a></p>

                    <h1>Opettajille ja opiskelijoille</h1>

                    <p>Kurssi vastaa <a href="http://www.cs.helsinki.fi/home/" target="_blank">Helsingin yliopiston tietojenkäsittelytieteen laitoksen</a> kurssia <a href="http://www.cs.helsinki.fi/en/courses/582353" target="_blank">Web-palvelinohjelmointi</a> (5 opintopistettä).</p>

                    <p>Kurssia ja sen materiaalia saa käyttää ja muokata vapaasti, kunhan noudattaa materiaalin <a href="#license">lisenssiä</a>. Jos järjestät kurssista kokeen omassa oppilaitoksessasi, saat tarvittaessa osoitteesta <a href="mailto:mooc@cs.helsinki.fi">mooc@cs.helsinki.fi</a> koepohjan.</p>

                    <p>Jos olet opiskelijana jossain muualla kuin Helsingin yliopistolla ja haluaisit suorittaa kurssin siten, että saat suoritusmerkinnän tai opintopisteet omassa oppilaitoksessasi, etsi omasta oppilaitoksestasi opettaja tai opinto-ohjaaja, joka on valmis valvomaan kokeen ja hyväksymään kurssisuorituksen ja pyydä häntä lähettämään sähköpostia osoitteeseen <a href="mailto:mooc@cs.helsinki.fi">mooc@cs.helsinki.fi</a></p>

                </div>
-->

                <h1 id="start">Sisältö, aikataulu, arvostelu</h1>

                <p>Kurssilla tutustutaan nykyaikaisten, skaalautuvien ja virheenkestävien web-sovellusten toteuttamiseen, testaamiseen ja julkaisemiseen. Kurssilla keskitytään palvelinpuolen toiminnallisuuden toteuttamiseen. Selainpuolen toiminnallisuudella on kurssilla hyvin pieni paino. Kurssin opetuskieli on Suomi ja ohjelmointikieli Java. Kurssilla hyödynnetään <a href="http://spring.io/" target="_blank">Spring</a>-sovelluskehystä.</p>

                <p>Kurssi sisältää seitsemän tehtäväsarjaa. <strong>Ensimmäinen tehtäväsarja julkaistaan 2. syyskuuta 2015</strong>. Uusia tehtäväsarjoja julkaistaan viikoittain. Tehtäväsarjojen viimeiset palautuspäivät löytyvät TMC:stä -- ensimmäisen sarjan viimeinen palautuspäivä on <strong>maanantaina 7.9. klo 16:00</strong>.</p>

                <p>Kurssin arvostelu perustuu viikoittaisiin harjoitustehtäviin, sekä kahteen kokeeseen, joista toinen tehdään kynällä ja paperilla, ja toinen tietokoneella. Kurssin pisteytys on seuraava:</p>

		<ul>
		  <li>Viikoittaisista tehtäväsarjoista saa 100 pistettä viikkoa kohti. Täydet 100 pistettä saa tekemällä 100% viikon tehtävistä. Jos tekee puolet tehtävistä, saa 50 pistettä jne.</li>
		  <li>Paperilla tehtävästä kokeesta on mahdollista saada 250 pistettä.</li>
		  <li>Tietokoneella tehtävästä kokeesta on mahdollista saada 250 pistettä.</li>
		</ul>

		<p>Kurssista voi saada yhteensä 1200 pistettä. Sekä paperilla ja kynällä että tietokoneella tehtävistä kokeista on kummastakin saatava vähintään puolet mahdollisista pisteistä. Kurssin alustavat arvosanarajat ovat seuraavat:</p>

		<ul>
		  <li>700 -> 1</li>
		  <li>800 -> 2</li>
		  <li>900 -> 3</li>
		  <li>1000 -> 4</li>
		  <li>1100 -> 5</li>
		</ul>

                <p><a class="jump" href="#viikoittaiset-teemat" role="button">Viikoittaiset teemat &raquo;</a></p>

                <h1>Esitietovaatimukset ja kurssin suorittaminen</h1>

                <p>Kurssilla oletetaan Java-ohjelmointikielen tuntemus kurssien ohjelmoinnin perusteet ja ohjelmoinnin jatkokurssi laajuudessa. Tämän lisäksi kursseista ohjelmistotekniikan menetelmät, tietokantojen perusteet, ohjelmoinnin harjoitustyö, tietokantasovellus, ja ohjelmistotuotanto on huomattavasti apua.</p>


                <h2>Luennot ja ohjaus</h2>
		
                <p>Kurssin ainoa luento pidetään keskiviikkona 2.9. kello 14-16 salissa A111.</p>
		
                <p>Kurssilla on kyselymuotoisia ohjaustunteja huoneessa C221 (Linkki) maanantaisin ja perjantaisin kello 12-14. Huoneessa on myös tietokoneita, joilla kurssin tehtäviä voi tehdä.</p>

		<p>Ohjaustunneille tulee ilmoittautua osoitteessa <a href="http://kyselyilmo.herokuapp.com" target="_blank">http://kyselyilmo.herokuapp.com</a> olevan sovelluksen kautta. Jos tunnille ei ole tulossa osallistujia, tuntia ei pidetä.</p> 

		<p>Kurssilla on lisäksi IRC-kanava <code>#wadup</code>, josta löytyy muita kurssilaisia. Muiden auttaminen kanavalla on vapaaehtoista, mutta luonnollisesti suositeltavaa. Auttamisesta hyötyy apua tarvitsevan lisäksi myös auttaja.</p>


                <h1 id="viikoittaiset-teemat">Viikoittaiset teemat -- voivat muuttua kurssin edetessä</h1>


                <ul id="week-toc">
                    <li><a href="#viikko1">Viikko 1</a> Webin peruskomponentit, Spring Bootin alkeet, dynaamiset sivut ja luonnolliset näkymätemplatet, ensimmäinen tietokantasovellus.</li>
                    <li><a href="#viikko2">Viikko 2</a> Palvelinohjelmistojen kerrokset.</li>
                    <li><a href="#viikko3">Viikko 3</a> REST, HTTP ja Sessiot.</li>
                    <li><a href="#viikko4">Viikko 4</a> Palveluorientoituneet arkkitehtuurit, testaamisen perusteet sekä konfiguraatiot.</li>
                    <li><a href="#viikko5">Viikko 5</a> Luonnolliset näkymätemplatet, mediatiedostojen kuten kuvien ja videoiden tallentaminen ja näyttäminen, tietoturva.</li>
                    <li><a href="#viikko6">Viikko 6</a> Web-sovellusten skaalautuminen.</li>
                    <li><a href="#viikko7">Viikko 7</a> Kertaus ja "facebook".</li>
                </ul>


                <h1>Sisällysluettelo</h1>

                <ul class="nav" id="material-toc"></ul>

                <h1>Tehtävät</h1>

                <ul class="nav nav-pills nav-pills-fixed-width" id="tehtavat-toc"></ul>

            </section>
            <!-- END INDEX -->

            <!-- BEGIN WEEK1 -->
            <section class="weeklimit" data-week-id="1">

                <header>
                    <h1 id="viikko1">Viikko 1</h1>
                </header>

                <h1>Aloitus</h1>

                <h2>Web-sovelluksista yleisesti</h2>

                <p>Web-sovellukset koostuvat selain- ja palvelinpuolesta. Käyttäjän koneella toimii selainohjelmisto (esim. <a href="http://chrome.google.com" target="_blank">Google Chrome</a>), jonka kautta käyttäjä tekee pyyntöjä verkossa sijaitsevalle palvelimelle. Kun palvelin vastaanottaa pyynnön, se käsittelee pyynnön ja rakentaa pyynnölle sopivan vastauksen. Vastaus voi sisältää esimerkiksi web-sivun tai tietyssä muodossa olevaa dataa.</p>

                <div class="image">
                    <img src="img/pyynto.png"/>
                    <div>Web-sovellusten käyttäminen: (1) käyttäjä klikkaa linkkiä, (2) selain tekee pyynnön palvelimelle, (3) palvelin käsittelee pyynnön ja rakentaa vastauksen, (4) selaimen tekemään pyyntöön palautetaan vastaus. Vastauksen näyttämistä käyttäjälle ei näytetä tässä kuvassa.</div>
                </div>

                <p>Selainohjelmointiin ja käyttöliittymäpuoleen keskityttäessä painotetaan rakenteen, ulkoasun, ja toiminnallisuuden erottamista toisistaan. Karkeasti voidaan sanoa, että sivun rakenne määritellään <a href="http://en.wikipedia.org/wiki/CSS" target="_blank">HTML</a>-tiedostoilla, ulkoasu <a href="http://en.wikipedia.org/wiki/CSS" target="_blank">CSS</a>-tiedostoilla, ja toiminnallisuus <a href="http://en.wikipedia.org/wiki/JavaScript" target="_blank">JavaScript</a>-tiedostoilla.</p>

                <p>Palvelinpuolen toiminnallisuutta toteutettaessa keskitytään tyypillisesti selainohjelmiston tarvitsevan "APIn" suunnitteluun ja toteutukseen, sivujen muodostamiseen selainohjelmistoa varten, datan tallentamiseen ja käsittelyyn, sekä sellaisten laskentaoperaatioiden toteuttamiseen, joita selainohjelmistossa ei kannata tai voida tehdä.</p>

                <p>Web-sovelluksista puhuttaessa on hyvä erottaa staattiset ja dynaamiset sivut toisistaan. Staattiset sivut ovat sivuja, joiden sisältö on ennalta määrätty, ja jotka palvelin palauttaa suoraan käyttäjälle niitä pyydettäessä. Dynaamiset sivut taas luodaan palvelimella tarvittaessa. Esimerkiksi osoitteessa <a href="http://telkku.com/" target="_blank">http://telkku.com/</a> toimiva web-sovellus luo näytettävän televisio-ohjelmiston dynaamisesti palvelinpuolella: uuden staattisen sivun luominen käsin aina uuden ohjelmatiedon saapuessa olisi erittäin raskasta ja tehotonta. Sivuston tarjoama hakupalvelu mahdollistaa rajattoman määrän erilaisia sivustoja; kukaan ei kirjoittaisi näitä käsin.</p>

                <p>Työpöytäsovelluksia ja web-sovelluksia verrattaessa työpöytäsovellukset tarjoavat enemmän interaktiivisuutta ja nopeutta web-sovelluksiin verraten. Web-sovellukset toisaalta mahdollistavat saumattomat ohjelmistojen päivitykset, helposti jaettavan ja ylläpidettävän datan ja dokumenttien jakamisen, sekä kevyet käyttöliittymät. Olemme viimeisten vuosien aikana todistaneet muutosta, missä web-sovellukset hiljalleen syrjäyttävät perinteiset työpöytäsovellukset, myöskin niissä tapauksissa, joissa sovelluksilla on käyttäjiä vain yksittäisessä paikassa. Tälläkin hetkellä Google tarjoaa kaikille ilmaista toimistotyökalupakettia, elokuvien ja tv-ohjelmien katsominen selainohjelmistossa on helppoa esimerkiksi Yle Areenan tai Netflixin avulla, ja selaimessa pelattavat pelit ovat ohittaneet perinteiset tietokonepelit käyttäjämäärissä jo muutamia vuosia sitten.</p>



                <h2>Ohjelmistojen kehittämisestä</h2>

                <p>Ohjelmistojen kehittämistä verrataan usein naiivisti talojen tai rakennusten rakentamiseen. Taloa suunnitellessa arkkitehdillä on selkeä tehtävä ja etenemissuunnitelma: kerää vaatimukset, tutki vaihtoehtoja, ja luo pohjapiirrustus. Kun arkkitehti on luonut pohjapiirrustuksen, se annetaan urakoitsijalle, jonka pohjalta urakoitsijan palkkaamat työntekijät -- rakennusmiehet -- rakentavat rakennuksen vaadituilla materiaaleilla.</p>

                <p>Ohjelmistoja suunniteltaessa arkkitehti osallistuu sekä ohjelmiston suunnitteluun että kehitykseen, eli rakentamiseen. Koska ohjelmistoista halutaan mahdollisimman nopeasti konkreettista palautetta, arkkitehti aloittaa ohjelmiston suunnittelun perustarpeista: muutamasta huoneesta, joihin palautetta antavat ihmiset muuttavat. Kun alkuperäinen suunnitelma on lähes valmis, rakennukseen muuttaa lisää ihmisiä, jotka tarvitsevat rakennukselta uusia toiminnallisuuksia. Ensisijaisina vaatimuksina ovat uudet huoneet, pesula, disko ja luonnollisesti oleskelutila, jossa on tilaa biljardipöydälle.</p>

                <p>Tällöin arkkitehti muuttaa alkuperäistä suunnitelmaansa ottaen huomioon uudet ihmiset ja kehitystyö jatkuu. Kehitystyön jatkuessa alkuperäiset asukkaat alkavat valittamaan rakennusmelusta ja uhkaavat poismuutolla jos asioihin ei saada muutosta, aiheuttaen hiusten harvenemista arkkitehdille. Toisaalta, sana uudesta biljardipöydästä kiertää, ja yhä enemmän ihmisiä muuttaa rakennukseen, ja rakennukselta vaaditaan taas uusia huoneita sekä cartingrata ja curlinghalli.</p>

                <p>Hyvän suunnittelun perusta on mahdollisuuksien huomiointi. Huomioinnilla ei tarkoiteta sitä, että rakennetaan heti aluksi iso järjestelmä -- käytännössä järjestelmän valmistuessa sille ei olisi käyttäjiä sillä kaikki olisivat siirtyneet toiseen aiemmin tarpeellisia ominaisuuksia tarjonneeseen järjestelmään. Jos alkuperäinen suunnitelma tekee järjestelmän laajentamisesta vaikeaa, käyttäjät saattavat vaihtaa palvelua hitauden takia.</p>

                <p>Kaikkien osapuolten toiveet tyydyttävän ohjelmiston rakentaminen on haastavaa. Jokaista ohjelmistoa joudutaan laajentamaan, rajaamaan ja muokkaamaan. Asiakkaalla tai asiakkailla on käytännössä aina uusia toivomuksia ohjelmiston elinkaaren varrella.</p>

                <p>Arkkitehtuurin tulee mahdollistaa sopivan kokoisesta palasta aloittaminen sekä rakennettavan sovelluksen laajentaminen, myös toisten kehittäjien toimesta. Käytännössä hyvin harvat ohjelmistot ovat vain yhden ihmisen käsialaa, ja laajempaa sovellusta kehitettäessä olemassaolevien ohjelmistokomponenttien hyödyntäminen on oleellista. Ohjelmistoalalla aloittelevan on hyvin vaikea valita sopivia komponentteja olemassaolevasta viidakosta sillä yhtä oikeaa ratkaisua ei yleensä ole.</p>

                <p>Oleelllisinta ohjelmistokehityksessä on kommunikointi niin koodin kautta kuin muita väyliä käyttäen. Avoimeen lähdekoodiin ja online-versionhallintatyökaluihin (esim. GitHub) perustuvat projektit saavat ihmiset eri puolilta maailmaa tekemään työtä yhteisten kiinnostuksenkohteiden takia. Sovittujen käytänteiden (esim. nimeämiskäytänteet, versionhallinta, testaus, dokumentointi ym.) noudattaminen on oleellista sillä heikko suunnittelu ja ylläpidettävyys, esimerkiksi muuttujien huono nimentä, aiheuttavat lähinnä kylmiä väreitä ja ajavat innokkaat ihmiset pois.</p>

                <p>Työkaluja valittaessa tarkoituksena on välttää nurkkaan ajautumista: työkaluista tulee pystyä myös pääsemään eroon. On paljon hyödyllisempää miettiä päivä ja käyttää muutama päivä prototyypin tekemiseen, koska prototyyppiä voidaan parantaa kuukausia, kuin miettiä kuukausi ja sitouttaa itsensä kuukauden aikana luotuun suunnitelmaan. Mitä nopeammin toiminnallisuutta on olemassa, sitä nopeammin siitä saa palautetta.  Toisaalta, mitä vähemmän aikaa yksittäisen toiminnallisuuden toteuttamiseen käytetään, sitä helpommin siitä voi tarpeen vaatiessa hankkiutua eroon.</p>

                <p>Sovelluksia tehdessä, erityisesti prototyyppivaiheessa, otetaankin usein hieman teknistä velkaa ns. "menemällä siitä mistä aita on matalin". Tämä velka maksetaan kuitenkin ennen pitkää takaisin; mitä pidempään sen takaisinmaksussa kestää, sitä suurempi velan korko on.</p> 



                <h2>Kurssin työvälineet</h2>

                <p>Käytämme tällä kurssilla ohjelmointiympäristönä <a href="http://netbeans.org/" target="_blank">NetBeans</a>ia, ohjelmistoprojektien ja komponenttien riippuvuuksien hallintaan <a href="http://maven.apache.org" target="_blank">Maven</a>ia, sekä komentotulkkia. Harjoitustehtävät palautetaan <a href="http://tmc.mooc.fi/hy" target="_blank">Test My Code</a>-palvelimelle NetBeansiin ladattavan Test My Code -liitännäisen avulla.</p>

                <p>Selainpuolella ohjelmistoja tutkitaan <a href="http://chrome.google.com">Google Chrome</a>ssa olevien <a href="https://developers.google.com/chrome-developer-tools/" target="_blank">DevTools</a>ien avulla.</p>

                <h3>NetBeansin ja Test My Coden asennus</h3>

                <p>Test My Coden web-sivu löytyy osoitteesta <a href="http://tmc.mooc.fi/hy">http://tmc.mooc.fi/hy</a>. Valitse sivun ylälaidasta <em>Sign up</em> ja kirjaudu järjestelmään. Jos olet HY:n opiskelija, käytä käyttäjätunnuksena (<em>username</em>) opiskelijanumeroasi, ja anna järjestelmään käyttämäsi sähköpostiosoite. Opiskelijanumeron käyttö opiskelijana on tärkeää: näin tehtävistä saamasi pisteet voidaan liittää sinuun jos osallistut kokeeseen. Kun käyttäjätunnuksesi on luotu ja kirjautuminen onnistuu, jatka eteenpäin.</p>

                <p>NetBeans-sovelluskehitysympäristön ladattua osoitteesta <a href="http://netbeans.org/" target="_blank">http://netbeans.org/</a>. NetBeansin versiota ladattaessa kannattaa valita versio kaikilla mausteilla, eli vaihtoehto "All". Jos NetBeans kysyy haluatko käyttää vanhoja asetuksia sitä käynnistettäessä, kannattaa valita <strong>ei</strong>.</p>

                <p>Test My Code-liitännäisen saa lisättyä NetBeansin pluginvaihtoehdoksi näkyviin valitsemalla Tools -> Plugins. Valitse avautuvasta ikkunasta Settings-välilehti, ja klikkaa uuden liitännäispaikan lisäämiseen tarkoitettua Add-nappia. Anna avautuvaan ikkunaan latauspaikan nimeksi <code>TMC</code>, ja osoitteeksi <code>http://update.testmycode.net/tmc-netbeans_mooc/updates.xml</code>. Valitse lopulta OK.</p>

                <p>Mene tämän jälkeen Available Plugins -välilehdelle ja etsi sieltä vaihtoehto Test My Code NetBeans Plugin. Klikkaa sen vasemmalla puolella olevaa laatikkoa, ja painaa Install. Tämä asentaa Test My Coden NetBeansiisi.</p>

                <p>Kun Test My Code on asentunut, NetBeans haluaa käynnistyä uudestaan. Käynnistä NetBeans uudestaan. Tämän jälkeen NetBeansin valikossa on myös vaihtoehto Test My Code. Käy vielä asettamassa Test My Coden asetukset. Valitse TMC -> Settings, ja täytä avautuvaan ikkunaan tietosi. Käyttäjätunnus on TMC-tunnuksesi, salasanasi TMC:hen liittyvä salasanasi. Valitse kurssiksi <em>opettajalta saamasi tunnus</em>.</p>

                <p>Varmista että myös alaosassa olevat vaihtoehdot ovat valittuina ja paina OK (kurssin kehittämisen kannalta on erittäin tärkeää, että viimeinen vaihtoehto "Send snapshots of your progress for study" on valittu). Tämän jälkeen NetBeans kysyy sinulta ladataanko saatavilla olevat tehtävät. Valitse "Download".</p>

                <p>NetBeans lataa tehtävät, jonka jälkeen ne ovat näkyvissä NetBeans-projekteina. Pieni musta pallo projektin ikonissa tarkoittaa että tehtävää ei ole vielä yritetty. Jos pallo on vihreä, on tehtävästä kerätty kaikki pisteet.</p>



                <h3>Ohjelmistoprojektien hallinta ja Maven</h3>

                <p>Jokaisessa ohjelmistoprojektissa tulee vastaan erilaisia lähdekoodiin liittyviä tarpeita. Lähdekoodia tulee pystyä paketoimaan tuotantopalvelimelle siirettäväksi paketiksi (esim -.jar ja -.war -tiedostot), lähdekoodiin liittyviä testejä tulee pystyä ajamaan erillisellä palvelimella ja lähdekoodista tulee pystyä generoimaan erilaisia raportteja sekä luonnollisesti dokumentaatiota.</p>

                <p>Työkalut kuten <em><a href="http://ant.apache.org/" target="_blank">Apache Ant</a></em> auttavat projektiin liittyvän lähdekoodin hallinnoinnissa ja kääntämisessä. Ant on käytännössä 2000-luvun alun vastine perinteisille Makefile-tiedostoille. Nykyaikaisemmat <em><a href="http://maven.apache.org/" target="_blank">Apache Maven</a></em> ja <em><a href="http://www.gradle.org/" target="_blank">Gradle</a></em> auttavat käännösprosessin lisäksi muunmuassa projektiin liittyvien kirjastoriippuvuuksien automaattisessa hallinnassa. Käytämme tällä kurssilla Mavenia.</p>

                <p>Apache Maven on projektinhallintatyökalu, jota voi käyttää ohjelmakoodikäännösten lisäksi lähes koko projektin elinkaaren hallintaan uuden projektin aloittamisesta lähtien. Maven tarjoaa ohjelmiston elinkaaren hallintaan joukon valmiiksi konfiguroituja vaiheita (<em>phase</em>), joita voidaan suorittaa komentoriviltä. Usein käytettäviä vaiheita ovat mm. <em>test</em>, joka suorittaa projektiin liittyvät testit sekä <em>package</em>, joka paketoi lähdekoodin projektityypistä riippuen sopivaan pakettiin. Oikeastaan Maven on sovelluskehys liitännäisten suoritukseen ja yksinkertaisimmatkin Mavenin tarjoamat toiminnot ovat toteutettu liitännäisinä.</p>

                <p>Jokaisella Maven-projektilla on elinkaari, joka sisältää vaiheet lähtien projektin validoinnista, kääntämisestä ja testaamisesta aina tuotantoon siirtämiseen asti. Tarkempi listaus projektin erilaisista vaiheista löytyy Mavenin <a href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#Lifecycle_Reference" target="_blank">dokumentaatiosta</a>. Kukin vaihe koostuu yhdestä tai useammasta tavoitteesta (<em>goal</em>), jotka suoritetaan vaiheen sisällä. Vaiheet riippuvat myös edellisistä vaiheista; esimerkiksi vaihetta <em>test</em> suoritettaessa Maven suorittaa ensin projektin validoinnin ja kääntämisen.</p>

                <p>Mavenin liitännäisarkkitehtuuri mahdollistaa hyvin monipuolisen toiminnallisuuden. Esimerkiksi raportointia ja staattista koodianalyysiä varten löytyy omat liitännäiset, samoin kuin mahdollisen (web-)palvelimen käynnistämiselle projektin testausta varten. Liitännäisistä löytyy (ei kattava) lista osoitteessa <a href="http://maven.apache.org/plugins/index.html" target="_blank">http://maven.apache.org/plugins/index.html</a>.</p>

                <p>Maven automatisoi uusien projektien luomisen <em>archetype</em>-liitännäisellä. Archetype-liitännäisen avulla ohjelmistokehittäjät voivat tarjota toisilleen valmiita projektirunkoja ja esimerkiksi määritellä yrityksen teknologiavalinnat paketiksi, jonka pohjalta uuden sovelluksen kehittäminen on nopeaa.</p>

                <p>Yksi Mavenin tärkeimmistä ominaisuuksista on tarvittavien kirjastojen eli riippuvuuksien automaattinen lataaminen. Mavenin avulla projektiin voi määritellä riippuvuuden esimerkiksi yksikkötestauskirjastoihin ja käytetyn web-sovelluskehyksen kirjastoihin. Tällöin Maven lataa riippuvuudet automaattisesti ja kirjastoja ei tarvitse pitää esimerkiksi projektikohtaisessa tai paikallisessa versionhallintajärjestelmässä.</p>



                <h3>Mavenin projektirakenne</h3>

                <p>Mavenin archetype-pluginia käyttäen uuden projektin luonti tapahtuu helposti. Luodaan uusi projekti, jota tarkastelemme seuraavaksi. Uuden projektin luominen onnistuu komentoriviltä esimerkiksi seuraavan komennon avulla.</p>

                <pre>mvn archetype:generate -DgroupId=fi.organisaatio -DartifactId=sovelluksen-nimi</pre>

                <p>Käytännössä komennossa <code>mvn archetype:generate</code> kutsutaan Mavenin archetype-liitännäiseen liittyvää tavoitetta <code>generate</code> ja annetaan sille kaksi parametria. Parametrilla <code>-DgroupId</code> kerrotaan katto-organisaation tai ryhmän tunnus, parametrilla <code>-DartifactId</code> kerrotaan luotavan sovelluksen nimi.</p>

                <p>Komento hakee archetype-pluginista valmit projektipohjat, ja kysyy ensin mitä pohjaa haluat käyttää. Tämän jälkeen Maven kyselee muita tietoja luotavasta projektista. Koska haluamme vain tutustua tässä Mavenin projektirakenteeseen, vastaillaan kysymyksiin enter-painalluksilla. Tällöin Maven käyttää oletusvastauksia.</p>

                <p>Kun projekti on luotu, sillä on seuraavanlainen kansiorakenne.</p>

                <pre>
sovelluksen-nimi
 ├── pom.xml
 └── src
     ├── main
     │   └── java
     │       └── fi
     │           └── organisaatio
     │               └── App.java
     └── test
         └── java
             └── fi
                 └── organisaatio
                     └── AppTest.java
                </pre>

                <p>Sovelluksen ja testien lähdekoodit ovat eritelty erillisiin kansioihin. Projektin alla olevassa kansiossa <code>src</code> on projektiin liittyvät lähdekoodit. Kansion <code>src</code> alla on kansiot <code>main</code> ja <code>test</code>, joissa toisessa on projektiin liittyvää koodia, ja toisessa projektiin liittyvät testit. Maven-projektin konfiguraatiotiedosto <code>pom.xml</code> on projektin juuressa.</p>

                <p>Projektin luominen valmiista archetype-projekstista onnistuu myös NetBeansissa. Valitsemalle File -&gt; New Project pääsee projektivalikkoon, josta löytyy kategoria Maven. Kun vaihtoehto "Project from Archetype" valitaan käyttäjä pääsee selaamaan saatavilla olevia vaihtoehtoja. Archetypen valinnan jälkeen projektille annetaan nimi ja aloitetaan sovelluksen kehittäminen. </p>


                <h3>Mavenin "pom.xml": Project Object Model</h3>

                <p>Tiedoston pom.xml osa <strong>pom</strong> tulee sanoista <em>Project Object Model</em>. XML-muotoinen pom-tiedosto sisältää projektiin liittyvän rakenteen, asetukset, kirjastoriippuvuudet ja tarvittaessa määritellyt tavoitteet. Yksinkertaisimmillaan pom.xml -tiedosto sisältää kuvauksen organisaatiosta, projektin nimestä, versiosta ja lähdekoodin pakkausmuodosta. Edellisessä osiossa komentorivillä luodun projektin pom.xml -sisältö näyttää seuraavalta.</p>

                <pre class="sh_xml">
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;groupId&gt;fi.organisaatio&lt;/groupId&gt;
  &lt;artifactId&gt;sovelluksen-nimi&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;name&gt;sovelluksen-nimi&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;

  &lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
  &lt;/properties&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</pre>

                <p>Alussa on XML-tiedoston otsake, joka määrittelee käytetyn <a href="http://www.w3schools.com/schema/schema_intro.asp" target="_blank">XML-skeeman</a>. Tämän jälkeen määritellään projektin tiedot (groupId = ryhmä, artifactId = projekti, version = projektin versio, packaging = pakkausmuoto). Tämän jälkeen tulee sovelluksen nimi (usein sama kuin projekti), sekä projektiin liittyvä osoite. Näitä seuraa projektiin liittyvät asetukset – yllä olevassa tiedostossa on määritelty projekti käyttämään UTF-8 -merkistökoodausta.</p>

                <p>Dependencies-osiossa määritellään kirjastot, joita projekti tarvitsee. Esimerkissä projektille on määritelty riippuvuus yksikkötestauksessa käytettävään JUnit-sovelluskirjastoon, jonka Maven lataa automaattisesti. Riippuvuuden <code>scope</code>-osiolla voidaan määritellä vaihe, johon riippuvuus liittyy. Yllä olevassa esimerkissä JUnit-kirjastoa on käytössä vain <code>test</code>-vaiheessa. Käytännössä siis JUnit on käytössä vain testausta varten, mutta se ei tule olemaan mukana asiakkaalle lähetettävässä valmiissa sovelluksessa.</p>

                <aside class="extra">
                    <h1>XML?!</h1>

                    <p>XML (Extensible Markup Language) on laitteistoriippumaton tapa tiedon tallentamiseen siten, että tallennusmuodossa välittyy myös tiedon rakenne. XML-dokumentteja käytetään mm. grafiikan (SVG), tekstidokumenttien (OOXML) ja erilaisten asetustiedostojen tallentamiseen. Tällä kurssilla XML esiintyy projektien asetuksia muokatessa.</p>

                    <p><a href="http://www.w3schools.com/xml/xml_whatis.asp" target="_blank">W3Schoolsin XML-opas</a></p>
                </aside>


                <h3>Maven ja riippuvuuksien hallinta</h3>


                <p>Projektikonfiguraatiossa (<code>pom.xml</code>) olevassa dependencies-osiossa määritellään kirjastot, joita projekti käyttää. Riippuvuuksia ei ole pakko olla yhtäkään, tai niitä voi olla useita. Käytettävät kirjastot riippuvat usein myös muista kirjastoista. Maven (versiosta 2 lähtien) lataa automaattisesti myös käytettävien kirjastojen tarvitsemat riippuvuudet: esimerkiksi JUnit-kirjaston uusin versio tarvitsee avukseen hamcrest-nimisen kirjaston (kts. "This artifact depends on..." osoitteessa <a href="http://mvnrepository.com/artifact/junit/junit/4.11" target="_blank">http://mvnrepository.com/artifact/junit/junit/4.11</a>). Voimme kuitenkin määritellä riippuvuudeksi JUnit-kirjaston ja antaa Mavenin hoitaa loput. </p>

                <p>Projekti voi myös periä jonkun toisen projektin konfiguraation. Elementti &lt;parent&gt; kertoo perittävän komponentin tiedot. Esimerkiksi, seuraavalla konfiguraatiolla kerromme, että perimme <code>spring.framework.boot</code>-ryhmän <code>spring-boot-starter-parent</code> -projektin version <code>1.1.6.RELEASE</code>.</p>

                <pre class="sh_xml">
  &lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;1.1.6.RELEASE&lt;/version&gt;
  &lt;/parent&gt;</pre>

                <p>Lisää tietoa riippuvuuksien hallinnasta löytyy mavenin <a href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html" target="_blank">dokumentaatiosta</a>. Hyviä paikkoja kirjastojen etsimiseen ovat muun muassa <a href="http://search.maven.org/" target="_blank">http://search.maven.org/</a> ja <a href="http://mvnrepository.com/" target="_blank">http://mvnrepository.com/</a>.</p>


                <h3>Mavenin valmiita komentoja</h3>

                <p>Kirjoittaessamme pom.xml-tiedoston sisältävässä kansiossa komennon <code>mvn</code>, näemme viestin, joka valittaa komennon puuttumisesta. Viestin konkreettinen sisältö riippuu mavenin versiosta, esimerkiksi mavenin versiossa 2 oleellinen sisältö on seuraavanlainen. Kolmosversiossa viesti on vaikealukuisempi...</p>

                <pre>
$ mvn
...
You must specify at least one goal or lifecycle phase to perform build steps.
The following list illustrates some commonly used build commands:

  mvn clean
    Deletes any build output (e.g. class files or JARs).
  mvn test
    Runs the unit tests for the project.
  mvn install
    Copies the project artifacts into your local repository.
  mvn deploy
    Copies the project artifacts into the remote repository.
  mvn site
    Creates project documentation (e.g. reports or Javadoc).

Please see
http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html
for a complete description of available lifecycle phases.
...
                </pre>


                <p>Selaamalla osoitteeseen <a href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html" target="_blank">http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html</a> näemme tarkemman listan toiminnoista, joita maven tarjoaa ohjelmistoprojektin eri vaiheisiin.</p>

                <h3>Testien suorittaminen</h3>

                <p>Projektiin liittyvät testit suoritetaan käyttämällä mavenin vaihetta <code>test</code>. Käytännössä kukin vaihe liittyy johonkin tiettyyn pluginiin, esimerkiksi test-vaiheessa suoritetaan <code><a href="http://maven.apache.org/plugins/maven-surefire-plugin/" target="_blank">surefire</a></code>-pluginin tavoite <code>test</code>. Lisätietoja vaiheiden oletusplugineista löytyy <a href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#Setting_Up_Your_Project_to_Use_the_Build_Lifecycle" target="_blank">täältä</a>.</p>

                <p>Suoritetaan testit antamalla projektikansiossa komento <code>mvn test</code> (saman voi tehdä myös NetBeansissa valitsemalla projektin oikealla hiiren napilla ja painamalla "Test").</p>

                <pre>
$ mvn test
// tulostusta...
[INFO] ------------------------------------------------------------------------
[INFO] Building sovelluksen-nimi 1.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
// tulostusta...
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running fi.organisaatio.AppTest
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.016 sec

Results :

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0

[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
// tulostusta
                </pre>

                <p>Käytännössä projektiin liittyvät testitiedostot, joita komentorivin kautta luomassamme esimerkkiprojektissa on vain 1, suoritetaan. Jos testeissä on ongelmia, mavenista pääsee käsiksi niihin liittyviin raportteihin.</p>

                <p>Projektin konfiguraation muokkaus on helppoa kun tietää mitä tekee. Esimerkiksi yksikkötestauskirjaston JUnit version vaihtaminen vanhasta versiosta 3.8.1 versioon 4.11 onnistuu helposti. Käytännössä vain <code>version</code>-tägin sisältö tulee vaihtaa:</p>


                <pre class="sh_xml">
  ...
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;4.11&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  ...
                </pre>

                <p>Jos testit suoritetaan nyt uudestaan komennolla <code>mvn test</code>, huomataan että Maven lataa JUnit-version 4.11 käyttöösi. Koska JUnit on taaksepäin yhteensopiva, testit menevät läpi.</p>

                <aside class="extra">

                    <h1>Riippuvuuksien lataamisen manuaalinen käynnistäminen NetBeansissa</h1>

                    <p>Jos NetBeans-projektin kuvakkeessa on keltainen kolmio sekä lähdekoodikansioissa mahdollinen punainen pallo, saat lisätietoa ongelmasta viemällä hiiren projektin nimen päälle.</p>

                    <p>Jos ongelmana näkyy teksti "Some dependency artifacts are not in the local repository.", eli osaa riippuvuuksista ei ole ladattu paikalliselle koneelle, voit valita oikealla hiirennäppäimellä Dependencies ja "Download Declared Dependencies". Nyt NetBeans pyytää Mavenia lataamaan riippuvuudet.</p>

                    <p>Riippuvuudet ladataan käyttäjän kotihakemiston alla olevaan kansioon ".m2".</p>

                </aside>


                <h1>Webin peruskomponentit</h1>

                <p><em>"I just had to take the hypertext idea and connect it to the TCP and DNS ideas and – ta-da! – the World Wide Web."</em> -- <a href="http://en.wikipedia.org/wiki/Tim_Berners-Lee" target="_blank">Tim Berners-Lee</a></p>


                <p>Webin peruskomponentit ovat (1) URI (<em>Uniform Resource Identifier</em>) ja DNS (<em>Domain Name Services</em>) , jotka mahdollistavat resurssien ja palveluiden yksilöinnin, (2) HTTP (<em>HyperText Transfer Protocol</em>), joka on protokolla viestien lähetykseen verkon yli, sekä (3) HTML (<em>HyperText Markup Language</em>), eli yhteinen dokumenttien esityskieli.</p>

                <h2>URI ja DNS</h2>

                <p><em>"The most important thing that was new was the idea of URI-or URL, that any piece of information anywhere should have an identifier, which will allow you to get hold of it."</em> -- Tim Berners-Lee</p>

                <p>Verkossa sijaitseva sivusto tunnistetaan sille annetun yksilöivän osoitteen perusteella. Osoite (URI eli Uniform Resource Identifier, terminä käyttöön jäänyt URL <em>Uniform Resource Locator</em>) koostuu resurssin nimestä ja sijainnista, joiden perusteella haluttu palvelin ja resurssi voidaan löytää verkossa olevien koneiden massasta.</p>

                <p>Kun käyttäjä kirjoittaa web-selaimen osoitekenttään URIn ja painaa enteriä, web-selain tekee kyselyn annettuun osoitteeseen. Koska tekstimuotoiset osoitteet ovat käytännössä vain ihmisiä varten, kääntää selain ensiksi halutun osoitteen numeeriseksi IP-osoitteeksi. Jos IP-osoite on jo tiedossa esimerkiksi aiemmin osoitteeseen tehdyn kyselyjen takia, selain voi ottaa yhteyden IP-osoitteeseen. Jos taas IP-osoite ei ole tiedossa, tulee selaimen ensin tehdä kysely <a href="http://fi.wikipedia.org/wiki/DNS" target="_blank">DNS</a>-palvelimelle (<em>Domain Name System</em>), jonka tehtävänä on muuntaa tekstuaaliset osoitteet IP-osoitteiksi (esim. Tietojenkäsittelytieteen laitoksen kotisivu <code>http://www.cs.helsinki.fi</code> on IP-osoitteessa <code>128.214.166.78</code>). Ilman DNS-palvelimia ihmisten tulisi muistaa IP-osoitteet ulkoa, joka käytännössä tarkoittaisi ettei nykyinen internet toimisi.</p>

                <p>IP-osoitteet yksilöivät tietokoneet ja mahdollistavat koneiden löytämisen verkon yli. Käytännössä yhteys IP-osoitteen määrittelemään koneeseen avataan sovellustason HTTP-protokollan avulla kuljetustason TCP-protokollan yli. TCP-protokollan tehtävänä on varmistaa, että viestit pääsevät perille. Lisää tietoa konkreettisesta tietoliikenteestä kurssilla <a href="http://www.cs.helsinki.fi/courses/582202" target="_blank">Tietoliikenteen perusteet</a>.</p>

                <p>Käytännössä URIt näyttävät seuraavilta:</p>

                <pre>
protokolla://isäntäkone[:portti]/polku/../[kohdedokumentti][?kyselyparametrit][#ankkuri]
                </pre>

                <p>
                <ul>
                    <li>protokolla: kyselyssä käytettävä protokolla, esimerkiksi HTTP, FTP tai SSH.</li>
                    <li>isäntäkone: kone tai palvelin johon luodaan yhteys. Voi olla joko IP-osoite tai tekstuaalinen kuvaus (esim www.cs.helsinki.fi).</li>
                    <li>portti: portti isäntäkoneella johon yhteys luodaan. HTTP-palvelimien oletusportti on 80. Jos palvelin käyttää eri porttinumeroa kuin 80, tulee se merkitä osoitteeseen. Portti käytännössä määrittelee prosessin, johon yritetään ottaa yhteyttä.</li>
                    <li>polku: periaatteessa polku resurssiin palvelimella. Käytännössä (nykyään) palvelun osoite, johon palvelin osaa osoittaa. Usein palvelut toimivat erillisessä koneessa sisäverkossa, ja ulkoverkkoon näkyvä kone vain toimii ohjaajana eli proxynä oikeaan palveluun.</li>
                    <li>kohdedokumentti: haettava resurssi, jos kohdedokumenttia ei ole määritelty palvelin päättelee oletusdokumentin. Usein index.html</li>
                    <li>kyselyparametrit: koostuu avain-arvo -pareista, joiden avulla palvelimelle pystyy toteuttamaan lisätoiminnallisuutta. Kuhunkin avaimeen liittyvä arvo esitetään = -merkillä, avain-arvo -parit erotetaan toisistaan &-merkillä.</li>
                    <li>ankkuri: kertoo mihin kohtaan dokumentissa tulee mennä.</li>
                </ul>
                </p>

                <aside class="pohdi">
                    <h1>Osoitteen osat</h1>

                    <p>Tutki osoitetta <a href="http://www.googlefight.com/index.php?lang=en_GB&word1=Batman&word2=Superman" target="_blank">http://www.googlefight.com/index.php?lang=en_GB&word1=Batman&word2=Superman</a>. Mitkä tai mikä ovat/on osoitteen:</p>

                    <ul>
                        <li>protokolla</li>
                        <li>isäntäkone</li>
                        <li>portti</li>
                        <li>polku</li>
                        <li>kohdedokumentti</li>
                        <li>kyselyparametrit</li>
                        <li>ankkuri</li>
                    </ul>

                    <p>Mitkä näistä puuttuvat?</p>
                </aside>


                <h2>HTTP</h2>

                <p>HTTP (<em>HyperText Transfer Protocol</em>) on TCP/IP -protokollapinon sovellustason protokolla, jota web-palvelimet ja selaimet käyttävät kommunikointiin. HTTP-protokolla perustuu asiakas-palvelin malliin, jossa jokaista pyyntöä kohden on yksi vastaus (<em>request-response paradigm</em>). Käytännössä HTTP-asiakasohjelma (jatkossa selain) lähettää HTTP-viestin HTTP-palvelimelle (jatkossa palvelin), joka palauttaa HTTP-vastauksen. HTTP-protokollan versio 1.1 on määritelty <a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html" target="_blank">RFC 2616</a>-spesifikaatiossa.</p>

                <h5>Asiakas-palvelin malli</h5>

                <p>Asiakas-palvelin -mallissa <em>(Client-Server model)</em> asiakkaat käyttävät palvelimen tarjoamia palveluja. Kommunikointi asiakkaan ja palvelimen välillä tapahtuu usein verkon yli siten, että asiakasohjelmisto ja palvelinohjelmisto sijaitsevat erillisissä fyysisissä sijainneissa (eri tietokoneilla). Palvelinohjelmisto tarjoaa yhden tai useamman palvelun, joita asiakasohjelmisto käyttää.</p>

                <p>Käytännössä asiakasohjelmisto tarjoaa käyttöliittymän ohjelmiston käyttäjälle. Asiakasohjelmiston käyttäjän ei tarvitse tietää, että kaikki käytetty tieto ei ole hänen koneella. Käyttäjän tehdessä toiminnon asiakasohjelmisto pyytää tarpeen vaatiessa palvelimelta käyttäjän tarpeeseen liittyvää lisätietoa. Tyypillistä mallille on se, että palvelin tarjoaa vain asiakkaan pyytämät tiedot ja verkossa liikkuvan tiedon määrä pidetään vähäisenä.</p>

                <p>Asiakas-palvelin -malli mahdollistaa hajautetut ohjelmistot: asiakasohjelmistoa käyttävät loppukäyttäjät voivat sijaita eri puolilla maapalloa palvelinohjelmiston sijaitessa tietyssä paikassa.</p>


                <aside class="pohdi">
                    <h1>Chuck Norris</h1>

                    <p>Selaa osoitteeseen <a href="http://www.imdb.com" target="_blank">http://www.imdb.com</a>. Kirjoita sivuston ylälaidassa olevaan kenttään "Chuck Norris" ja paina Enter. Mitkä seuraavista askeleista tapahtuivat asiakasohjelmistossa, mitkä palvelinohjelmistossa, mitkä muualla? Voit olettaa että asiakasohjelmistolla tarkoitetaan käyttämääsi web-selainta.</p>

                    <ol>
                        <li>Näppäimistön avulla kirjoittamasi osoitetekstin näyttäminen.</li>
                        <li>Osoitetta http://www.imdb.com vastaavan IP-osoitteen etsiminen.</li>
                        <li>Sivun http://www.imdb.com näyttäminen.</li>
                        <li><span title="YOU CAN'T FIND CHUCK NORRIS, CHUCK NORRIS FINDS YOU">Chuck Norriksen etsiminen.</span></li>
                    </ol>
                </aside>

                <p>Haasteena perinteisessä asiakas-palvelin mallissa on se, että palvelin sijaitsee yleensä tietyssä keskitetyssä sijainnissa. Keskitetyillä palveluilla on mahdollisuus ylikuormittua asiakasmäärän kasvaessa. Kapasiteettia rajoittavat muun muassa palvelimen fyysinen kapasiteetti (rauta), palvelimeen yhteydessä olevan verkon laatu ja nopeus, sekä tarjotun palvelun tyyppi. Esimerkiksi pyynnöt, jotka johtavat tiedon tallentamiseen, vievät tyypillisesti enemmän resursseja kuin pyynnöt, jotka tarvitsevat vain staattista sisältöä.</p>


                <h3>HTTP-viestin rakenne: palvelimelle lähetettävä kysely</h3>

                <p>HTTP-protokollan yli lähetettävät viestit ovat tekstimuotoisia. Viestit koostuvat riveistä jotka muodostavat otsakkeen, sekä riveistä jotka muodostavat viestin rungon. Viestin runkoa ei ole pakko olla olemassa. Viestin loppuminen ilmoitetaan kahdella peräkkäisellä rivinvaihdolla.</p>

                <p>Palvelimelle lähetettävän viestin, eli kyselyn, ensimmäisellä rivillä on pyyntötapa, halutun resurssin polku ja HTTP-protokollan versionumero.</p>

                <pre>
PYYNTÖTAPA /POLKU_HALUTTUUN_RESURSSIIN HTTP/versio
otsake-1: arvo
otsake-2: arvo

valinnainen viestin runko</pre>

                <p>Pyyntötapa ilmaisee HTTP-protokollassa käytettävän pyynnön tavan (esim. <code>GET</code> tai <code>POST</code>), polku haluttuun resurssiin kertoo haettavan resurssin sijainnin palvelimella (esim. <code>/index.html</code>), ja HTTP-versio kertoo käytettävän version (esim. <code>HTTP/1.0</code>). Alla esimerkki hyvin yksinkertaisesta -- joskin yleisestä -- pyynnöstä. Huomaa että pyyntöä tehdessä yhteys palvelimeen on jo muodostettu, eli palvelimen osoitetta ei merkitä erikseen.</p>

                <pre>
GET /index.html HTTP/1.0</pre>

                <p>Yksittäisen koneen dedikointi web-palvelimeksi jättää usein huomattavan osan koneen kapasiteetista käyttämättä. Nykyään yleisesti käytössä oleva HTTP/1.1 -protokolla mahdollistaa useamman palvelimen pitämisen samassa IP-osoitteessa virtuaalipalvelintekniikan avulla, jolloin yksittäiset palvelinkoneet voivat sisältää useita palvelimia. Käytännössä IP-osoitetta kuunteleva kone voi joko itsessään sisältää useita ohjelmistoilla emuloituja palvelimia, tai se voi toimia reitittimenä ja ohjata pyynnön tietylle esimerkiksi yrityksen sisäverkossa sijaitsevalle koneelle. Kun yksittäinen IP-osoite voi sisältää useampia palvelimia, pelkkä polku haluttuun resurssiin ei riitä oikean resurssin löytämiseen: resurssi voisi olla millä tahansa koneeseen liittyvällä virtuaalipalvelimella. HTTP/1.1 -protokollassa on pyynnöissä pakko olla mukana käytetyn palvelimen osoitteen kertova <code>Host</code>-otsake.</p>

                <pre>
GET /index.html HTTP/1.1
Host: www.munpalvelin.net</pre>

                <h3>HTTP-viestin rakenne: palvelimelta saapuva vastaus</h3>

                <p>Palvelimelle tehtyyn pyyntöön saadaan aina jonkinlainen vastaus. Jos tekstimuotoiseen osoitteeseen ei ole liitetty IP-osoitetta DNS-palvelimilla, selain ilmoittaa ettei palvelinta löydy. Jos palvelin löytyy, ja pyyntö saadaan tehtyä palvelimelle asti, tulee palvelimen myös vastata jollain tavalla.</p>

                <p>Palvelimelta saatavan vastauksen sisältö on seuraavanlainen. Ensimmäisellä rivillä HTTP-protokollan versio, viestiin liittyvä statuskoodi, sekä statuskoodin selvennys. Tämän jälkeen on joukko otsakkeita, tyhjä rivi, ja mahdollinen vastausrunko. Vastausrunko ei ole pakollinen.</p>

                <pre>
HTTP/versio statuskoodi selvennys
otsake-1: arvo
otsake-2: arvo

valinnainen vastauksen runko
                </pre>

                <p>Esimerkiksi:</p>

                <pre>
HTTP/1.1 200 OK
Date: Mon, 01 Sep 2014 03:12:45 GMT
Server: Apache/2.2.14 (Ubuntu)
Vary: Accept-Encoding
Content-Length: 973
Connection: close
Content-Type: text/html;charset=UTF-8

.. runko ..</pre>

                <p>Kun palvelin vastaanottaa tiettyyn resurssiin liittyvän pyynnön, tekee se resurssiin mahdollisesti liittyviä toimintoja ja palauttaa lopulta vastauksen. Kun selain saa vastauksen, tarkistaa se vastaukseen liittyvän <a href="http://httpcats.herokuapp.com/" target="_blank">statuskoodin</a> ja siihen liittyvät tiedot. Tämän jälkeen selain päättelee, mitä vastauksella tehdään, ja esimerkiksi tuottaa vastaukseen liittyvän web-sivun käyttäjälle.</p>

                <aside class="extra">
                    <p><strong>Google Dev Tools</strong></p>

                    <p>Google Chromen DevTools-apuvälineet löytää Tools-valikosta tai painamalla F12 (Linux). Apuvälineillä voi esimerkiksi tarkastella verkkoliikennettä ja lähetettyjä ja vastaanotettuja paketteja. Valitsemalla työvälineistä Network-välilehden, ja lataamalla sivun uudestaan, näet kaikki sivua varten ladattavat osat sekä kunkin osan lataamiseen kuluneen ajan.</p>

                </aside>

                <h3>Statuskoodit</h3>

                <p>Statuskoodit (<em>status code</em>) kuvaavat palvelimella tapahtunutta toimintaa kolmella numerolla. Statuskoodien avulla palvelin kertoo mahdollisista ongelmista tai tarvittavista lisätoimenpiteistä. Yleisin statuskoodi on <code>200</code>, joka kertoo kaiken onnistuneen oikein. HTTP/1.1 sisältää viisi kategoriaa vastausviesteihin.</p>

                <ul>
                    <li>1**: informaatioviestit (esim 100 "Continue")</li>
                    <li>2**: onnistuneet tapahtumat (esim 200 "OK")</li>
                    <li>3**: asiakasohjelmistolta tarvitaan lisätoimintoja (esim 301 "Moved Permanently" tai 304 "Not Modified" eli hae välimuistista)</li>
                    <li>4**: virhe pyynnössä tai erikoistilanne (esim 401 "Not Authorized" ja 404 "Not Found")</li>
                    <li>5**: virhe palvelimella (esim 500 "Internal Server Error")</li>
                </ul>

                <p>Humoristisia kuvia statuskoodeista löytyy osoitteesta <a href="http://httpcats.herokuapp.com" target="_blank">http://httpcats.herokuapp.com</a>.</p>


                <aside class="extra">
                    <h1>HTTP-liikenteen testaaminen telnet-työvälineellä</h1>

                    <p>Linux-ympäristöissä on käytössä telnet-työkalu, jota voi käyttää yksinkertaisena asiakasohjelmistona pyyntöjen simulointiin. Telnet-yhteyden tietyn koneen tiettyyn porttiin saa luotua komennolla <code>telnet isäntäkone portti</code>. Esimerkiksi TKTL:n www-palvelimelle saa yhteyden seuraavasti:</p>

                    <pre>
$ telnet cs.helsinki.fi 80
                    </pre>

                    <p>Tätä seuraa telnetin infoa yhteyden muodostamisesta, jonka jälkeen pääsee kirjoittamaan pyynnön.</p>

                    <pre>
Trying 128.214.166.78...
Connected to cs.helsinki.fi.
Escape character is '^]'.

                    </pre>

                    <p>Yritetään pyytää HTTP/1.1 -protokollalla juuridokumenttia. Huom! HTTP/1.1 -protokollassa tulee pyyntöön lisätä aina Host-otsake. Jos yhteys katkaistaan ennen kuin olet saanut kirjoitettua viestisi loppuun, ota apuusi tekstieditori ja copy-paste. Muistathan myös että viesti lopetetaan aina kahdella rivinvaihdolla.</p>

                    <pre>
GET / HTTP/1.1
Host: cs.helsinki.fi

                    </pre>

                    <p>Palvelin lähettää meille vastauksen, jossa on statuskoodi ja otsakkeita sekä dokumentin runko.</p>

                    <pre>
HTTP/1.1 302 Found
Date: Mon, 02 Sep 2013 18:31:30 GMT
Server: Apache/2.2.14 (Ubuntu)
Location: http://www.cs.helsinki.fi/
Vary: Accept-Encoding
Content-Length: 290
Content-Type: text/html; charset=iso-8859-1

&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;
&lt;html&gt;&lt;head&gt;
&lt;title&gt;302 Found&lt;/title&gt;
&lt;/head&gt;&lt;body&gt;
&lt;h1&gt;Found&lt;/h1&gt;
&lt;p&gt;The document has moved &lt;a href="http://www.cs.helsinki.fi/"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;address&gt;Apache/2.2.14 (Ubuntu) Server at cs.helsinki.fi Port 80&lt;/address&gt;
&lt;/body&gt;&lt;/html&gt;
                    </pre>

                    <p>Juuripolkua palvelimelta <code>cs.helsinki.fi</code> haettaessa palvelin vastaa että dokumentti on löytynyt (<code>302 Found</code>), mutta se sijaitsee muualla (<code>Location: http://www.cs.helsinki.fi/</code>).</p>

                </aside>

                <aside class="pohdi">
                    <h1>Kuinka monta hyppyä?</h1>

                    <p>Käytä telnetiä ja aloita osoitteesta <code>cs.helsinki.fi</code>, tavoitteenasi on päästä laitoksen etusivulle <code>http://www.cs.helsinki.fi/home/</code>. Kuinka monta uudelleenohjausta saat ennenkuin pääset etusivulle?</p>

                    <p>Jos et ehdi kirjoittamaan komentoa telnet-ikkunaan, voit ensin kirjoittaa sen esimerkiksi tekstieditoriin, ja kopioida sen sieltä telnet-ikkunaan.</p>

                </aside>

                <h3>HTTP-protokollan pyyntötavat</h3>

                <p>HTTP-protokolla määrittelee kahdeksan erillistä pyyntötapaa (Request method), joista yleisimmin käytettyjä ovat <code>GET</code> ja <code>POST</code>. Pyyntötavat määrittelevät rajoitteita ja suosituksia viestin rakenteeseen ja niiden prosessointiin palvelinpäässä. Esimerkiksi <a href="http://jcp.org/aboutJava/communityprocess/mrel/jsr154/index2.html" target="_blank">Java Servlet API (versio 2.5)</a> sisältää seuraavan suosituksen GET-pyyntotapaan liittyen:</p>

                <p><em>The GET method should be safe, that is, without any side effects for which users are held responsible. For example, most form queries have no side effects. If a client request is intended to change stored data, the request should use some other HTTP method.</em></p>

                <p>Suomeksi yksinkertaistaen: Palvelinpuolen toiminnallisuutta suunniteltaessa kannattaa pyrkiä tilanteeseen, missä <code>GET</code>-tyyppisillä pyynnöillä ei voida muuttaa palvelimella olevaa dataa.</p>

                <h4>GET</h4>

                <p>GET-pyyntötapaa käytetään esimerkiksi dokumenttien hakemiseen: kun kirjoitat osoitteen selaimen osoitekenttään ja painat enter, selain tekee GET-pyynnön. GET-pyynnöt eivät tarvitse otsaketietoja HTTP/1.1:n vaatiman Host-otsakkeen lisäksi. Mahdolliset kyselyparametrit lähetetään palvelimelle osana haettavaa osoitetta.</p>

                <pre>
GET /sivu.html?porkkana=1 HTTP/1.1
Host: palvelimen-osoite.net

                </pre>

                <h4>POST</h4>

                <p>Käytännön ero POST- ja GET-kyselyn välillä on se, että POST-tyyppisillä pyynnoillä kyselyparametrit liitetään pyynnön runkoon. Rungon sisältö ja koko määritellään otsakeosiossa. POST-kyselyt mahdollistavat multimedian (kuvat, videot, musiikki, ...) lähettämisen palvelimelle.</p>

                <pre>
POST /sivu.html HTTP/1.1
Host: palvelimen-osoite.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

porkkana=1
                </pre>

                <h2>HTML</h2>

                <p><em>"In '93 to '94, every browser had its own flavor of HTML. So it was very difficult to know what you could put in a Web page and reliably have most of your readership see it."</em> -- Tim Berners-Lee</p>

                <p>HTML on rakenteellinen kuvauskieli, jolla voidaan esittää linkkejä sisältävää tekstiä sekä tekstin rakennetta. HTML koostuu elementeistä, jotka voivat olla sisäkkäin ja peräkkäin. Elementtejä käytetään ohjeina dokumentin jäsentämiseen ja käyttäjälle näyttämiseen. HTML-dokumenteissa elementit avataan elementin nimen sisältävällä pienempi kuin -merkillä (&lt;) alkavalla ja suurempi kuin -merkkiin (&gt;) loppuvalla merkkijonolla (&lt;elementin_nimi&gt;), ja suljetaan merkkijonolla jossa elementin pienempi kuin -merkin jälkeen on vinoviiva (&lt;/elementin_nimi&gt;).</p>

                <p>HTML-dokumentin rakennetta voi ajatella myös puuna. Juurisolmuna on elementti <code>&lt;html&gt;</code>, jonka lapsina ovat elementit <code>&lt;head&gt;</code> ja <code>&lt;body&gt;</code>.</p>

                <p>Jos elementin sisällä ei ole muita elementtejä tai tekstisolmuja eli tekstiä, voi elementin yleensä avata ja sulkea samalla merkkijonolla: (&lt;elementin_nimi /&gt;).</p>

                <p>HTML:stä on useita erilaisia standardeja, joista viimeisin julkaistu versio on <a href="http://www.w3.org/TR/html5/" target="_blank">HTML5</a> -- myös versio <a href="http://www.w3.org/TR/html51/" target="_blank">5.1</a> työstetään tällä hetkellä (päivitetty 28.8.2015).</p>

                <pre class="sh_xml">
&lt;!DOCTYPE html&gt;
&lt;html lang="fi"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;title&gt;selainikkunassa näkyvä otsikko&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Tekstiä tekstielementin sisällä, tekstielementti runkoelementin sisällä,
       runkoelementti html-elementin sisällä. Elementin sisältö voidaan asettaa
       useammalle riville.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>

                <p>Ylläoleva HTML5-dokumentti sisältää dokumentin tyypin ilmaisevan aloitustägin (<code>&lt;!DOCTYPE html&gt;</code>), dokumentin aloittavan html-elementin (<code>&lt;html&gt;</code>), otsake-elementin ja sivun otsikon (<code>&lt;head&gt;</code>, jonka sisällä <code>&lt;title&gt;</code>), sekä runkoelementin (<code>&lt;body&gt;</code>).</p>

                <p>Elementit voivat sisältää attribuutteja ja attribuuteille voi antaa arvoja. Esimerkiksi ylläolevassa esimerkissä html-elementille on määritelty erillinen attribuutti <em>lang</em>, joka kertoo dokumentissa käytetystä kielestä.  Ylläolevan esimerkin otsakkeessa on myös metaelementti, jota käytetään lisävinkin antamiseen selaimelle: "dokumentissa käytetään UTF-8 merkistöä". Tämä kannattaa olla dokumenteissa aina.</p>

                <p>Nykyaikaiset web-sivut sisältävät paljon muutakin kuin sarjan HTML-elementtejä. Linkitetyt resurssit, kuten kuvat ja tyylitiedostot, ovat oleellisia sivun ulkoasun ja rakenteen luomisessa. Selainpuolella suoritettavat skriptitiedostot, erityisesti Javascript, ovat luoneet huomattavan määrän syvyyttä nykyaikaiseen web-kokemukseen. Tällä kurssilla emme juurikaan syvenny selainpuolen toiminnallisuuteen.</p>



		<h1>Ensimmäinen palvelinohjelmisto</h1>


                <p>Tutustutaan tässä osiossa yksinkertaisten web-palvelinohjelmistojen rakenteeseen, sekä niiden toteuttamiseen <a href="http://www.spring.io" target="_blank">Spring</a>-sovelluskehyksen <a href="http://projects.spring.io/spring-boot/" target="_blank">Spring Boot</a>-projektilla. Spring on sovelluskehys, joka tarjoaa komponentteja sovellusten toteuttamiseen ja testaamiseen, ja Spring Boot -projekti tarjoaa näistä komponenteista koostuvia valmiita aloituspaketteja.</p>


                <h2>Hello World!</h2>

                <p>Tutustutaan "Hello World!"-tyyppisen web-sovelluksen toteuttamiseen Springin avulla. Oletetaan, että käytössämme on osoitteesta <a href="http://start.spring.io/" target="_blank">start.spring.io</a> ladattu Web-projektirunko (ruksaa Web-listan komponentti Web), jonka kansiorakenne on oletuksena seuraavankaltainen:</p>

                <pre>
├── pom.xml
└── src
    ├── main
    │   ├── java
    │   │   └── demo
    │   │       └── DemoApplication.java
    │   └── resources
    │       ├── application.properties
    │       ├── static
    │       └── templates
    └── test
        └── java
            └── demo
                └── DemoApplicationTests.java</pre>


                <h3>Kontrolleriluokka, pyynnön vastaanottaminen ja pyynnön käsittelevä metodi</h3>


                <p>Lisää kansioon <code>src/main/java/demo</code> luokka <code>HelloController</code>. Kontrollerit (<em>Controller</em>) ovat palvelinohjelmistoissa luokkia, joissa oleviin metodeihin palvelin ohjaa käyttäjän tekemiä pyyntöjä. Spring löytää kontrolleriluokkamme jos luokalle on lisätty <em>annotaatio</em> <code>@Controller</code>. Lisätään luokalle lisäksi annotaatio <code>@ResponseBody</code>, joka kertoo, että metodien palauttamat arvot lähetetään sellaisenaan takaisin pyynnön tehneelle selaimelle. Kontrolleriluokkamme runko on seuraavanlainen.</p>

<pre class="sh_java">
package demo;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
@ResponseBody
public class HelloController {

}</pre>

                <p>Pyynnöt käsitellään kontrolleriluokissa olevien metodien avulla. Jotta Spring osaa valita oikean metodin, tulee metodeille lisäksi kertoa <em>polku</em>, mitä ne kuuntelevat. Polku kerrotaan metodille määriteltävällä <code>@RequestMapping</code>-annotaatiolla. Metodi, jolla on annotaatio <code>@RequestMapping("*")</code> kuuntelisi kaikkia palvelinohjelmistoon liittyviä polkuja, kun taas annotaatiolla <code>@RequestMapping("/hello")</code> metodi kuuntelisi vain ohjelmiston polkuun <code>/hello</code> tulevia pyyntöjä. Luodaan kontrolleri, joka palauttaa selaimelle tekstin <code>"Hello!"</code> riippumatta siitä, mihin polkuun pyyntö tulee.</p>

		<pre class="sh_java">
package demo;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
@ResponseBody
public class HelloController {

    @RequestMapping("*")
    public String hello() {
        return "Hello!";
    }
}</pre>

	

                <h3>Sovelluksen käynnistäminen komentoriviltä</h3>

                <p>Sovelluksen käynnistäminen onnistuu suorittamalla projektijuuressa (hakemisto, missä on tiedosto pom.xml) komento <code>mvn spring-boot:run</code>. Käytännössä komento käynnistää projektissa mukana olevan palvelimen, ja asentaa siihen kehittämämme sovelluksen.</p>

                <p>Kun sovellus käynnistetään, siihen liittyvä palvelin käynnistyy oletuksena osoitteeseen <code>http://localhost:8080</code>. Voit tarkastella sovelluksen toimintaa web-selaimella. </p>


		<h3>Sovelluksen käynnistämisestä ja pakkauksista</h3>
		
		<p>Esimerkkipohjan mukana tuleva Spring-sovellus käynnistyy luokan <code>DemoApplication</code> kautta.</p>
		
		<pre class="sh_java">package demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}</pre>
		
		<p>Luokassa oleva annotaatio <code>@SpringBootApplication</code> pyytää sovellusta muunmuassa etsimään oleellisia luokkia projektista. Oletuksena luokkien tulee olla pakkauksen <code>demo</code> sisällä, tai sen alipakkauksissa kuten <code>demo.controller</code>. Käytämme kurssilla tehtävissä usein juuripakkauksen nimenä termiä <code>wad</code>, joka on kurssia varten keksitty lyhenne sanoista Web Application Development.</p>

		<p>Materiaalin esimerkeissä käytetty pakkausnimentä vaihtelee ajoittain.</p>
		

                <hr/>

                <div class="tehtavat">

                    <p>Tästä eteenpäin materiaalissa on myös ohjelmointitehtäviä. Tehtävien tekeminen ja palautus tapahtuu NetBeans-ympäristössä Test My Code-liitännäisen avulla. Test My Code lataa tehtäväpohjat sinulle valmiiksi, eli et tarvitse <code>start.spring.io</code>-osoitteen projektipohjia tehtävien tekemiseen. Muistathan palauttaa jokaisen tehtävän (<em>submit solution</em>). Tehtävät avataan tehtävän otsikkoa klikkaamalla.</p>
		    
                    <div class="tehtava" id="t-helloweb-ex">

                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-helloweb">
                                    Hello World!
                                </a>
                            </h1>
                        </header>

                        <div id="t-helloweb" class="collapse">

                            <p>Kuten huomattava osa ohjelmointikursseista, tämäkin kurssi alkaa tehtävällä, jossa toteutettava ohjelma kirjoittaa tekstin <code>Hello World!</code>.</p>

                            <p>Toteuta pakkauksessa <code>wad.controller</code> olevaan luokkaan <code>HelloWorldController</code> kontrollerimetodi, joka kuuntelee kaikkia osoitteita. Kun palvelin vastaanottaa pyynnön, tulee palvelimen palauttaa merkkijono "Hello World!".</p>

                            <p>Käynnistä palvelin painamalla NetBeansin play-nappia tai suorittamalla <code>Application</code>-luokan <code>main</code>-metodi. Avaa nettiselain, mene osoitteeseen <a href="http://localhost:8080/" target="_blank">http://localhost:8080/</a>, ja näet selaimessasi tekstin "Hello World!".</p>

                            <p><img class="browser-img" src="img/exercises/w1e01.png"/></p>

                            <p>Palvelin sammutetaan NetBeansissa punaista nappia painamalla -- vain yksi sovellus voi olla kerrallaan päällä samassa osoitteessa. Palauta tehtävä lopuksi Test My Code:n submit-napilla.</p>
                        </div>
                    </div>

                    <div class="tehtava" id="t-vieraslaskuri">

                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-vieraslaskuri">
                                    Vieraslaskuri
                                </a>
                            </h1>
                        </header>
                        <div id="t-vieraslaskuri" class="collapse">
                            <p>Vieraslaskuri kertoo kävijälle kuinka monta kävijää sivulla on käynyt tähän mennessä. Ensimmäinen kävijä näkee luvun 1, toinen kävijä luvun 2, jne.</p>

                            <p>Toteuta pakkauksessa <code>wad.controller</code> olevaan luokkaan <code>VisitCountController</code> polkua <code>/visits</code> kuunteleva metodi, joka toteuttaa toivotun toiminnallisuuden. Vinkki! Kontrolleriluokka luodaan vain kerran palvelimen käynnistyksen yhteydessä, joten voinet hyödyntää jotain sopivaa oliomuuttujaa.</p>

                            <p>Testaa sovellustasi. Ensimmäisellä pyynnöllä osoitteeseen <code>http://localhost:8080/visits</code> sinun pitäisi nähdä numero 1, toisella pyynnöllä numero 2 jne. Kun käynnistät palvelimen uudelleen, laskuri alkaa taas yhdestä.</p>
                        </div>
                    </div>
                </div>



                <h2>Pyynnön parametrit</h2>

                <p>Kun käyttäjä avaa osoitteen web-selaimella, selain tekee GET-tyyppisen pyynnön palvelimelle. Pyynnön mukana voi kulkea parametreja, jotka lisätään haettavan osoitteen perään. Esimerkiksi, osoitteessa <code>http://localhost:8080/autot?numero=95&amp;nimi=salama</code> on kaksi parametria. Parametrin <code>numero</code> arvo on <code>95</code> ja parametrin <code>nimi</code> arvo on <code>salama</code>. Parametrit erotetaan toisistaan <code>&amp;</code>-merkillä.</p>

                <p>Kontrollerimetodit voivat vastaanottaa näitä pyyntöjä määrittelemällä pyynnön vastaanottavalle metodille parametreja. Seuraava osoitetta <code>/tervehdi</code>-kuunteleva kontrollerimetodi olettaa, että pyynnön mukana tulee parametri <code>nimi</code>, ja palauttaa viestin "Hei ", jonka perään on liitetty parametrina saatu arvo.</p>

                <pre class="sh_java">
package demo;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
@ResponseBody
public class HelloController {

    @RequestMapping("/tervehdi")
    public String hello(@RequestParam String nimi) {
        return "Hei " + nimi;
    }
}</pre>

                <p>Jos ylläolevan sovelluksen käynnistää, ja hakee selaimella osoitetta <code>http://localhost:8080/tervehdi?nimi=Winnetou</code> -- olettaen että sovellus on käynnistetty omalla koneella -- käyttäjä näkee tekstin <code>Hei Winnetou</code>. Käytännössä osoitteessa oleva parametrin nimi kytketään automaattisesti metodissa käytettävään muuttujan nimeen.</p>

                <p>Kuten <code>@RequestMapping</code>-annotaatiolle, myös <code>@RequestParam</code>-annotaatiolle voi antaa toimintaa tarkentavia parametreja. Parametrit <code>required</code> ja <code>defaultValue</code> ovat molemmat hyödyllisiä; ensimmäisellä määritellään että tuleeko parametrin olla pyynnössä, ja toisella määritellään parametrin oletusarvo jos parametria ei ole.</p>

                <p>Seuraavassa esimerkissä todetaan, että pyynnön ei tarvitse sisältää parametria <code>sijainti</code>, ja että parametriin asetetaan oletuksena arvo "Kumpula".</p>

                <pre class="sh_java">
    @RequestMapping("/sijainti")
    public String etsi(@RequestParam(required=false, defaultValue="Kumpula") String sijainti) {
        return "Haetaan " + sijainti;
    }</pre>

                <p>Käytännössä jos selain tekee pyynnön osoitteeseen <code>http://localhost:8080/sijainti</code>, palauttaa palvelin merkkijonon "Haetaan Kumpula".</p>

                <p>Parametreja voi olla pyynnössä myös useampia. Seuraavassa esimerkissä metodi osaa käsitellä sekä <code>sijainti</code> että <code>vuosi</code> -nimiset parametrit. Huomaa, että oletusarvot asetetaan aina merkkijonona.</p>

                <pre class="sh_java">
    @RequestMapping("/sijainti")
    public String etsi(@RequestParam(required=false, defaultValue="Kumpula") String sijainti,
                       @RequestParam(required=false, defaultValue="1970") Integer vuosi) {
        return "Haetaan " + sijainti + " vuonna " + vuosi;
    }</pre>



                <p>Käytämme viittaustyyppisiä muuttujia (esim. <code>Integer</code>) myös tapauksissa, joissa alkeistyyppisen muuttujan (esim. <code>int</code>) käyttö olisi periaatteessa mahdollista. Tällä ohjelmointityylillä vältämme ongelmia, joita ilmenee kun sovelluskehys yrittää asettaa puuttuvaa parametrin arvoa (oletuksena <code>null</code>) alkeistyyppiseen muuttujaan (kokeile mitä tapahtuu jos koodissasi on komennot <code>Integer arvo = null; int a = arvo;</code>).</p>


                <div class="tehtavat">

                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-kaikupalvelu">
                                    Papukaija Bob
                                </a>
                            </h1>
                        </header>
                        <div id="t-kaikupalvelu" class="collapse">
                            <p>Papukaija <a href="https://www.youtube.com/watch?v=6NG37huf2dU" target="_blank">Bob</a> on netti-ilmiö, joka on oppinut sanoja, joita se toistaa. Tässä tehdään Bobille vastine, joka osaa toistaa sille sanottavia asioita.</p>

                            <p>Toteuta luokkaan <code>ParrotController</code> kontrollerimetodi, joka kuuntelee pyyntöjä <code>/bob</code>-osoitteessa. Jos pyynnön mukana ei ole <code>message</code>-nimistä parametria, on vastaus <code>"Krraaa"</code>. Muuten, vastaus on <code>"Krraaa"</code>, jota seuraa välilyönti ja <code>message</code>-parametrin arvo.</p>

                            <p>Kun testaat sovellusta, pyyntö osoitteeseen <code>http://localhost:8080/bob</code> näyttää sivun, jossa on merkkijono <code>"Krraaa"</code>, kun taas esimerkiksi pyyntö <code>http://localhost:8080/bob?message=keksii</code> palauttaa merkkijonon <code>"Krraaa keksii"</code>.</p>
                        </div>
                    </div>
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-laskin">
                                    Laskin
                                </a>
                            </h1>
                        </header>
                        <div id="t-laskin" class="collapse">

                            <p>Toteuta luokkaan <code>CalculatorController</code> kontrollerimetodi, joka kuuntelee pyyntöjä <code>/calculate</code>-osoitteessa. Pyynnön mukana voi olla kolme parametria. Parametri <code>"op"</code> kertoo laskuoperaation, <code>"first"</code> kertoo ensimmäisen laskettavan luvun, ja <code>"second"</code> kertoo toisen laskettavan luvun.</p>

                            <p>Jos parametria <code>"op"</code> ei ole pyynnössä mukana, tulee sen saada oletusarvoksi <code>"plus"</code>. Jos parametri <code>"first"</code> puuttuu, saa se oletuksena arvon 0. Myös parametri <code>"second"</code> saa puuttuessaan arvon 0.</p>

                            <p>Laskimen tulee toteuttaa seuraavat operaatiot:</p>

                            <ul>
                                <li>Kun operaatio (op) on <code>"plus"</code> laskin palauttaa lukujen <code>"first"</code> ja <code>"second"</code> summan. Esim. pyyntö osoitteeseen <code>http://localhost:8080/calculate?op=plus&first=3&second=1</code> palauttaa arvon <code>4</code>.</li>
                                <li>Kun operaatio (op) on <code>"minus"</code> laskin palauttaa lukujen <code>"first"</code> ja <code>"second"</code> erotuksen. Esim. pyyntö osoitteeseen <code>http://localhost:8080/calculate?op=minus&first=7&second=2</code> palauttaa arvon <code>5</code>.</li>
                                <li>Kun operaatio (op) on <code>"multiply"</code> laskin palauttaa lukujen <code>"first"</code> ja <code>"second"</code> tulon. Esim. pyyntö osoitteeseen <code>http://localhost:8080/calculate?op=multiply&first=11&second=3</code> palauttaa arvon <code>33</code>.</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <h2>Näkymät ja data</h2>

                <p>Aiemmat sovelluksemme ovat vastaanottaneet tiettyyn osoitteeseen tulevan pyynnön ja palauttaneet käyttäjälle esimerkiksi merkkijonomuodossa olevaa dataa. Tämä ei kuitenkaan ole ainoa palvelinohjelmistojen toimintatyyppi, vaan palvelin voi myös luoda käyttäjälle näkymän, jonka selain lopulta näyttää käyttäjälle. Näkymät luodaan tyypillisesti HTML-kielellä siten, että HTML-kielen sekaan on upotettu komentoja, joiden perusteella näkymään lisätään palvelimen tuottamaa tietoa.</p>



                <h3>Näkymän luominen: Thymeleaf</h3>

                <p>Eräs apuväline näkymän luomiseen on <a href="http://www.thymeleaf.org/" target="_blank">Thymeleaf</a>-templatemoottori, joka tarjoaa välineitä datan lisäämiseen HTML-sivuille. Käytännössä luomme näkymät ensin HTML-sivuina, jonka jälkeen sivuihin lisätään komentoja Thymeleafin käsiteltäväksi.</p>

                <p>Esimerkiksi, kun allaolevaa HTML-sivua käsitellään palvelimella, siinä olevan elementin <code>&lt;span th:text="${viesti}"&gt;hello world!&lt;/span&gt;</code> sisältö vaihdetaan palvelimella pyyntöön lisättyyn muuttujaan <code>viesti</code>.</p>

                <pre class="sh_xml">
&lt;!DOCTYPE html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;title&gt;selainikkunassa näkyvä otsikko&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Tekstiä tekstielementin sisällä, tekstielementti runkoelementin sisällä,
       runkoelementti html-elementin sisällä. Elementin sisältö voidaan asettaa
       useammalle riville.&lt;/p&gt;

    &lt;p&gt;palvelimelta saatu teksti: &lt;span th:text="${viesti}"&gt;hello world!&lt;/span&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>

                <p>Thymeleaf-sivut eroavat HTML-sivuista siinä, että niillä on <code>html</code>-määrittelyssä <code>xml</code>-nimiavaruuden <code>th</code>-määrittely, jonka avulla komennot kuten <code>th:text</code> tunnistetaan.</p>

                <p>Thymeleaf-sivut ("templatet") sijaitsevat tällä kurssilla projektin kansiossa <code>src/main/resources/templates</code> tai sen alla olevissa kansioissa. NetBeansissa kansio löytyy kun klikataan "Other Sources"-kansiota.</p>

		<aside class="info">
		  <br/>
		  <h1>Thymeleafin käyttöönotto</h1>

                  <p>Thymeleafin käyttöönotto vaatii <code>pom.xml</code>-tiedostossa olevien riippuvuuksien muokkaamista. Spring-sovelluskehyksen perusweb-toiminnallisuus on tuotu käyttöömme riippuvuudella</p>

                <pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>

		<p>Vaihtamalla ylläoleva riippuvuus allaolevaan muotoon, otamme Thymeleafin käyttöön.</p>

                <pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>

		<p>Joudumme myös hakemaan projektin riippuuvuuksia. Tämä onnistuu joko kirjoittamalla komentorivillä projektin juuressa komento <code>mvn dependency:resolve</code> tai valitsemalle NetBeansissa projektiin liittyvä kansio <em>Dependencies</em> oikealla hiirennapilla, ja painamalla <em>Download Declared Dependencies</em>.</p>

		<p>tämän lisäksi, HTML-sivujen <code>html</code>-elementin määrittelyssä tulee olla seuraavat määrittelyt.</p>  

                <pre class="sh_xml">
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt;</pre>        

                <p>Thymeleaf etsii näkymiä oletuksena kansiosta <code>src/main/resources/templates</code>. Spring etsii kansiosta <code>src/main/resources</code> konfiguraatiotiedostoa <code>application.properties</code>, johon lisäämme seuraavat rivit.</p>

                <pre>
spring.thymeleaf.suffix=.html
spring.thymeleaf.cache=false</pre>

                <p>Yllä olevalla konfiguraatiolla määrittelemme, että näkymätiedostojen pääte on <code>.html</code>; sitä ei tarvitse erikseen kertoa kontrollerissa. Tämän lisäksi, rivi <code>spring.thymeleaf.cache=false</code> sanoo sovellukselle, että näkymiä ei tule ladata välimuistiin; tämän avulla näemme näkymiin tehtävät muutokset myös palvelimen ollessa käynnissä.</p>

                <p>Nyt jos palautamme kontrollerista esimerkiksi merkkijonon <code>messages</code>, Spring etsii sivun <code>src/main/resources/templates/messages.html</code>, pyytää Thymeleafia luomaan sen, ja palauttaa sen käyttäjälle.</p>

                <pre class="sh_java">
@RequestMapping(method = RequestMethod.GET)
public String view() {
    return "messages";
}</pre>        

		</aside>


                <h3>Näkymän löytäminen ja näyttäminen</h3>

                <p>Sovellukseen tulevat pyynnöt otetaan vastaan ensin Spring-sovelluskehyksen toimesta, jonka tehtävänä on ohjata pyynnöt sopiville kontrollerimetodeille. Nämä päätellään <code>@RequestMapping</code>-annotaatioista. Kontrollerimetodien vastuulla on sekä datan liittäminen pyyntöön että vastauksen ohjaaminen joko suoraan käyttäjälle tai komponentille, joka luo datan avulla näkymän (esim. Thymeleaf).</p>

		<p>Aiemmin kontrolleriluokissa käyttämämme annotaatio <code>@ResponseBody</code> on käytännössä tarkoittanut sitä, että metodin palauttama data palautetaan sellaisenaan käyttäjälle. Kun otamme sen pois, käyttämämme sovelluskehys yrittää etsiä palauttamamme merkkijonon perusteella näkymää, jonka voisi näyttää käyttäjälle.</p>

                <p>Palauttamalla kontrollerimetodista merkkijono, sovellus etsii merkkijonoon liittyvää näkymää. Esimerkiksi, jos metodi palauttaa arvon "index", hakee Spring --  Thymeleafia käytettäessä -- kansiosta <code>src/main/resources/templates/</code> tiedostoa <code>index.html</code> ja näyttää sen sisällön käyttäjälle.</p>  

                <pre class="sh_java">
package wad.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class HelloController {

    @RequestMapping("*")
    public String view() {
        return "index";
    }
}</pre>

                <h3>Tiedon lisääminen pyyntöön</h3>

                <p>Sivua ei lähetetä suoraan käyttäjälle, vaan se käsitellään ensin palvelinohjelmistossa. Sivulle voi lisätä tietoa ns. <em>Model</em>-olion avulla, jonka voimme määritellä kontrollerimetodeihin. Spring asettaa oliolle arvon automaattisesti pyynnön saapuessa. Seuraava koodi lisää pyynnössä olevalle Model-oliolle attribuutin <code>viesti</code>, jonka arvoksi asetetaan merkkijono "aikamoista.". Tämän jälkeen metori palauttaa merkkijonon, jonka perusteella etsitään näkymän määrittelevä tiedosto. Tämä tiedosto ja model-oliossa oleva data käsitellään Thymeleafin toimesta, ja lopulta valmis sivu palautetaan käyttäjälle.</p>

                <pre class="sh_java">
package wad.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class HelloController {

    @RequestMapping("*")
    public String view(Model model) {
        model.addAttribute("viesti", "aikamoista.");
        return "index";
    }
}</pre>

        
		<p>Näkymän luonnin yhteydessä data asetetaan määriteltyihin kohtiin ja Thymeleaf-projektiin liittyvät viitteet poistetaan. Jos sivu "index.html" olisi aiemmin materiaalissa näkemämme HTML-sivu, saisi käyttäjä lopulta seuraavalta näyttävän sivun.</p>


                <pre class="sh_xml">
&lt;!DOCTYPE html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;title&gt;selainikkunassa näkyvä otsikko&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Tekstiä tekstielementin sisällä, tekstielementti runkoelementin sisällä,
       runkoelementti html-elementin sisällä. Elementin sisältö voidaan asettaa
       useammalle riville.&lt;/p&gt;

    &lt;p&gt;palvelimelta saatu teksti: &lt;span&gt;aikamoista&lt;/span&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>     

	

                <p>Kontrollerimetodit voivat luonnollisesti sekä vastaanottaa pyynnön parametreja, että lisätä dataa Model-olioon. Allaolevassa esimerkissä metodi odottaa kahta parametria ja lisää niiden arvot model-oliolle näkymän luomista varten.</p>

                <pre class="sh_java">
    @RequestMapping("/sijainti")
    public String etsi(Model model,
                       @RequestParam(required=false, defaultValue="Kumpula") String sijainti,
                       @RequestParam(required=false, defaultValue="1970") Integer vuosi) {
        model.addAttribute("sijainti", sijainti);
        model.addAttribute("vuosi", vuosi);
        return "index";
    }</pre>

                <div class="tehtava">
                    <header>
                        <h1>
                            <a data-toggle="collapse" class="collapsed" href="#t-nakyma-ja-lomake">
                                Näkymä ja lomake
                            </a>
                        </h1>
                    </header>
                    <div id="t-nakyma-ja-lomake" class="collapse">
                        <p>Sovelluksessa oleva luokka <code>FormController</code> sisältää metodin, joka vastaanottaa minkä tahansa pyynnön, asettaa <code>model</code>-olion <code>data</code>-parametrin arvoksi <code>content</code>-muuttujan, sekä ohjaa pyynnön luomaan sivun kansiossa <code>src/main/resources/templates/</code> olevasta <code>index.html</code>-sivusta. Sivu sisältää valmiin lomakkeen, jonka avulla palvelimelle voi lähettää tietoa. Jos HTML-lomakkeet eivät ole tuttuja, tutustu esimerkiksi osoitteessa <a href="http://www.w3schools.com/html/html_forms.asp" target="_blank">http://www.w3schools.com/html/html_forms.asp</a> olevaan oppaaseen.</p>

			<p>Kun tarkastelet valmista lomaketta tarkemmin, on <code>action</code>-attribuutti hieman erilainen kuin normaalisti. Thymeleafissa lomakkeen <code>action</code>-attribuutti määritellään muodossa <code>th:action="@{/submit}"</code>, minkä avulla osoite voidaan muuttaa automaattisesti sovelluksen sijainnin muuttuessa.</p>

                        <p>Muokkaa sovellusta siten, että lomakkeella lähetetty data muuttaa palvelimella olevaa <code>content</code>-muuttujaa, ja että käyttäjälle näytetään aina <code>content</code>-muuttujan uusin arvo. Jos taas pyynnössä ei tule <code>data</code>-nimistä parametria, säilytetään <code>content</code>-muuttujan arvo sellaisenaan. Varmista lopuksi, että käyttäjä näkee sivun myös ilman lomakkeen lähetystä.</p>

                        <p>Käytännössä sivun tulee toimia seuraavasti:</p>

                        <ul>
                            <li>Kun sivu avataan ensimmäisen kerran, käyttäjä näkee tekstin "i got nothing.."</li>
                            <li>Kun lomakkeella lähetetään dataa, esimerkiksi "testi", käyttäjä näkee tekstin "i got testi"</li>
                            <li>Kun sivu avataan tämän jälkeen uudestaan, käyttäjä näkee vieläkin tekstin "i got testi"</li>
                        </ul>
                    </div>
                </div>


                <h3>Pyynnöistä ja poluista</h3>


                <p>HTML-sivuilla olevien lomakkeiden avulla käyttäjä voi lähettää dataa sekä GET- että POST-tyyppisellä pyynnöllä. Pyynnön tyyppi määritellään lomakkeen <code>method</code>-osiossa, esimerkiksi seuraavalla lomakkella tehdään POST-tyyppinen pyyntö, jossa palvelimen polkuun <code>/persons</code> lähetetään parametri nimeltä <code>name</code> -- (palvelimen päälläollessa käytännössä <code>http://localhost:8080/persons</code>). Käytännössä GET-tyyppisiä pyyntöjä ei tule käyttää ohjelmiston sisäisen tilan muokkaamiseen (esimerkiksi henkilöiden poistamiseen), sillä esimerkiksi web-indeksoijat tekevät GET-tyyppisiä pyyntöjä ja seuraavat sivujen linkkejä.</p>

                <pre class="sh_xml">
        &lt;form th:action="@{/persons}" method="POST"&gt;
            &lt;input type="text" name="name"/&gt;
            &lt;input type="submit"/&gt;
        &lt;/form&gt;</pre>

                <p>Allaoleva kontrollerimetodi vastaanottaa sekä GET- että POST-tyyppisiä pyyntöjä.</p>

                <pre class="sh_java">
    @RequestMapping("/persons")
    public String post(@RequestParam String name) {
        // tee jotain parametrille name
        return "index";
    }</pre>


                <p>Pyynnön tyypin voi kertoa eksplisiittisesti osana <code>@RequestMapping</code>-annotaatiota. Alla oleva metodi käsittelee vain POST-tyyppisiä pyyntöjä.</p>

                <pre class="sh_java">
    @RequestMapping(value = "/persons", method = RequestMethod.POST)
    public String post(@RequestParam String name) {
        // tee jotain parametrille name
        return "index";
    }</pre>

                <p>POST-tyyppiset pyynnöt ovat hieman ongelmallisia jos pyynnön vastauksena palautetaan näytettävä sivu. Tällöin käyttäjä voi sivun uudelleenlatauksen (esim. painamalla F5) yhteydessä lähettää aiemmin lähettämänsä datan vahingossa uudelleen. Esimerkiksi edellisessä tehtävässä, jos painat F5-näppäintä sen jälkeen kun olet lähettänyt lomakkeen, huomaat tämän ilmiön.</p>

                <p>On tyylikkäämpää toteuttaa lomakkeen dataa vastaanottavat kontrollerit siten, että ne vastaanottavat pyynnön ja pyytävät selainta hakemaan sivun uudestaan. Tämä tapahtuu palauttamalla kontrollerimetodista merkkijono <code>redirect:</code>, johon on liitetty haluttava polku. Esimerkiksi merkkijonon <code>redirect:/persons</code> palauttaminen luo tilanteen, missä selaimelle lähetetään viesti, jossa sitä ohjeistetaan tekemään GET-tyyppinen haku osoitteeseen <code>/persons</code>. Tätä toteutustapaa kutsutaan <a href="http://en.wikipedia.org/wiki/Post/Redirect/Get" target="_blank">Post/Redirect/Get</a>-suunnittelumalliksi, ja sillä mm. estetään lomakkeiden uudelleenlähetys, jonka lisäksi vähennetään toiminnallisuuden toisteisuutta.</p>

                <p>Ylläolevan esimerkin voi toteuttaa uudestaan siten, että lomake vastaanotetaan yhdessä kontrollerimetodissa ja näkymä palautetaan toisessa. Lisätään annotaatioon <code>@RequestMapping</code> parametri <code>method</code>, jolla kerrotaan pyyntötyyppi, jota kontrollerimetodi kuuntelee.</p>

                <pre class="sh_java">
    @RequestMapping(value = "/persons", method = RequestMethod.GET)
    public String get() {
        return "index";
    }

    @RequestMapping(value = "/persons", method = RequestMethod.POST)
    public String post(@RequestParam String name) {
        // tee jotain parametrille name
        return "redirect:/persons";
    }</pre>

                <p>Kontrollerimetodiin <code>get</code> voisi luonnollisesti lisätä myös Model-parametrin, johon voisi asettaa näkymään lisättävää tietoa.</p>

                <p>Jatketaan esimerkkiä vielä hieman. Oletetaan, että käsittelemme henkilöitä, joilla jokaisella on jonkinlainen yksilöllinen tunnus, ja haluamme näyttää henkilöön liittyvän sivun. Eräs vaihtoehto olisi lisätä pyynnön parametriin näytettävän henkilön tunnus, minkä perusteella pyyntöä käsittelevä metodi hakisi tarvittavan henkilön.</p>

                <p>Toinen vaihtoehto on ajatella pyyntöpolkua haettavan henkilön, tai resurssin tunnistajana, ja hakea henkilön tietoja esimerkiksi osoitteen <code>/persons/5</code> kautta, missä tunnus <code>5</code> on haettavan henkilön tunnus. Parametrien erottaminen pyyntöpolusta onnistuu <code>@PathVariable</code>-annotaation avulla. Yllä oleva esimerkki jatkuu siten, että muokkaamme <code>get</code>-metodin nimen muotoon <code>list</code>, ja lisäämme toisen metodin nimeltä <code>get</code>, jonka avulla voidaan hakea yksittäinen henkilö. Kokonaisuudessaan henkilöiden noutamiseen ja lisäämiseen tarvittava kontrolleriluokka on seuraavanlainen.</p>


                <pre class="sh_java">
package wad.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

@Controller
public class PersonController {

    // ..

    @RequestMapping(value = "persons", method = RequestMethod.GET)
    public String list(Model model) {
        // hae kaikki henkilöt ja lisää ne modeliin
        // palauta sopiva sivu
        return "persons"; // erillinen persons.html
    }

    @RequestMapping(value = "persons/{id}", method = RequestMethod.GET)
    public String get(Model model, @PathVariable String id) {
        // etsi henkilö tunnuksella id, lisää se modeliin
        // palauta sopiva sivu
        return "person"; // erillinen person.html
    }

    @RequestMapping(value = "persons", method = RequestMethod.POST)
    public String post(@RequestParam String name) {
        // luo uusi henkilö nimen perusteella
        return "redirect:/persons";
    }
}</pre>

                <p>Huomaamme kuitenkin metodeissa hieman toistoa. Voimme siirtää osan <code>@RequestMapping</code>-määrittelystä luokkatasolle seuraavasti. Tällöin kaikki alla olevassa luokassa olevat metodit kuuntelevat polkua <code>persons</code> tai sen alipolkuja.</p>


                <pre class="sh_java">
// ..

@Controller
@RequestMapping(value = "persons")
public class PersonController {

    @RequestMapping(method = RequestMethod.GET)
    public String list(Model model) {
        // ..
    }

    @RequestMapping(value = "/{id}", method = RequestMethod.GET)
    public String get(Model model, @PathVariable String id) {
        // ..
    }

    @RequestMapping(method = RequestMethod.POST)
    public String post(@RequestParam String name) {
        // ..
    }
}</pre>

                <h3>Olioiden luominen pyynnöstä</h3>

                <p>Jatketaan edellistä esimerkkiä vielä hieman. Oletetaan, että haluamme käsitellä <code>Person</code>-luokan ilmentymiä. Jos luokan attribuuttien nimet ovat samat pyynnössä olevien parametrien kanssa, voidaan pyynnön parametreista luoda olio automaattisesti. Oletetaan, että käytössämme on seuraava <code>Person</code>-luokka.</p>

                <pre class="sh_java">
//..
public class Person {

    private String name;

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }
}</pre>

                <p>Luokalle tulee olla ns. getterit ja setterit, sillä Spring käyttää niitä arvojen asettamiseen. Näiden luominen on automaattista NetBeansissa: kun olet luonut oliomuuttujat, klikkaa lähdekoodi-ikkunaa oikealla hiirennapillä, ja valitse <code>Insert code</code>.</p>

                <p>Kun käytössämme on luokka <code>Person</code>, voimme muokata aiempaa kontrolleriluokkaamme siten, että lomakkeen vastaanottava <code>post</code> metodi luo pyynnöstä automaattisesti <code>Person</code>-olion. Tämä tapahtuu <code>@ModelAttribute</code>-annotaatiolla.</p>

                <pre class="sh_java">
    @RequestMapping(method = RequestMethod.POST)
    public String post(@ModelAttribute Person person) {
        // tee luodulle oliolle jotain

        return "redirect:/persons";
    }</pre>

                <div class="tehtava">
                    <header>
                        <h1>
                            <a data-toggle="collapse" class="collapsed" href="#t-vieraslista">
                                Vieraslista
                            </a>
                        </h1>
                    </header>
                    <div id="t-vieraslista" class="collapse">
                        <p>Tehtävässä kehitetään vieraslistausta. Tässä tehtävässä on kaksi osaa, joista kummastakin saa tehtäväpisteen.</p>

                        <h1>Vieraiden lisääminen</h1>

                        <p>Muokkaa <code>GuestController</code>-luokkaa siten, että kun osoitteeseen <code>/guests</code> tehdään POST-pyyntö, jonka mukana lähetetään vierasta kuvaavat <code>name</code> ja <code>menu</code>-parametrit, vieraslistaan (lista nimeltä <code>guests</code>) lisätään uusi vieras. Lisää vieras jos ja vain jos name-parametri ei ole tyhjä.</p>

                        <p>Huomioi, että luokka <code>GuestController</code> kuuntelee jo <code>/guests</code>-osoitetta!</p>

                        <p>Kun uusi vieras on lisätty, pyyntö tulee <em>uudelleenohjata</em> vieraat listaavalle kontrollerimetodille.</p>


                        <h1>Vieraiden poisto</h1>

                        <p>Toteuta vieraiden poistotoiminnallisuus.</p>

                        <p>Poistotoiminnallisuuden tulee tapahtua POST-tyyppisen pyynnön avulla vieraskohtaisiin osoitteisiin. Esimerkiksi, vieraan, jonka tunnus (id) on "x9z41f", poisto tapahtuu tekemällä pyyntö osoitteeseen <code>/guests/x9z41f/delete</code>. Annotaatiosta <code>@PathVariable</code> on tässä hyötyä. Huom! Älä hyväksy GET-tyyppisiä pyyntöjä, jotka yrittävät poistaa vierasta listalta!</p>

                        <p>Kun vieras on poistettu, uudelleenohjaa pyyntö vieraat listaavalle kontrollerimetodille.</p>
                    </div>
                </div>


                <h3>Olioiden ja kokoelmien käyttäminen näkymässä</h3>

                <p>Edellisessä tehtävässä käytetyssä HTML-sivussa oli muutamia mystisiä kommentteja. Selvennetään niistä muutamia.</p>

                <p>Jos model-olioon on lisätty olio, pääsemme olion muuttujiin käsiksi piste-operaattorin <code>.</code> avulla. Esimerkiksi lause <code>${person.name}</code> hakee <code>person</code>-nimiseen olioon liittyvän <code>name</code>-muuttujan arvoa. Muuttujien arvojen hakemisessa käytetään gettereitä ja settereitä, joten ne kannattaa olla luokkamäärittelyssä.</p>

                <p>Käytännössä siis jos Person-luokan ilmentymä lisätään pyynnön model-olioon, pääsee Thymeleaf sen <code>getName</code>-metodiin käsiksi.</p>

                <pre class="sh_java">
    ...
    Person p = new Person();
    p.setName("James Gosling");
    model.addAttribute("person", p);
    ...
                </pre>

                <p>Kun olio on lisätty pyynnön attribuutiksi nimellä <code>person</code>, voidaan siihen liittyviin get-metodeihin viitata muodossa <code>${person.<em>ominaisuus</em>}</code>. Tämä tekisi metodikutsun <code>getOminaisuus()</code>. Metodia <code>getName()</code> voi taas kutsua seuraavasti:</p>

                <pre class="sh_xml">
    ...
    &lt;body&gt;
        &lt;p&gt;Ja seuraavana vuorossa on: &lt;span th:text="${person.name}"&gt;jack bauer?&lt;/span&gt;&lt;/p&gt;
    &lt;/body&gt;
    ...
                </pre>

                <p>Yllä oleva esimerkki luo seuraavanlaisen tulostuksen.</p>

                <pre class="naytto">
Ja seuraavana vuorossa on: James Gosling
                </pre>

                <p>Thymeleaf sisältää toiminnallisuudet mm. perusohjelmoinnissa käytettävien kontrollirakenteiden käyttöön sekä erilaisten tietotyyppien kuten päivämäärän formatointiin. Tällä kurssilla hyödynnämme lähinnä kontrollirakenteita, joista toistolauseke lienee tärkein.</p>

                <p>Komentoa <code>th:each</code> käytetään Collection-rajapinnan toteuttavien kokoelmien läpikäyntiin. Sen määrittely saa muuttujan nimen, johon kokoelmasta otettava alkio kullakin iteraatiolla tallennetaan, sekä läpikäytävän kokoelman. Perussyntaksiltaan <code>th:each</code> on seuraavanlainen.</p>

                <pre class="sh_xml">
    ...
    &lt;pre&gt;
        &lt;p th:each="alkio : ${joukko}"&gt;
            &lt;span th:text="${alkio}"&gt;hello world!&lt;/span&gt;
        &lt;/p&gt;
    &lt;/pre&gt;
    ...
                </pre>

                <p>Yllä käytämme attribuuttia nimeltä <code>joukko</code>, ja tulostamme yksitellen sen sisältämät alkiot.</p>

                <p><em>Huom! Eräs klassinen virhe on määritellä iteroitava joukko merkkijonona <code>th:each="alkio : joukko"</code>. Tämä ei luonnollisesti toimi.</em></p>

                <p>Iteroitavan joukon alkioiden ominaisuuksiin pääsee käsiksi aivan samalla tavalla kuin muiden model-olioon lisättävien attribuuttien. Tutkitaan seuraavaa esimerkkiä, jossa listaan lisätään kaksi henkilöä, lista lisätään pyyntöön, ja lopulta luodaan Thymeleafin avulla.</p>


                <pre class="sh_java">
    ...
    Person p = new Person();
    p.setName("James Gosling");

    Person p2 = new Person();
    p2.setName("Martin Odersky");

    List&lt;Person&gt; list = new ArrayList&lt;&gt;();
    list.add(p);
    list.add(p2);

    model.addAttribute("persons", list);
    ...
                </pre>

                <pre class="sh_xml">
    ...
    &lt;p&gt;And the talks are given by:&lt;/p&gt;
    &lt;ol&gt;
        &lt;li th:each="person : ${persons}"&gt;
            &lt;span th:text="${person.name}"&gt;has no name&lt;/span&gt;
        &lt;/li&gt;
    &lt;/ol&gt;
    ...
                </pre>

                <p>Käyttäjälle lähetettävä sivu näyttää palvelimella tapahtuneen prosessoinnin jälkeen seuraavalta.</p>


                <pre class="sh_xml">
    ...
    &lt;p&gt;And the talks are given by:&lt;/p&gt;
    &lt;ol&gt;
            &lt;li&gt;&lt;span&gt;James Gosling&lt;/span&gt;&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;Martin Odersky&lt;/span&gt;&lt;/li&gt;
    &lt;/ol&gt;
    ...
                </pre>


                <h2>Tietokannan käyttäminen</h2>

                <p>Vaikka sovelluksemme ovat melko huikeita, on samalla hieman tylsää, että sovelluksiin liittyvä tieto katoaa aina kun palvelin käynnistetään uudelleen. Tietokannat ovat palvelinohjelmistosta erillisiä sovelluksia, joiden ensisijainen tehtävä on varmistaa, että käytettävä tieto ei katoa. Otetaan ensiaskeleet tietokannan käyttöön web-palvelinohjelmistoissa -- tutustumme tietokantoihin tarkemmin myöhemmin kurssilla. Käytämme tietokantatoiminnallisuuden toteuttamisessa <a href="http://projects.spring.io/spring-data-jpa/" target="_blank">Spring Data JPA</a>-komponenttia, johon löytyy myös aloituspaketti käyttämästämme Spring Bootista.</p>

		<aside class="info">

		  <br/>

		  <h1>Spring Data JPA:n käyttöönotto</h1>

		  <p>Saadaksemme Spring Data JPA:n käyttöömme, tulee meidän lisätä se <code>pom.xml</code>-tiedostoon. Spring Bootin kautta löytyy näppärä paketti <code>spring-boot-starter-data-jpa</code>, joka vähentää yksittäisten riippuvuuksien lisäämistä. Tämän lisäksi tarvitsemme testikäyttöön sopivan tietokannan -- valitaan <a href="http://hsqldb.org/" target="_blank">HSQLDB</a>, jonka voi ladata muistiin sovelluksen käynnistyessä.</p>

		  <p>Lisätään projektiin seuraavat riippuvuudet:</p>

		  <pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.hsqldb&lt;/groupId&gt;
    &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>

		  <p>Kun projektin riippuvuudet noudetaan Mavenin avulla, on tietokanta valmis testikäyttöön.</p>

		</aside>

                <p>Jotta voimme tallentaa luokan ilmentymiä tietokantaan, meidän tulee asettaa luokalle <code>@Entity</code>-annotaatio, sekä tehdä sille tunnuskenttä, jonka avulla se voidaan yksilöidä. Voimme käyttää tunnuskentän luomiseen Spring Data JPA:n valmiiksi tarjoamaa <code>AbstractPersistable</code>-yliluokkaa, jota perittäessä kerromme uniikin tunnuksen tyypin. Esimerkiksi <code>Person</code>-luokasta voidaan tehdä tietokantaan tallennettava seuraavilla muutoksilla.</p>

                <pre class="sh_java">
package wad.domain;

import javax.persistence.Entity;
import org.springframework.data.jpa.domain.AbstractPersistable;

@Entity
public class Person extends AbstractPersistable&lt;Long&gt; {

    private String name;

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }
}</pre>

                <p>Kun käytössämme on tietokantaan tallennettava luokka, voimme luoda tietokannan käsittelyyn käytettävän <em>rajapinnan</em>. Kutsutaan tätä rajapintaoliota nimellä <code>PersonRepository</code>.</p>

                <pre class="sh_java">
// pakkaus

import wad.domain.Person;
import org.springframework.data.jpa.repository.JpaRepository;

public interface PersonRepository extends JpaRepository&lt;Person, Long&gt; {

}</pre>

                <p>Rajapinta perii Spring Data-projektin <code>JpaRepository</code>-rajapinnan; samalla kerromme, että tallennettava olio on tyyppiä <code>Person</code> ja että tallennettavan olion tunnus on <code>Long</code>-tyyppiä. Tämä tyyppi on sama kuin aiemmin <code>AbstractPersistable</code>-luokan perinnässä parametriksi asetettu tyyppi. Spring osaa käynnistyessään myös etsiä mm. JpaRepository-rajapintaluokan periviä luokkia. Jos niitä löytyy, se luo niiden pohjalta tietokannan käsittelyyn sopivan olion sekä asettaa olion ohjelmoijan haluamiin muuttujiin. Nämä muuttujat määritellään annotaatiolla <code>@Autowired</code> -- jokaiselle muuttujalle tulee oma annotaatio -- palaamme myöhemmin kurssilla tarkemmin tähän ns. olioiden automaattiseen asettamiseen.</p>

                <p>Kun olemme luoneet rajapinnan <code>PersonRepository</code>, voimme lisätä sen käyttöömme esimerkiksi kontrolleriluokkaan. Tämä tapahtuu seuraavasti.</p>

                <pre class="sh_java">
// ...

@Controller
@RequestMapping(value = "persons")
public class PersonController {

    @Autowired
    private PersonRepository personRepository;

    // ...
}</pre>

                <p>Nyt tietokantaan pääsee käsiksi <code>personRepository</code>-olion kautta. Osoitteessa <a href="http://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/JpaRepository.html" target="_blank">http://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/JpaRepository.html</a> on JpaRepository-rajapinnan API-kuvaus, mistä löytyy rajapinnan tarjoamien metodien kuvauksia. Voimme esimerkiksi toteuttaa tietokannassa olevien olioiden listauksen sekä yksittäisen olion haun seuraavasti:</p>

                <pre class="sh_java">
// ...

@Controller
@RequestMapping(value = "persons")
public class PersonController {

    @Autowired
    private PersonRepository personRepository;

    @RequestMapping(method = RequestMethod.GET)
    public String list(Model model) {
        model.addAttribute("list", personRepository.findAll());
        return "persons"; // erillinen persons.html
    }

    @RequestMapping(value = "/{id}", method = RequestMethod.GET)
    public String get(Model model, @PathVariable Long id) {
        model.addAttribute("person", personRepository.findOne(id));
        return "person"; // erillinen person.html
    }
}</pre>


                <h3>Tietokantatransaktiot ja tietokantaolioiden muuttaminen</h3>

                <p>Kun tietokannasta lataa olion, sen muuttaminen ei automaattisesti vie muutoksia takaisin tietokantaan. Esimerkiksi, seuraavassa kontrollerimetodissa <code>person</code>-oliolle tehdyt muutokset eivät tallennu tietokantaan.</p>

                <pre class="sh_java">
    @RequestMapping(value = "{id}/example", method = RequestMethod.POST)
    public String post(@PathVariable Long id) {
        Person p = personRepository.findOne(id);
        p.setName("example");
        // ..
        return "redirect:/person/" + id;
    }</pre>

                <p>Jos muutokset halutaan tallentaa tietokantaan, tulee olio joko tallentaa erikseen <code>personRepository</code>-olion <code>save</code>-metodilla, tai kontrollerimetodille asettaa annotaatio <code>@Transactional</code>. Annotaatio <code>@Transactional</code> määrittelee metodin toiminnallisuuden sellaiseksi, että kaikki metodin sisällä tapahtuvat asiat tapahtuvat tietokantatransaktion sisällä, jonka aikana tehdyt muutokset viedään tietokantaan metodin suorituksen lopuksi. Seuraavassa esimerkissä haetun henkilön nimi päivittyy tietokantaan.</p>

                <pre class="sh_java">
    @Transactional
    @RequestMapping(value = "{id}/example")
    public String post(@PathVariable Long id) {
        Person p = personRepository.findOne(id);
        p.setName("example");
        // ..
        return "redirect:/person/" + id;
    }</pre>



                <div class="tehtava">
                    <header>
                        <h1>
                            <a data-toggle="collapse" class="collapsed" href="#t-tehtavalista">
                                Tehtävälista
                            </a>
                        </h1>
                    </header>
                    <div id="t-tehtavalista" class="collapse">

                      <p>Tässä tehtävässä toteutetaan tehtävälistatoiminnallisuutta. Tehtäväpohjassa on valmis tietokantakonfiguraatio, missä käytetään muistiin ladattavaa tietokantaa -- tietokanta tyhjenee palvelimen sammuessa.</p>

                        <h1>Tehtävien listaaminen</h1>

                        <p>Toteuta <code>TaskController</code>-luokkaan <code>/tasks</code>-osoitteeseen tulevia GET-tyyppisiä pyyntöjä kuunteleva kontrollerimetodi. Pyynnön tulee lisätä <code>model</code>-parametriin <code>tasks</code> kaikki tietokannasta löytyvät tehtävät. Tässä <code>taskRepository</code>-olion <code>findAll</code>-metodi on hyödyksi. Palauta käyttäjälle kansiossa <code>src/main/resources/templates</code> olevasta <code>index.html</code>-tiedostosta luotu näkymä.</p>

                        <h1>Tehtävän lisääminen</h1>

                        <p>Toteuta <code>TaskController</code>-luokkaan <code>/tasks</code>-osoitteeseen tulevia POST-tyyppisiä pyyntöjä kuunteleva kontrollerimetodi. Pyynnön mukana tulee <code>name</code> ja <code>done</code>-parametrit, joiden pohjalta luodaan uusi tehtävä. Jos tehtävän nimi (<em>name</em>) ei ole tyhjä ja se ei ole null, tulee tehtävä tallentaa tietokantaan. Tässä <code>taskRepository</code>-olion <code>save</code>-metodi on hyödyksi.</p>

                        <p>Kun uusi tehtävä on lisätty, uudelleenohjaa pyyntö aiemmin toteuttamallesi tehtävät listaavalle kontrollerimetodille.</p>

                        <h1>Tehtävän poistaminen</h1>

                        <p>Toteuta <code>TaskController</code>-luokkaan <code>/tasks/{id}/delete</code>-osoitteeseen POST-tyyppisiä pyyntöjä kuunteleva kontrollerimetodi. Poistettavan tehtävän <code>id</code> on osana osoitetta. Tässä <code>taskRepository</code>-olion <code>delete</code>-metodi on hyödyksi.</p>

                        <p>Kun tehtävä on poistettu, uudelleenohjaa pyyntö aiemmin toteuttamallesi tehtävät listaavalle kontrollerimetodille.</p>

                        <h1>Tehtävän muuttaminen tehdyksi</h1>

                        <p>Toteuta <code>TaskController</code>-luokkaan <code>/tasks/{id}/done</code>-osoitteeseen POST-tyyppisiä pyyntöjä kuunteleva kontrollerimetodi. Tehtävän, joka tulee asettaa tehdyksi, <code>id</code> on osana osoitetta. Tässä <code>taskRepository</code>-olion <code>findOne</code>-metodi on hyödyksi.</p>

                        <p>Kun tehtävä on on asetettu tehdyksi, uudelleenohjaa pyyntö aiemmin toteuttamallesi tehtävät listaavalle kontrollerimetodille. Huom! Jotta tietokannasta hakemaasi olioon tehdyt muutokset päivittyvät, sinun tulee joko käyttää <code>@Transactional</code>-annotaatiota, tai tallentaa olio muutosten jälkeen.</p>
                    </div>
                </div>

                <h3>Tietokannassa olevat oliot ja toisiin olioihin viittaaminen</h3>

                <p>Kuten olio-ohjelmoinnissa yleensäottaen, tietokantaan tallennettavat oliot voivat viitata toisiinsa. Oletetaan, että käytössämme on <code>Person</code>-luokan lisäksi <code>VipList</code>-luokka, joka sisältää listan henkilöitä. Yhtä Vip-listaa kohden on monta henkilöä, joten merkitään yhteys <code>@OneToMany</code>-annotaatiolla. Palaamme myös yhteystyyppeihin myöhemmin kurssilla.</p>

                <pre class="sh_java">
package wad.domain;

import java.util.List;
import javax.persistence.Entity;
import javax.persistence.OneToMany;
import org.springframework.data.jpa.domain.AbstractPersistable;

@Entity
public class VipList extends AbstractPersistable&lt;Long&gt; {

    @OneToMany
    private List&lt;Person&gt; persons;

    public List&lt;Person&gt; getPersons() {
        return this.persons;
    }

    public void setPersons(List&lt;Person&gt; persons) {
        this.persons = persons;
    }
}</pre>

                <p>Täysin uuden henkilön luominen ja lisääminen vip-listalle tapahtuu seuraavasti. Oletetaan, että käytössämme on <code>personRepository</code>-olio henkilöiden hallintaan ja <code>vipListRepository</code>-vip-listojen hallintaan.</p>

                <pre class="sh_java">
    @Transactional
    @RequestMapping(value = "viplists/{id}/persons", method = RequestMethod.POST)
    public String post(@PathVariable Long id, @ModelAttribute Person person) {
        // tallennetaan henkilö ja otetaan viite tallennettuun olioon haltuun
        person = personRepository.save(person);
        // haetaan vip-lista ja lisätään henkilö listalle
        vipListRepository.findOne(id).add(person);

        // ohjataan pyyntö sopivaan näkymään
        return "redirect:/viplists";
    }</pre>

                <p>Henkilön poistaminen vip-listalta tapahtuu vastaavasti.</p>

                <pre class="sh_java">
    @Transactional
    @RequestMapping(value = "viplists/{id}/persons/{personId}/delete", method = RequestMethod.POST)
    public String removePerson(@PathVariable Long id, @PathVariable Long personId) {
        person = personRepository.findOne(personId);
        vipListRepository.findOne(id).getPersons().remove(person);

        // ohjataan pyyntö sopivaan näkymään
        return "redirect:/viplists";
    }</pre>

                <p>Huom! Vaikka käytämme ensimmäisellä viikolla POST-pyyntöjä resurssien (esimerkiksi henkilöiden) poistamiseen, on käytäntö melko huono. Opimme myöhemmin parempia tapoja.</p>

                <p>Jos henkilö halutaan poistaa kokonaisuudessaan, tulee hänet ensin poistaa listoilta, joihin hän on lisätty. Palaamme taustasyihin myöhemmin...</p>

                <div class="tehtava">
                    <header>
                        <h1>
                            <a data-toggle="collapse" class="collapsed" href="#t-albumilista">
                                Albumilista
                            </a>
                        </h1>
                    </header>
                    <div id="t-albumilista" class="collapse">

                        <p>Muokattavaan albumilistasovellukseen on toteutettu jo albumien lisääminen ja listaaminen. Tässä tehtävässä lisätään albumeihin kappaleita. Älä huoli <code>wad.profiles</code>-pakkauksen alla olevista tiedostoista tai muista projektiin lisätyistä uusista riippuvuuksista :).</p>

                        <h1>Kappaleen lisääminen</h1>

                        <p>Lisää <code>AlbumController</code>-luokkaan kontrollerimetodi, joka kuuntelee POST-tyyppisiä pyyntöjä osoitteeseen <code>/albums/{albumId}/tracks</code>, missä <code>albumId</code> on olemassaolevan albumin tunnus. Pyynnöissä tulee mukana <code>name</code>-niminen parametri, jonka arvona on lisättävän kappaleen nimi.</p>

                        <p>Tallenna lisättävä kappale tietokantaan ja lisää se albumille, jonka tunnus (<em>id</em>) on sama kuin polussa oleva {albumId}.</p>

                        <p>Kun kappale on lisätty albumille, ohjaa pyyntö edelleen albumit listaavalle kontrollerimetodille.</p>


                        <h1>Kappaleen poistaminen</h1>


                        <p>Lisää <code>AlbumController</code>-luokkaan kontrollerimetodi, joka kuuntelee POST-tyyppisiä pyyntöjä osoitteeseen <code>/albums/{albumId}/tracks/{trackId}/delete</code>, missä <code>albumId</code> on olemassaolevan albumin tunnus, ja <code>trackId</code> on poistettavan kappaleen tunnus.</p>

                        <p>Kun kontrollerimetodia kutsutaan, tulee sen poistaa annettu kappale annetulta albumilta. Huomaa, että kappale tulee sekä poistaa albumilta, että poistaa kappaletietokannasta.</p>

                        <p>Kun kappale on poistettu, ohjaa pyyntö edelleen albumit listaavalle kontrollerimetodille.</p>
                    </div>
                </div>

                <h2>Sovelluksen siirtäminen verkkoon</h2>

                <p>Albumilistamme, kuten muutkin sovelluksemme, on melko jepa, mutta olisi kiva näyttää sitä myös jollekin muulle. Tutustutaan tämän viikon lopuksi sovelluksen verkkoon siirtämiseen. Tarvitset tässä tunnukset <a href="https://www.heroku.com/" target="_blank">Heroku</a>-palveluun, joka tarjoaa ilmaisen sijoituspaikan vähän resursseja kuluttaville sovelluksille.</p>

                <p>Kun olet luonut tunnuksen Herokuun, asenna osoitteesta <a href="https://toolbelt.heroku.com/" target="_blank">https://toolbelt.heroku.com/</a> työvälineet sovelluksen Herokuun siirtämiseen. Seuraa myös sivun "Getting started"-ohjetta, ja suorita sen <code>heroku login</code>-osio.</p>

                <p>Mene tämän jälkeen Albumilista-tehtävän kansioon, missä on myös tiedosto <code>pom.xml</code>. Kirjoita kansiossa komento <code>git init</code>, mikä lisää kansioon versionhallintakansion <code>.git</code>.</p>

                <pre>        
avihavai@aavikkokettu:<em>polku</em>/W1E08.Albumilista$ git init
Initialized empty Git repository in <em>polku</em>/W1E08.Albumilista/.git/</pre>

                <p>Kirjoita tämän jälkeen komento <code>heroku create</code>, mikä luo paikan minne sovelluksen voi lähettää.</p>

                <pre>       
avihavai@aavikkokettu:<em>polku</em>/W1E08.Albumilista$ heroku create
Creating aqueous-lowlands-6350... done, stack is cedar
http://aqueous-lowlands-6350.herokuapp.com/ | git@heroku.com:aqueous-lowlands-6350.git</pre>

                <p>Komennolla <code>git remote add heroku git@heroku.com:aqueous-lowlands-6350.git</code> lisätään juuri luotu heroku-sijainti projekti käyttöömme. Huomaa, että <code>git@heroku.com:aqueous-lowlands-6350.git</code> on sama kuin komennon <code>heroku create</code> tulostama sijainti.</p>

                <pre>       
avihavai@aavikkokettu:<em>polku</em>/W1E08.Albumilista$ git remote add heroku git@heroku.com:aqueous-lowlands-6350.git
avihavai@aavikkokettu:<em>polku</em>/W1E08.Albumilista$</pre>        

                <p>Nyt voimme lisätä sovelluksen verkkoon. Jos tehtäväkansiossa on target-kansio, poista se tässä välissä. Kirjoita seuraavaksi komento <code>git add .</code>, jonka jälkeen komento <code>git commit -m "initial commit"</code>. Näillä komennoilla lisäät sovelluksen nykyisen version versionhallintaan. Kirjoita tämän jälkeen <code>git push heroku master</code>, mikä lähettää sovelluksen verkkoon.</p>

                <pre>       
avihavai@aavikkokettu:<em>polku</em>/W1E08.Albumilista$ git add .
avihavai@aavikkokettu:<em>polku</em>/W1E08.Albumilista$ git commit -m "initial commit"
[master (root-commit) 2cbc76b] initial commit
 tulostusta...
avihavai@aavikkokettu:<em>polku</em>/W1E08.Albumilista$ git push heroku master
 tulostusta...
-----> Discovering process types
       Procfile declares types -> web

-----> Compressing... done, 135.6MB
-----> Launching... done, v6
       http://aqueous-lowlands-6350.herokuapp.com/ deployed to Heroku
 hieman tulostusta</pre>

                <p>Nyt, voimme käydä tarkistamassa sovelluksen herokun palvelussa. Yllä olevassa esimerkissä sovellus on lisätty osoitteeseen <a href="http://aqueous-lowlands-6350.herokuapp.com/" target="_blank">http://aqueous-lowlands-6350.herokuapp.com/</a>.</p>
            </section>
            <!-- END WEEK1 -->

<!--
	    <p><em>päivitysraja</em></p>
-->

            <!-- BEGIN WEEK2 -->
<!--
            <section class="weeklimit" data-week-id="2">
                <header>
                    <h1 id="viikko2">Viikko 2</h1>
                </header>


            </section>
-->
            <!-- END WEEK2 -->

        </article>

        <footer>
            <p>
                <a id="license" rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.0/"><img alt="Creative Commons License" style="border-width:0; float:left; padding:15px" src="http://i.creativecommons.org/l/by-nc-sa/2.0/88x31.png" /></a>
                <small>T&auml;m&auml; materiaali on lisensoitu Creative Commons BY-NC-SA-lisenssill&auml;, joten voit k&auml;ytt&auml;&auml; ja levitt&auml;&auml; sit&auml; vapaasti, kunhan alkuper&auml;isten tekij&ouml;iden nimi&auml; ei poisteta. Jos teet muutoksia materiaaliin ja haluat levitt&auml;&auml; muunneltua versiota, se t&auml;ytyy lisensoida samanlaisella vapaalla lisenssill&auml;. Materiaalien k&auml;ytt&ouml; kaupalliseen tarkoitukseen on ilman erillist&auml; lupaa kielletty. Tekij&auml;(t): <a href="http://www.cs.helsinki.fi/en/people/avihavai" target="_blank">Arto Vihavainen</a> sekä <a href="http://www.cs.helsinki.fi/en/rage" target="_blank">Agile Education Research</a> -tutkimusryhm&auml;.
            </p>
        </footer>

        <div class="hidden">
            <p>the end.</p>
        </div>


        <script src="js/libs/jquery/jquery.js"></script>
        <script src="js/libs/jqueryui/jquery-ui.js"></script>
        <script src="js/libs/twitter-bootstrap/js/bootstrap.js"></script>


        <script src="js/libs/syntaxhighlight/sh_main.min.js"></script>
        <script src="js/wepa.js"></script>
    </body>
</html>
