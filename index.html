<!DOCTYPE html>
<html>
    <head>
        <title>Web-palvelinohjelmointi</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="js/libs/syntaxhighlight/css/sh_style.css"/>
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
        <link rel="stylesheet" href="css/chartist.min.css"/>
        <link rel="stylesheet" href="css/wepa.css"/>

        <link rel="stylesheet" href="css/wepa-mooc.css"/>

    </head>
    <body>

        <!-- BEGIN NAV -->
        <header role="navigation">
            <h1>
                <button type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>

                <!-- BEGIN MOOC SNIP -->                    
<!--
                <a href="http://www.mooc.fi" class="hidden-in-hy">&#171; mooc.fi</a>
-->
                <!-- END MOOC SNIP -->
                <!-- BEGIN HY SNIP -->                    
                <!-- END HY SNIP -->

                <a href="http://www.cs.helsinki.fi"><img src="img/header_tktl.png" alt="CS Dept. Univ. Helsinki"></a>
		
            </h1>
            <nav class="collapse bs-navbar-collapse" role="navigation">
                <ul>
                    <li>
                        <a href="#viikko1">Viikko 1</a>
                    </li>
                    <li>
                        <a href="#viikko2">Viikko 2</a>
                    </li>
                    <li>
                        <a href="#viikko3">Viikko 3</a>
                    </li>
                    <li>
                        <a href="#viikko4">Viikko 4</a>
                    </li>
                    <li>
                        <a href="#viikko5">Viikko 5</a>
                    </li>
                    <li>
                        <a href="#viikko6">Viikko 6</a>
                    </li>
                    <li>
                        <a href="#viikko7">Viikko 7</a>
                    </li>
                </ul>

		<div style="direction: rtl;">
		  <button id="logout" class="btn btn-warning">Kirjaudu ulos</button>
		</div>
            </nav>
	    
        </header>
        <!-- // END NAV -->
        <article>


          <div class="modal fade" id="tmcAuthModal" data-backdrop="static" data-keyboard="false"  tabindex="-1" role="dialog" aria-labelledby="tmcAuthModalLabel" aria-hidden="true">
            <div class="modal-dialog">
              <form class="form-inline"  id="TmcLoginForm" role="form">
		<div class="modal-content">
                  <div class="modal-header">
                    <h4 class="modal-title" id="tmcAuthModalLabel">Kirjoita TMC-tunnuksesi</h4>
                  </div>
                  <div class="modal-body">
                    <p>Pyydämme sinua kirjautumaan TMC-tunnuksillasi materiaaliin. Kirjautumistietoja käytetään oppimateriaalin käytön tutkimukseen.</p>
                    <div id="tmc-account-wrong-alert" class="hidden alert alert-danger">Tarkista TMC-tunnuksesi</div>
                    <div class="form-group">
                      <label class="sr-only" for="exampleInputPassword2">TMC-tunnus</label>
                      <input type="text" name="tmcAccountName" class="form-control" id="inputTmcAccount" placeholder="TMC-tunnus">
                    </div>
                  </div>
                  <div class="modal-footer">
                    <button type="button" id="tmcAccountNOACCOUNT" class="btn btn-default" data-dismiss="modal">En halua</button>
                    <button type="submit" name="tmcLoginButton" id="tmcAccountOK" class="btn btn-primary">OK</button>
                  </div>
		</div><!-- /.modal-content -->
              </form>
            </div><!-- /.modal-dialog -->
          </div><!-- /.modal -->
	  

            <section id="intro" class="no-toc weeklimit" data-week-id="-1">Huom! Jos etsit syksyllä 2014 julkaistua web-palvelinohjelmoinnin oppimateriaalia, löytyy se <a href="s2014-wepa.html">täältä</a>.</section>



            <!-- BEGIN INDEX -->
            <section id="intro" class="no-toc weeklimit" data-week-id="0">
                
                <header>

                    <div class="intro-header-img"></div>

                    <h1>Web-palvelinohjelmointi</h1>

                    <p>Voinko oppia tekemään Facebookin, Flickrin tai Twitterin?</p>

                    <a class="call-to-action" href="#start" role="button">No todellakin!</a>

                </header>


<!--
                <div class="hidden">

                    <h1>Sisältö ja aikataulu</h1>

                    <p>Kurssilla tutustutaan nykyaikaisten, skaalautuvien ja virheenkestävien web-sovellusten toteuttamiseen, testaamiseen ja julkaisemiseen. Kurssilla keskitytään palvelinpuolen toiminnallisuuden toteuttamiseen. Selainpuolen toiminnallisuudella on kurssilla hyvin pieni paino. Kurssin opetuskieli on Suomi ja ohjelmointikieli Java. Kurssilla hyödynnetään <a href="http://spring.io/" target="_blank">Spring</a>-sovelluskehystä.</p>

                    <p>Kurssi sisältää seitsemän tehtäväsarjaa, joista ensimmäinen julkaistaan 2. syyskuuta 2014, ja uusia julkaistaan aina viikoittain. Seuraavaan tehtäväsarjaan eteneminen vaatii sen, että tekee vähintään 80% edeltävästä tehtäväsetistä.</p>

                    <p><a class="jump" href="#viikoittaiset-teemat" role="button">Viikoittaiset teemat &raquo;</a></p>

                    <h1>Opettajille ja opiskelijoille</h1>

                    <p>Kurssi vastaa <a href="http://www.cs.helsinki.fi/home/" target="_blank">Helsingin yliopiston tietojenkäsittelytieteen laitoksen</a> kurssia <a href="http://www.cs.helsinki.fi/en/courses/582353" target="_blank">Web-palvelinohjelmointi</a> (5 opintopistettä).</p>

                    <p>Kurssia ja sen materiaalia saa käyttää ja muokata vapaasti, kunhan noudattaa materiaalin <a href="#license">lisenssiä</a>. Jos järjestät kurssista kokeen omassa oppilaitoksessasi, saat tarvittaessa osoitteesta <a href="mailto:mooc@cs.helsinki.fi">mooc@cs.helsinki.fi</a> koepohjan.</p>

                    <p>Jos olet opiskelijana jossain muualla kuin Helsingin yliopistolla ja haluaisit suorittaa kurssin siten, että saat suoritusmerkinnän tai opintopisteet omassa oppilaitoksessasi, etsi omasta oppilaitoksestasi opettaja tai opinto-ohjaaja, joka on valmis valvomaan kokeen ja hyväksymään kurssisuorituksen ja pyydä häntä lähettämään sähköpostia osoitteeseen <a href="mailto:mooc@cs.helsinki.fi">mooc@cs.helsinki.fi</a></p>

                </div>
-->

                <h1 id="start">Sisältö, aikataulu, arvostelu</h1>

                <p>Kurssilla tutustutaan nykyaikaisten, skaalautuvien ja virheenkestävien web-sovellusten toteuttamiseen, testaamiseen ja julkaisemiseen. Kurssilla keskitytään palvelinpuolen toiminnallisuuden toteuttamiseen. Selainpuolen toiminnallisuudella on kurssilla hyvin pieni paino. Kurssin opetuskieli on Suomi ja ohjelmointikieli Java. Kurssilla hyödynnetään <a href="http://spring.io/" target="_blank">Spring</a>-sovelluskehystä.</p>

                <p>Kurssi sisältää seitsemän tehtäväsarjaa. <strong>Ensimmäinen tehtäväsarja julkaistaan 2. syyskuuta 2015</strong>. Uusia tehtäväsarjoja julkaistaan viikoittain. Tehtäväsarjojen viimeiset palautuspäivät löytyvät TMC:stä -- ensimmäisen sarjan viimeinen palautuspäivä on <strong>maanantaina 7.9. klo 16:00</strong>.</p>

                <p>Kurssin arvostelu perustuu viikoittaisiin harjoitustehtäviin, sekä kahteen kokeeseen, joista toinen tehdään kynällä ja paperilla, ja toinen tietokoneella. Kurssin pisteytys on seuraava:</p>

		<ul>
		  <li>Viikoittaisista tehtäväsarjoista saa 100 pistettä viikkoa kohti. Täydet 100 pistettä saa tekemällä 100% viikon tehtävistä. Jos tekee puolet tehtävistä, saa 50 pistettä jne.</li>
		  <li>Paperilla tehtävästä kokeesta on mahdollista saada 250 pistettä.</li>
		  <li>Tietokoneella tehtävästä kokeesta on mahdollista saada 250 pistettä.</li>
		</ul>

		<p>Kurssista voi saada yhteensä 1200 pistettä. Sekä paperilla ja kynällä että tietokoneella tehtävistä kokeista on kummastakin saatava vähintään puolet mahdollisista pisteistä. Kurssin alustavat arvosanarajat ovat seuraavat:</p>

		<ul>
		  <li>700 -> 1</li>
		  <li>800 -> 2</li>
		  <li>900 -> 3</li>
		  <li>1000 -> 4</li>
		  <li>1100 -> 5</li>
		</ul>

		<h2>Koeasiaa</h2>

		<p>Kurssin paperitentti järjestetään keskiviikkona 21.10. klo 9:00 salissa A111. Jos keskiviikkoaamu ei muiden kokeiden takia sovi, tentti on mahdollista myös suorittaa tiistaina 20.10. klo 16:00. Ota tällöin sähköpostitse yhteyttä kurssin vastuuhenkilöön <a href="mailto:avihavai@cs.helsinki.fi">avihavai@cs.helsinki.fi</a>. Kurssikokeessa tulee olemaan sekä kurssin käsitteistön selittämistä että web-sovelluksen suunnittelua.</p>

		<p>Kurssin konetentin voi tehdä aikavälillä 16-23.10. Konetentti suoritetaan TMC:hen tulevan kurssin kautta. Kun palauttaa kurssin ensimmäisen tehtävän, kurssikoe alkaa, ja koetehtävät tulevat ladattavaksi TMC:stä. Konetentille on kolme tuntia aikaa -- konetentissä materiaalin ja netin käyttö on sallittua, mutta kaikki muu kommunikointi kurssin aikana -- esimerkiksi avun kysymyminen tai vastaanottaminen ei ole sallittua. Konetentin kysymyksiä tai vastauksia ei luonnollisesti myöskään saa jakaa muille.</p>
		

                <p><a class="jump" href="#viikoittaiset-teemat" role="button">Viikoittaiset teemat &raquo;</a></p>

                <h1>Esitietovaatimukset ja kurssin suorittaminen</h1>

                <p>Kurssilla oletetaan Java-ohjelmointikielen tuntemus kurssien ohjelmoinnin perusteet ja ohjelmoinnin jatkokurssi laajuudessa. Tämän lisäksi kursseista ohjelmistotekniikan menetelmät, tietokantojen perusteet, ohjelmoinnin harjoitustyö, tietokantasovellus, ja ohjelmistotuotanto on huomattavasti apua.</p>

		<p>Kurssi käyttää TMC-palvelua tehtävien tarkistamisessa. Helsingin yliopistolla järjestettävällä kurssilla TMC-palvelin löytyy osoitteessa <a href="http://tmc.mooc.fi/hy" target="_blank">http://tmc.mooc.fi/hy</a>, kurssin nimenä on <code>hy-s2015-wepa</code>.</p>

		<p>Jos et ole käyttänyt TMC:tä aiemmin, tutustu Ohjelmoinnin perusteiden kurssin ohjeisiin osoitteessa <a href="http://www.cs.helsinki.fi/group/java/s15/" target="_blank">http://www.cs.helsinki.fi/group/java/s15/</a>.</p>

		


                <h2>Luennot ja ohjaus</h2>
		
                <p>Kurssin ainoa luento pidetään keskiviikkona 2.9. kello 14-16 salissa A111.</p>
		
                <p>Kurssilla on kyselymuotoisia ohjaustunteja huoneessa C221 (Linkki) maanantaisin ja perjantaisin kello 12-14. Huoneessa on myös tietokoneita, joilla kurssin tehtäviä voi tehdä.</p>

		<p>Ohjaustunneille tulee ilmoittautua osoitteessa <a href="http://kyselyilmo.herokuapp.com" target="_blank">http://kyselyilmo.herokuapp.com</a> olevan sovelluksen kautta. Jos tunnille ei ole tulossa osallistujia, tuntia ei pidetä.</p> 

		<p>Kurssilla on lisäksi IRC-kanava <code>#wadup</code>, josta löytyy muita kurssilaisia. Muiden auttaminen kanavalla on vapaaehtoista, mutta luonnollisesti suositeltavaa. Auttamisesta hyötyy apua tarvitsevan lisäksi myös auttaja.</p>


                <h1 id="viikoittaiset-teemat">Viikoittaiset teemat -- voivat muuttua kurssin edetessä</h1>


                <ul id="week-toc">
                    <li><a href="#viikko1">Viikko 1</a> Webin peruskomponentit, Spring Bootin alkeet, dynaamiset sivut ja luonnolliset näkymätemplatet, ensimmäinen tietokantasovellus.</li>
                    <li><a href="#viikko2">Viikko 2</a> Palvelinohjelmistojen kerrokset.</li>
                    <li><a href="#viikko3">Viikko 3</a> REST, HTTP ja Sessiot.</li>
                    <li><a href="#viikko4">Viikko 4</a> Palveluorientoituneet arkkitehtuurit, testaamisen perusteet sekä konfiguraatiot.</li>
                    <li><a href="#viikko5">Viikko 5</a> Luonnolliset näkymätemplatet, mediatiedostojen kuten kuvien ja videoiden tallentaminen ja näyttäminen, tietoturva.</li>
                    <li><a href="#viikko6">Viikko 6</a> Web-sovellusten skaalautuminen.</li>
                    <li><a href="#viikko7">Viikko 7</a> Kertaus ja "facebook".</li>
                </ul>


                <h1>Sisällysluettelo</h1>

                <ul class="nav" id="material-toc"></ul>

                <h1>Tehtävät</h1>

                <ul class="nav nav-pills nav-pills-fixed-width" id="tehtavat-toc"></ul>

            </section>
            <!-- END INDEX -->

            <!-- BEGIN WEEK1 -->
            <section class="weeklimit" data-week-id="1">

                <header>
                    <h1 id="viikko1">Viikko 1</h1>
                </header>

                <h1>Aloitus</h1>

                <h2>Web-sovelluksista yleisesti</h2>

                <p>Web-sovellukset koostuvat selain- ja palvelinpuolesta. Käyttäjän koneella toimii selainohjelmisto (esim. <a href="http://chrome.google.com" target="_blank">Google Chrome</a>), jonka kautta käyttäjä tekee pyyntöjä verkossa sijaitsevalle palvelimelle. Kun palvelin vastaanottaa pyynnön, se käsittelee pyynnön ja rakentaa pyynnölle sopivan vastauksen. Vastaus voi sisältää esimerkiksi web-sivun tai tietyssä muodossa olevaa dataa.</p>

                <div class="image">
                    <img src="img/pyynto.png"/>
                    <div>Web-sovellusten käyttäminen: (1) käyttäjä klikkaa linkkiä, (2) selain tekee pyynnön palvelimelle, (3) palvelin käsittelee pyynnön ja rakentaa vastauksen, (4) selaimen tekemään pyyntöön palautetaan vastaus. Vastauksen näyttämistä käyttäjälle ei näytetä tässä kuvassa.</div>
                </div>

                <p>Selainohjelmointiin ja käyttöliittymäpuoleen keskityttäessä painotetaan rakenteen, ulkoasun, ja toiminnallisuuden erottamista toisistaan. Karkeasti voidaan sanoa, että sivun rakenne määritellään <a href="http://en.wikipedia.org/wiki/CSS" target="_blank">HTML</a>-tiedostoilla, ulkoasu <a href="http://en.wikipedia.org/wiki/CSS" target="_blank">CSS</a>-tiedostoilla, ja toiminnallisuus <a href="http://en.wikipedia.org/wiki/JavaScript" target="_blank">JavaScript</a>-tiedostoilla.</p>

                <p>Palvelinpuolen toiminnallisuutta toteutettaessa keskitytään tyypillisesti selainohjelmiston tarvitsevan "APIn" suunnitteluun ja toteutukseen, sivujen muodostamiseen selainohjelmistoa varten, datan tallentamiseen ja käsittelyyn, sekä sellaisten laskentaoperaatioiden toteuttamiseen, joita selainohjelmistossa ei kannata tai voida tehdä.</p>

                <p>Web-sovelluksista puhuttaessa on hyvä erottaa staattiset ja dynaamiset sivut toisistaan. Staattiset sivut ovat sivuja, joiden sisältö on ennalta määrätty, ja jotka palvelin palauttaa suoraan käyttäjälle niitä pyydettäessä. Dynaamiset sivut taas luodaan palvelimella tarvittaessa. Esimerkiksi osoitteessa <a href="http://telkku.com/" target="_blank">http://telkku.com/</a> toimiva web-sovellus luo näytettävän televisio-ohjelmiston dynaamisesti palvelinpuolella: uuden staattisen sivun luominen käsin aina uuden ohjelmatiedon saapuessa olisi erittäin raskasta ja tehotonta. Sivuston tarjoama hakupalvelu mahdollistaa rajattoman määrän erilaisia sivustoja; kukaan ei kirjoittaisi näitä käsin.</p>

                <p>Työpöytäsovelluksia ja web-sovelluksia verrattaessa työpöytäsovellukset tarjoavat enemmän interaktiivisuutta ja nopeutta web-sovelluksiin verraten. Web-sovellukset toisaalta mahdollistavat saumattomat ohjelmistojen päivitykset, helposti jaettavan ja ylläpidettävän datan ja dokumenttien jakamisen, sekä kevyet käyttöliittymät. Olemme viimeisten vuosien aikana todistaneet muutosta, missä web-sovellukset hiljalleen syrjäyttävät perinteiset työpöytäsovellukset, myöskin niissä tapauksissa, joissa sovelluksilla on käyttäjiä vain yksittäisessä paikassa. Tälläkin hetkellä Google tarjoaa kaikille ilmaista toimistotyökalupakettia, elokuvien ja tv-ohjelmien katsominen selainohjelmistossa on helppoa esimerkiksi Yle Areenan tai Netflixin avulla, ja selaimessa pelattavat pelit ovat ohittaneet perinteiset tietokonepelit käyttäjämäärissä jo muutamia vuosia sitten.</p>



                <h2>Ohjelmistojen kehittämisestä</h2>

                <p>Ohjelmistojen kehittämistä verrataan usein naiivisti talojen tai rakennusten rakentamiseen. Taloa suunnitellessa arkkitehdillä on selkeä tehtävä ja etenemissuunnitelma: kerää vaatimukset, tutki vaihtoehtoja, ja luo pohjapiirrustus. Kun arkkitehti on luonut pohjapiirrustuksen, se annetaan urakoitsijalle, jonka pohjalta urakoitsijan palkkaamat työntekijät -- rakennusmiehet -- rakentavat rakennuksen vaadituilla materiaaleilla.</p>

                <p>Ohjelmistoja suunniteltaessa arkkitehti osallistuu sekä ohjelmiston suunnitteluun että kehitykseen, eli rakentamiseen. Koska ohjelmistoista halutaan mahdollisimman nopeasti konkreettista palautetta, arkkitehti aloittaa ohjelmiston suunnittelun perustarpeista: muutamasta huoneesta, joihin palautetta antavat ihmiset muuttavat. Kun alkuperäinen suunnitelma on lähes valmis, rakennukseen muuttaa lisää ihmisiä, jotka tarvitsevat rakennukselta uusia toiminnallisuuksia. Ensisijaisina vaatimuksina ovat uudet huoneet, pesula, disko ja luonnollisesti oleskelutila, jossa on tilaa biljardipöydälle.</p>

                <p>Tällöin arkkitehti muuttaa alkuperäistä suunnitelmaansa ottaen huomioon uudet ihmiset ja kehitystyö jatkuu. Kehitystyön jatkuessa alkuperäiset asukkaat alkavat valittamaan rakennusmelusta ja uhkaavat poismuutolla jos asioihin ei saada muutosta, aiheuttaen hiusten harvenemista arkkitehdille. Toisaalta, sana uudesta biljardipöydästä kiertää, ja yhä enemmän ihmisiä muuttaa rakennukseen, ja rakennukselta vaaditaan taas uusia huoneita sekä cartingrata ja curlinghalli.</p>

                <p>Hyvän suunnittelun perusta on mahdollisuuksien huomiointi. Huomioinnilla ei tarkoiteta sitä, että rakennetaan heti aluksi iso järjestelmä -- käytännössä järjestelmän valmistuessa sille ei olisi käyttäjiä sillä kaikki olisivat siirtyneet toiseen aiemmin tarpeellisia ominaisuuksia tarjonneeseen järjestelmään. Jos alkuperäinen suunnitelma tekee järjestelmän laajentamisesta vaikeaa, käyttäjät saattavat vaihtaa palvelua hitauden takia.</p>

                <p>Kaikkien osapuolten toiveet tyydyttävän ohjelmiston rakentaminen on haastavaa. Jokaista ohjelmistoa joudutaan laajentamaan, rajaamaan ja muokkaamaan. Asiakkaalla tai asiakkailla on käytännössä aina uusia toivomuksia ohjelmiston elinkaaren varrella.</p>

                <p>Arkkitehtuurin tulee mahdollistaa sopivan kokoisesta palasta aloittaminen sekä rakennettavan sovelluksen laajentaminen, myös toisten kehittäjien toimesta. Käytännössä hyvin harvat ohjelmistot ovat vain yhden ihmisen käsialaa, ja laajempaa sovellusta kehitettäessä olemassaolevien ohjelmistokomponenttien hyödyntäminen on oleellista. Ohjelmistoalalla aloittelevan on hyvin vaikea valita sopivia komponentteja olemassaolevasta viidakosta sillä yhtä oikeaa ratkaisua ei yleensä ole.</p>

                <p>Oleelllisinta ohjelmistokehityksessä on kommunikointi niin koodin kautta kuin muita väyliä käyttäen. Avoimeen lähdekoodiin ja online-versionhallintatyökaluihin (esim. GitHub) perustuvat projektit saavat ihmiset eri puolilta maailmaa tekemään työtä yhteisten kiinnostuksenkohteiden takia. Sovittujen käytänteiden (esim. nimeämiskäytänteet, versionhallinta, testaus, dokumentointi ym.) noudattaminen on oleellista sillä heikko suunnittelu ja ylläpidettävyys, esimerkiksi muuttujien huono nimentä, aiheuttavat lähinnä kylmiä väreitä ja ajavat innokkaat ihmiset pois.</p>

                <p>Työkaluja valittaessa tarkoituksena on välttää nurkkaan ajautumista: työkaluista tulee pystyä myös pääsemään eroon. On paljon hyödyllisempää miettiä päivä ja käyttää muutama päivä prototyypin tekemiseen, koska prototyyppiä voidaan parantaa kuukausia, kuin miettiä kuukausi ja sitouttaa itsensä kuukauden aikana luotuun suunnitelmaan. Mitä nopeammin toiminnallisuutta on olemassa, sitä nopeammin siitä saa palautetta.  Toisaalta, mitä vähemmän aikaa yksittäisen toiminnallisuuden toteuttamiseen käytetään, sitä helpommin siitä voi tarpeen vaatiessa hankkiutua eroon.</p>

                <p>Sovelluksia tehdessä, erityisesti prototyyppivaiheessa, otetaankin usein hieman teknistä velkaa ns. "menemällä siitä mistä aita on matalin". Tämä velka maksetaan kuitenkin ennen pitkää takaisin; mitä pidempään sen takaisinmaksussa kestää, sitä suurempi velan korko on.</p> 



                <h2>Kurssin työvälineet</h2>

                <p>Käytämme tällä kurssilla ohjelmointiympäristönä <a href="http://netbeans.org/" target="_blank">NetBeans</a>ia, ohjelmistoprojektien ja komponenttien riippuvuuksien hallintaan <a href="http://maven.apache.org" target="_blank">Maven</a>ia, sekä komentotulkkia. Harjoitustehtävät palautetaan <a href="http://tmc.mooc.fi/hy" target="_blank">Test My Code</a>-palvelimelle NetBeansiin ladattavan Test My Code -liitännäisen avulla.</p>

                <p>Selainpuolella ohjelmistoja tutkitaan <a href="http://chrome.google.com">Google Chrome</a>ssa olevien <a href="https://developers.google.com/chrome-developer-tools/" target="_blank">DevTools</a>ien avulla.</p>

                <h3>NetBeansin ja Test My Coden asennus</h3>

                <p>Test My Coden web-sivu löytyy osoitteesta <a href="http://tmc.mooc.fi/hy">http://tmc.mooc.fi/hy</a>. Valitse sivun ylälaidasta <em>Sign up</em> ja kirjaudu järjestelmään. Jos olet HY:n opiskelija, käytä käyttäjätunnuksena (<em>username</em>) opiskelijanumeroasi, ja anna järjestelmään käyttämäsi sähköpostiosoite. Opiskelijanumeron käyttö opiskelijana on tärkeää: näin tehtävistä saamasi pisteet voidaan liittää sinuun jos osallistut kokeeseen. Kun käyttäjätunnuksesi on luotu ja kirjautuminen onnistuu, jatka eteenpäin.</p>

                <p>NetBeans-sovelluskehitysympäristön ladattua osoitteesta <a href="http://netbeans.org/" target="_blank">http://netbeans.org/</a>. NetBeansin versiota ladattaessa kannattaa valita versio kaikilla mausteilla, eli vaihtoehto "All". Jos NetBeans kysyy haluatko käyttää vanhoja asetuksia sitä käynnistettäessä, kannattaa valita <strong>ei</strong>.</p>

                <p>Test My Code-liitännäisen saa lisättyä NetBeansin pluginvaihtoehdoksi näkyviin valitsemalla Tools -> Plugins. Valitse avautuvasta ikkunasta Settings-välilehti, ja klikkaa uuden liitännäispaikan lisäämiseen tarkoitettua Add-nappia. Anna avautuvaan ikkunaan latauspaikan nimeksi <code>TMC</code>, ja osoitteeksi <code>http://update.testmycode.net/tmc-netbeans_mooc/updates.xml</code>. Valitse lopulta OK.</p>

                <p>Mene tämän jälkeen Available Plugins -välilehdelle ja etsi sieltä vaihtoehto Test My Code NetBeans Plugin. Klikkaa sen vasemmalla puolella olevaa laatikkoa, ja painaa Install. Tämä asentaa Test My Coden NetBeansiisi.</p>

                <p>Kun Test My Code on asentunut, NetBeans haluaa käynnistyä uudestaan. Käynnistä NetBeans uudestaan. Tämän jälkeen NetBeansin valikossa on myös vaihtoehto Test My Code. Käy vielä asettamassa Test My Coden asetukset. Valitse TMC -> Settings, ja täytä avautuvaan ikkunaan tietosi. Käyttäjätunnus on TMC-tunnuksesi, salasanasi TMC:hen liittyvä salasanasi. Valitse kurssiksi <em>opettajalta saamasi tunnus</em>.</p>

                <p>Varmista että myös alaosassa olevat vaihtoehdot ovat valittuina ja paina OK (kurssin kehittämisen kannalta on erittäin tärkeää, että viimeinen vaihtoehto "Send snapshots of your progress for study" on valittu). Tämän jälkeen NetBeans kysyy sinulta ladataanko saatavilla olevat tehtävät. Valitse "Download".</p>

                <p>NetBeans lataa tehtävät, jonka jälkeen ne ovat näkyvissä NetBeans-projekteina. Pieni musta pallo projektin ikonissa tarkoittaa että tehtävää ei ole vielä yritetty. Jos pallo on vihreä, on tehtävästä kerätty kaikki pisteet.</p>



                <h3>Ohjelmistoprojektien hallinta ja Maven</h3>

                <p>Jokaisessa ohjelmistoprojektissa tulee vastaan erilaisia lähdekoodiin liittyviä tarpeita. Lähdekoodia tulee pystyä paketoimaan tuotantopalvelimelle siirettäväksi paketiksi (esim -.jar ja -.war -tiedostot), lähdekoodiin liittyviä testejä tulee pystyä ajamaan erillisellä palvelimella ja lähdekoodista tulee pystyä generoimaan erilaisia raportteja sekä luonnollisesti dokumentaatiota.</p>

                <p>Työkalut kuten <em><a href="http://ant.apache.org/" target="_blank">Apache Ant</a></em> auttavat projektiin liittyvän lähdekoodin hallinnoinnissa ja kääntämisessä. Ant on käytännössä 2000-luvun alun vastine perinteisille Makefile-tiedostoille. Nykyaikaisemmat <em><a href="http://maven.apache.org/" target="_blank">Apache Maven</a></em> ja <em><a href="http://www.gradle.org/" target="_blank">Gradle</a></em> auttavat käännösprosessin lisäksi muunmuassa projektiin liittyvien kirjastoriippuvuuksien automaattisessa hallinnassa. Käytämme tällä kurssilla Mavenia.</p>

                <p>Apache Maven on projektinhallintatyökalu, jota voi käyttää ohjelmakoodikäännösten lisäksi lähes koko projektin elinkaaren hallintaan uuden projektin aloittamisesta lähtien. Maven tarjoaa ohjelmiston elinkaaren hallintaan joukon valmiiksi konfiguroituja vaiheita (<em>phase</em>), joita voidaan suorittaa komentoriviltä. Usein käytettäviä vaiheita ovat mm. <em>test</em>, joka suorittaa projektiin liittyvät testit sekä <em>package</em>, joka paketoi lähdekoodin projektityypistä riippuen sopivaan pakettiin. Oikeastaan Maven on sovelluskehys liitännäisten suoritukseen ja yksinkertaisimmatkin Mavenin tarjoamat toiminnot ovat toteutettu liitännäisinä.</p>

                <p>Jokaisella Maven-projektilla on elinkaari, joka sisältää vaiheet lähtien projektin validoinnista, kääntämisestä ja testaamisesta aina tuotantoon siirtämiseen asti. Tarkempi listaus projektin erilaisista vaiheista löytyy Mavenin <a href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#Lifecycle_Reference" target="_blank">dokumentaatiosta</a>. Kukin vaihe koostuu yhdestä tai useammasta tavoitteesta (<em>goal</em>), jotka suoritetaan vaiheen sisällä. Vaiheet riippuvat myös edellisistä vaiheista; esimerkiksi vaihetta <em>test</em> suoritettaessa Maven suorittaa ensin projektin validoinnin ja kääntämisen.</p>

                <p>Mavenin liitännäisarkkitehtuuri mahdollistaa hyvin monipuolisen toiminnallisuuden. Esimerkiksi raportointia ja staattista koodianalyysiä varten löytyy omat liitännäiset, samoin kuin mahdollisen (web-)palvelimen käynnistämiselle projektin testausta varten. Liitännäisistä löytyy (ei kattava) lista osoitteessa <a href="http://maven.apache.org/plugins/index.html" target="_blank">http://maven.apache.org/plugins/index.html</a>.</p>

                <p>Maven automatisoi uusien projektien luomisen <em>archetype</em>-liitännäisellä. Archetype-liitännäisen avulla ohjelmistokehittäjät voivat tarjota toisilleen valmiita projektirunkoja ja esimerkiksi määritellä yrityksen teknologiavalinnat paketiksi, jonka pohjalta uuden sovelluksen kehittäminen on nopeaa.</p>

                <p>Yksi Mavenin tärkeimmistä ominaisuuksista on tarvittavien kirjastojen eli riippuvuuksien automaattinen lataaminen. Mavenin avulla projektiin voi määritellä riippuvuuden esimerkiksi yksikkötestauskirjastoihin ja käytetyn web-sovelluskehyksen kirjastoihin. Tällöin Maven lataa riippuvuudet automaattisesti ja kirjastoja ei tarvitse pitää esimerkiksi projektikohtaisessa tai paikallisessa versionhallintajärjestelmässä.</p>



                <h3>Mavenin projektirakenne</h3>

                <p>Mavenin archetype-pluginia käyttäen uuden projektin luonti tapahtuu helposti. Luodaan uusi projekti, jota tarkastelemme seuraavaksi. Uuden projektin luominen onnistuu komentoriviltä esimerkiksi seuraavan komennon avulla.</p>

                <pre>mvn archetype:generate -DgroupId=fi.organisaatio -DartifactId=sovelluksen-nimi</pre>

                <p>Käytännössä komennossa <code>mvn archetype:generate</code> kutsutaan Mavenin archetype-liitännäiseen liittyvää tavoitetta <code>generate</code> ja annetaan sille kaksi parametria. Parametrilla <code>-DgroupId</code> kerrotaan katto-organisaation tai ryhmän tunnus, parametrilla <code>-DartifactId</code> kerrotaan luotavan sovelluksen nimi.</p>

                <p>Komento hakee archetype-pluginista valmit projektipohjat, ja kysyy ensin mitä pohjaa haluat käyttää. Tämän jälkeen Maven kyselee muita tietoja luotavasta projektista. Koska haluamme vain tutustua tässä Mavenin projektirakenteeseen, vastaillaan kysymyksiin enter-painalluksilla. Tällöin Maven käyttää oletusvastauksia.</p>

                <p>Kun projekti on luotu, sillä on seuraavanlainen kansiorakenne.</p>

                <pre>
sovelluksen-nimi
 ├── pom.xml
 └── src
     ├── main
     │   └── java
     │       └── fi
     │           └── organisaatio
     │               └── App.java
     └── test
         └── java
             └── fi
                 └── organisaatio
                     └── AppTest.java
                </pre>

                <p>Sovelluksen ja testien lähdekoodit ovat eritelty erillisiin kansioihin. Projektin alla olevassa kansiossa <code>src</code> on projektiin liittyvät lähdekoodit. Kansion <code>src</code> alla on kansiot <code>main</code> ja <code>test</code>, joissa toisessa on projektiin liittyvää koodia, ja toisessa projektiin liittyvät testit. Maven-projektin konfiguraatiotiedosto <code>pom.xml</code> on projektin juuressa.</p>

                <p>Projektin luominen valmiista archetype-projekstista onnistuu myös NetBeansissa. Valitsemalle File -&gt; New Project pääsee projektivalikkoon, josta löytyy kategoria Maven. Kun vaihtoehto "Project from Archetype" valitaan käyttäjä pääsee selaamaan saatavilla olevia vaihtoehtoja. Archetypen valinnan jälkeen projektille annetaan nimi ja aloitetaan sovelluksen kehittäminen. </p>


                <h3>Mavenin "pom.xml": Project Object Model</h3>

                <p>Tiedoston pom.xml osa <strong>pom</strong> tulee sanoista <em>Project Object Model</em>. XML-muotoinen pom-tiedosto sisältää projektiin liittyvän rakenteen, asetukset, kirjastoriippuvuudet ja tarvittaessa määritellyt tavoitteet. Yksinkertaisimmillaan pom.xml -tiedosto sisältää kuvauksen organisaatiosta, projektin nimestä, versiosta ja lähdekoodin pakkausmuodosta. Edellisessä osiossa komentorivillä luodun projektin pom.xml -sisältö näyttää seuraavalta.</p>

                <pre class="sh_xml">
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;groupId&gt;fi.organisaatio&lt;/groupId&gt;
  &lt;artifactId&gt;sovelluksen-nimi&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;name&gt;sovelluksen-nimi&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;

  &lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
  &lt;/properties&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</pre>

                <p>Alussa on XML-tiedoston otsake, joka määrittelee käytetyn <a href="http://www.w3schools.com/schema/schema_intro.asp" target="_blank">XML-skeeman</a>. Tämän jälkeen määritellään projektin tiedot (groupId = ryhmä, artifactId = projekti, version = projektin versio, packaging = pakkausmuoto). Tämän jälkeen tulee sovelluksen nimi (usein sama kuin projekti), sekä projektiin liittyvä osoite. Näitä seuraa projektiin liittyvät asetukset – yllä olevassa tiedostossa on määritelty projekti käyttämään UTF-8 -merkistökoodausta.</p>

                <p>Dependencies-osiossa määritellään kirjastot, joita projekti tarvitsee. Esimerkissä projektille on määritelty riippuvuus yksikkötestauksessa käytettävään JUnit-sovelluskirjastoon, jonka Maven lataa automaattisesti. Riippuvuuden <code>scope</code>-osiolla voidaan määritellä vaihe, johon riippuvuus liittyy. Yllä olevassa esimerkissä JUnit-kirjastoa on käytössä vain <code>test</code>-vaiheessa. Käytännössä siis JUnit on käytössä vain testausta varten, mutta se ei tule olemaan mukana asiakkaalle lähetettävässä valmiissa sovelluksessa.</p>

                <aside class="extra">
                    <h1>XML?!</h1>

                    <p>XML (Extensible Markup Language) on laitteistoriippumaton tapa tiedon tallentamiseen siten, että tallennusmuodossa välittyy myös tiedon rakenne. XML-dokumentteja käytetään mm. grafiikan (SVG), tekstidokumenttien (OOXML) ja erilaisten asetustiedostojen tallentamiseen. Tällä kurssilla XML esiintyy projektien asetuksia muokatessa.</p>

                    <p><a href="http://www.w3schools.com/xml/xml_whatis.asp" target="_blank">W3Schoolsin XML-opas</a></p>
                </aside>


                <h3>Maven ja riippuvuuksien hallinta</h3>


                <p>Projektikonfiguraatiossa (<code>pom.xml</code>) olevassa dependencies-osiossa määritellään kirjastot, joita projekti käyttää. Riippuvuuksia ei ole pakko olla yhtäkään, tai niitä voi olla useita. Käytettävät kirjastot riippuvat usein myös muista kirjastoista. Maven (versiosta 2 lähtien) lataa automaattisesti myös käytettävien kirjastojen tarvitsemat riippuvuudet: esimerkiksi JUnit-kirjaston uusin versio tarvitsee avukseen hamcrest-nimisen kirjaston (kts. "This artifact depends on..." osoitteessa <a href="http://mvnrepository.com/artifact/junit/junit/4.11" target="_blank">http://mvnrepository.com/artifact/junit/junit/4.11</a>). Voimme kuitenkin määritellä riippuvuudeksi JUnit-kirjaston ja antaa Mavenin hoitaa loput. </p>

                <p>Projekti voi myös periä jonkun toisen projektin konfiguraation. Elementti &lt;parent&gt; kertoo perittävän komponentin tiedot. Esimerkiksi, seuraavalla konfiguraatiolla kerromme, että perimme <code>spring.framework.boot</code>-ryhmän <code>spring-boot-starter-parent</code> -projektin version <code>1.1.6.RELEASE</code>.</p>

                <pre class="sh_xml">
  &lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;1.1.6.RELEASE&lt;/version&gt;
  &lt;/parent&gt;</pre>

                <p>Lisää tietoa riippuvuuksien hallinnasta löytyy mavenin <a href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html" target="_blank">dokumentaatiosta</a>. Hyviä paikkoja kirjastojen etsimiseen ovat muun muassa <a href="http://search.maven.org/" target="_blank">http://search.maven.org/</a> ja <a href="http://mvnrepository.com/" target="_blank">http://mvnrepository.com/</a>.</p>


                <h3>Mavenin valmiita komentoja</h3>

                <p>Kirjoittaessamme pom.xml-tiedoston sisältävässä kansiossa komennon <code>mvn</code>, näemme viestin, joka valittaa komennon puuttumisesta. Viestin konkreettinen sisältö riippuu mavenin versiosta, esimerkiksi mavenin versiossa 2 oleellinen sisältö on seuraavanlainen. Kolmosversiossa viesti on vaikealukuisempi...</p>

                <pre>
$ mvn
...
You must specify at least one goal or lifecycle phase to perform build steps.
The following list illustrates some commonly used build commands:

  mvn clean
    Deletes any build output (e.g. class files or JARs).
  mvn test
    Runs the unit tests for the project.
  mvn install
    Copies the project artifacts into your local repository.
  mvn deploy
    Copies the project artifacts into the remote repository.
  mvn site
    Creates project documentation (e.g. reports or Javadoc).

Please see
http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html
for a complete description of available lifecycle phases.
...
                </pre>


                <p>Selaamalla osoitteeseen <a href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html" target="_blank">http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html</a> näemme tarkemman listan toiminnoista, joita maven tarjoaa ohjelmistoprojektin eri vaiheisiin.</p>

                <h3>Testien suorittaminen</h3>

                <p>Projektiin liittyvät testit suoritetaan käyttämällä mavenin vaihetta <code>test</code>. Käytännössä kukin vaihe liittyy johonkin tiettyyn pluginiin, esimerkiksi test-vaiheessa suoritetaan <code><a href="http://maven.apache.org/plugins/maven-surefire-plugin/" target="_blank">surefire</a></code>-pluginin tavoite <code>test</code>. Lisätietoja vaiheiden oletusplugineista löytyy <a href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#Setting_Up_Your_Project_to_Use_the_Build_Lifecycle" target="_blank">täältä</a>.</p>

                <p>Suoritetaan testit antamalla projektikansiossa komento <code>mvn test</code> (saman voi tehdä myös NetBeansissa valitsemalla projektin oikealla hiiren napilla ja painamalla "Test").</p>

                <pre>
$ mvn test
// tulostusta...
[INFO] ------------------------------------------------------------------------
[INFO] Building sovelluksen-nimi 1.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
// tulostusta...
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running fi.organisaatio.AppTest
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.016 sec

Results :

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0

[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
// tulostusta
                </pre>

                <p>Käytännössä projektiin liittyvät testitiedostot, joita komentorivin kautta luomassamme esimerkkiprojektissa on vain 1, suoritetaan. Jos testeissä on ongelmia, mavenista pääsee käsiksi niihin liittyviin raportteihin.</p>

                <p>Projektin konfiguraation muokkaus on helppoa kun tietää mitä tekee. Esimerkiksi yksikkötestauskirjaston JUnit version vaihtaminen vanhasta versiosta 3.8.1 versioon 4.11 onnistuu helposti. Käytännössä vain <code>version</code>-tägin sisältö tulee vaihtaa:</p>


                <pre class="sh_xml">
  ...
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;4.11&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  ...
                </pre>

                <p>Jos testit suoritetaan nyt uudestaan komennolla <code>mvn test</code>, huomataan että Maven lataa JUnit-version 4.11 käyttöösi. Koska JUnit on taaksepäin yhteensopiva, testit menevät läpi.</p>

                <aside class="extra">

                    <h1>Riippuvuuksien lataamisen manuaalinen käynnistäminen NetBeansissa</h1>

                    <p>Jos NetBeans-projektin kuvakkeessa on keltainen kolmio sekä lähdekoodikansioissa mahdollinen punainen pallo, saat lisätietoa ongelmasta viemällä hiiren projektin nimen päälle.</p>

                    <p>Jos ongelmana näkyy teksti "Some dependency artifacts are not in the local repository.", eli osaa riippuvuuksista ei ole ladattu paikalliselle koneelle, voit valita oikealla hiirennäppäimellä Dependencies ja "Download Declared Dependencies". Nyt NetBeans pyytää Mavenia lataamaan riippuvuudet.</p>

                    <p>Riippuvuudet ladataan käyttäjän kotihakemiston alla olevaan kansioon ".m2".</p>

                </aside>


                <h1>Webin peruskomponentit</h1>

                <p><em>"I just had to take the hypertext idea and connect it to the TCP and DNS ideas and – ta-da! – the World Wide Web."</em> -- <a href="http://en.wikipedia.org/wiki/Tim_Berners-Lee" target="_blank">Tim Berners-Lee</a></p>


                <p>Webin peruskomponentit ovat (1) URI (<em>Uniform Resource Identifier</em>) ja DNS (<em>Domain Name Services</em>) , jotka mahdollistavat resurssien ja palveluiden yksilöinnin, (2) HTTP (<em>HyperText Transfer Protocol</em>), joka on protokolla viestien lähetykseen verkon yli, sekä (3) HTML (<em>HyperText Markup Language</em>), eli yhteinen dokumenttien esityskieli.</p>

                <h2>URI ja DNS</h2>

                <p><em>"The most important thing that was new was the idea of URI-or URL, that any piece of information anywhere should have an identifier, which will allow you to get hold of it."</em> -- Tim Berners-Lee</p>

                <p>Verkossa sijaitseva sivusto tunnistetaan sille annetun yksilöivän osoitteen perusteella. Osoite (URI eli Uniform Resource Identifier, terminä käyttöön jäänyt URL <em>Uniform Resource Locator</em>) koostuu resurssin nimestä ja sijainnista, joiden perusteella haluttu palvelin ja resurssi voidaan löytää verkossa olevien koneiden massasta.</p>

                <p>Kun käyttäjä kirjoittaa web-selaimen osoitekenttään URIn ja painaa enteriä, web-selain tekee kyselyn annettuun osoitteeseen. Koska tekstimuotoiset osoitteet ovat käytännössä vain ihmisiä varten, kääntää selain ensiksi halutun osoitteen numeeriseksi IP-osoitteeksi. Jos IP-osoite on jo tiedossa esimerkiksi aiemmin osoitteeseen tehdyn kyselyjen takia, selain voi ottaa yhteyden IP-osoitteeseen. Jos taas IP-osoite ei ole tiedossa, tulee selaimen ensin tehdä kysely <a href="http://fi.wikipedia.org/wiki/DNS" target="_blank">DNS</a>-palvelimelle (<em>Domain Name System</em>), jonka tehtävänä on muuntaa tekstuaaliset osoitteet IP-osoitteiksi (esim. Tietojenkäsittelytieteen laitoksen kotisivu <code>http://www.cs.helsinki.fi</code> on IP-osoitteessa <code>128.214.166.78</code>). Ilman DNS-palvelimia ihmisten tulisi muistaa IP-osoitteet ulkoa, joka käytännössä tarkoittaisi ettei nykyinen internet toimisi.</p>

                <p>IP-osoitteet yksilöivät tietokoneet ja mahdollistavat koneiden löytämisen verkon yli. Käytännössä yhteys IP-osoitteen määrittelemään koneeseen avataan sovellustason HTTP-protokollan avulla kuljetustason TCP-protokollan yli. TCP-protokollan tehtävänä on varmistaa, että viestit pääsevät perille. Lisää tietoa konkreettisesta tietoliikenteestä kurssilla <a href="http://www.cs.helsinki.fi/courses/582202" target="_blank">Tietoliikenteen perusteet</a>.</p>

                <p>Käytännössä URIt näyttävät seuraavilta:</p>

                <pre>
protokolla://isäntäkone[:portti]/polku/../[kohdedokumentti][?kyselyparametrit][#ankkuri]
                </pre>

                <p>
                <ul>
                    <li>protokolla: kyselyssä käytettävä protokolla, esimerkiksi HTTP, FTP tai SSH.</li>
                    <li>isäntäkone: kone tai palvelin johon luodaan yhteys. Voi olla joko IP-osoite tai tekstuaalinen kuvaus (esim www.cs.helsinki.fi).</li>
                    <li>portti: portti isäntäkoneella johon yhteys luodaan. HTTP-palvelimien oletusportti on 80. Jos palvelin käyttää eri porttinumeroa kuin 80, tulee se merkitä osoitteeseen. Portti käytännössä määrittelee prosessin, johon yritetään ottaa yhteyttä.</li>
                    <li>polku: periaatteessa polku resurssiin palvelimella. Käytännössä (nykyään) palvelun osoite, johon palvelin osaa osoittaa. Usein palvelut toimivat erillisessä koneessa sisäverkossa, ja ulkoverkkoon näkyvä kone vain toimii ohjaajana eli proxynä oikeaan palveluun.</li>
                    <li>kohdedokumentti: haettava resurssi, jos kohdedokumenttia ei ole määritelty palvelin päättelee oletusdokumentin. Usein index.html</li>
                    <li>kyselyparametrit: koostuu avain-arvo -pareista, joiden avulla palvelimelle pystyy toteuttamaan lisätoiminnallisuutta. Kuhunkin avaimeen liittyvä arvo esitetään = -merkillä, avain-arvo -parit erotetaan toisistaan &-merkillä.</li>
                    <li>ankkuri: kertoo mihin kohtaan dokumentissa tulee mennä.</li>
                </ul>
                </p>

                <aside class="pohdi">
                    <h1>Osoitteen osat</h1>

                    <p>Tutki osoitetta <a href="http://www.googlefight.com/index.php?lang=en_GB&word1=Batman&word2=Superman" target="_blank">http://www.googlefight.com/index.php?lang=en_GB&word1=Batman&word2=Superman</a>. Mitkä tai mikä ovat/on osoitteen:</p>

                    <ul>
                        <li>protokolla</li>
                        <li>isäntäkone</li>
                        <li>portti</li>
                        <li>polku</li>
                        <li>kohdedokumentti</li>
                        <li>kyselyparametrit</li>
                        <li>ankkuri</li>
                    </ul>

                    <p>Mitkä näistä puuttuvat?</p>
                </aside>


                <h2>HTTP</h2>

                <p>HTTP (<em>HyperText Transfer Protocol</em>) on TCP/IP -protokollapinon sovellustason protokolla, jota web-palvelimet ja selaimet käyttävät kommunikointiin. HTTP-protokolla perustuu asiakas-palvelin malliin, jossa jokaista pyyntöä kohden on yksi vastaus (<em>request-response paradigm</em>). Käytännössä HTTP-asiakasohjelma (jatkossa selain) lähettää HTTP-viestin HTTP-palvelimelle (jatkossa palvelin), joka palauttaa HTTP-vastauksen. HTTP-protokollan versio 1.1 on määritelty <a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html" target="_blank">RFC 2616</a>-spesifikaatiossa.</p>

                <h5>Asiakas-palvelin malli</h5>

                <p>Asiakas-palvelin -mallissa <em>(Client-Server model)</em> asiakkaat käyttävät palvelimen tarjoamia palveluja. Kommunikointi asiakkaan ja palvelimen välillä tapahtuu usein verkon yli siten, että asiakasohjelmisto ja palvelinohjelmisto sijaitsevat erillisissä fyysisissä sijainneissa (eri tietokoneilla). Palvelinohjelmisto tarjoaa yhden tai useamman palvelun, joita asiakasohjelmisto käyttää.</p>

                <p>Käytännössä asiakasohjelmisto tarjoaa käyttöliittymän ohjelmiston käyttäjälle. Asiakasohjelmiston käyttäjän ei tarvitse tietää, että kaikki käytetty tieto ei ole hänen koneella. Käyttäjän tehdessä toiminnon asiakasohjelmisto pyytää tarpeen vaatiessa palvelimelta käyttäjän tarpeeseen liittyvää lisätietoa. Tyypillistä mallille on se, että palvelin tarjoaa vain asiakkaan pyytämät tiedot ja verkossa liikkuvan tiedon määrä pidetään vähäisenä.</p>

                <p>Asiakas-palvelin -malli mahdollistaa hajautetut ohjelmistot: asiakasohjelmistoa käyttävät loppukäyttäjät voivat sijaita eri puolilla maapalloa palvelinohjelmiston sijaitessa tietyssä paikassa.</p>


                <aside class="pohdi">
                    <h1>Chuck Norris</h1>

                    <p>Selaa osoitteeseen <a href="http://www.imdb.com" target="_blank">http://www.imdb.com</a>. Kirjoita sivuston ylälaidassa olevaan kenttään "Chuck Norris" ja paina Enter. Mitkä seuraavista askeleista tapahtuivat asiakasohjelmistossa, mitkä palvelinohjelmistossa, mitkä muualla? Voit olettaa että asiakasohjelmistolla tarkoitetaan käyttämääsi web-selainta.</p>

                    <ol>
                        <li>Näppäimistön avulla kirjoittamasi osoitetekstin näyttäminen.</li>
                        <li>Osoitetta http://www.imdb.com vastaavan IP-osoitteen etsiminen.</li>
                        <li>Sivun http://www.imdb.com näyttäminen.</li>
                        <li><span title="YOU CAN'T FIND CHUCK NORRIS, CHUCK NORRIS FINDS YOU">Chuck Norriksen etsiminen.</span></li>
                    </ol>
                </aside>

                <p>Haasteena perinteisessä asiakas-palvelin mallissa on se, että palvelin sijaitsee yleensä tietyssä keskitetyssä sijainnissa. Keskitetyillä palveluilla on mahdollisuus ylikuormittua asiakasmäärän kasvaessa. Kapasiteettia rajoittavat muun muassa palvelimen fyysinen kapasiteetti (rauta), palvelimeen yhteydessä olevan verkon laatu ja nopeus, sekä tarjotun palvelun tyyppi. Esimerkiksi pyynnöt, jotka johtavat tiedon tallentamiseen, vievät tyypillisesti enemmän resursseja kuin pyynnöt, jotka tarvitsevat vain staattista sisältöä.</p>


                <h3>HTTP-viestin rakenne: palvelimelle lähetettävä kysely</h3>

                <p>HTTP-protokollan yli lähetettävät viestit ovat tekstimuotoisia. Viestit koostuvat riveistä jotka muodostavat otsakkeen, sekä riveistä jotka muodostavat viestin rungon. Viestin runkoa ei ole pakko olla olemassa. Viestin loppuminen ilmoitetaan kahdella peräkkäisellä rivinvaihdolla.</p>

                <p>Palvelimelle lähetettävän viestin, eli kyselyn, ensimmäisellä rivillä on pyyntötapa, halutun resurssin polku ja HTTP-protokollan versionumero.</p>

                <pre>
PYYNTÖTAPA /POLKU_HALUTTUUN_RESURSSIIN HTTP/versio
otsake-1: arvo
otsake-2: arvo

valinnainen viestin runko</pre>

                <p>Pyyntötapa ilmaisee HTTP-protokollassa käytettävän pyynnön tavan (esim. <code>GET</code> tai <code>POST</code>), polku haluttuun resurssiin kertoo haettavan resurssin sijainnin palvelimella (esim. <code>/index.html</code>), ja HTTP-versio kertoo käytettävän version (esim. <code>HTTP/1.0</code>). Alla esimerkki hyvin yksinkertaisesta -- joskin yleisestä -- pyynnöstä. Huomaa että pyyntöä tehdessä yhteys palvelimeen on jo muodostettu, eli palvelimen osoitetta ei merkitä erikseen.</p>

                <pre>
GET /index.html HTTP/1.0</pre>

                <p>Yksittäisen koneen dedikointi web-palvelimeksi jättää usein huomattavan osan koneen kapasiteetista käyttämättä. Nykyään yleisesti käytössä oleva HTTP/1.1 -protokolla mahdollistaa useamman palvelimen pitämisen samassa IP-osoitteessa virtuaalipalvelintekniikan avulla, jolloin yksittäiset palvelinkoneet voivat sisältää useita palvelimia. Käytännössä IP-osoitetta kuunteleva kone voi joko itsessään sisältää useita ohjelmistoilla emuloituja palvelimia, tai se voi toimia reitittimenä ja ohjata pyynnön tietylle esimerkiksi yrityksen sisäverkossa sijaitsevalle koneelle. Kun yksittäinen IP-osoite voi sisältää useampia palvelimia, pelkkä polku haluttuun resurssiin ei riitä oikean resurssin löytämiseen: resurssi voisi olla millä tahansa koneeseen liittyvällä virtuaalipalvelimella. HTTP/1.1 -protokollassa on pyynnöissä pakko olla mukana käytetyn palvelimen osoitteen kertova <code>Host</code>-otsake.</p>

                <pre>
GET /index.html HTTP/1.1
Host: www.munpalvelin.net</pre>

                <h3>HTTP-viestin rakenne: palvelimelta saapuva vastaus</h3>

                <p>Palvelimelle tehtyyn pyyntöön saadaan aina jonkinlainen vastaus. Jos tekstimuotoiseen osoitteeseen ei ole liitetty IP-osoitetta DNS-palvelimilla, selain ilmoittaa ettei palvelinta löydy. Jos palvelin löytyy, ja pyyntö saadaan tehtyä palvelimelle asti, tulee palvelimen myös vastata jollain tavalla.</p>

                <p>Palvelimelta saatavan vastauksen sisältö on seuraavanlainen. Ensimmäisellä rivillä HTTP-protokollan versio, viestiin liittyvä statuskoodi, sekä statuskoodin selvennys. Tämän jälkeen on joukko otsakkeita, tyhjä rivi, ja mahdollinen vastausrunko. Vastausrunko ei ole pakollinen.</p>

                <pre>
HTTP/versio statuskoodi selvennys
otsake-1: arvo
otsake-2: arvo

valinnainen vastauksen runko
                </pre>

                <p>Esimerkiksi:</p>

                <pre>
HTTP/1.1 200 OK
Date: Mon, 01 Sep 2014 03:12:45 GMT
Server: Apache/2.2.14 (Ubuntu)
Vary: Accept-Encoding
Content-Length: 973
Connection: close
Content-Type: text/html;charset=UTF-8

.. runko ..</pre>

                <p>Kun palvelin vastaanottaa tiettyyn resurssiin liittyvän pyynnön, tekee se resurssiin mahdollisesti liittyviä toimintoja ja palauttaa lopulta vastauksen. Kun selain saa vastauksen, tarkistaa se vastaukseen liittyvän <a href="http://httpcats.herokuapp.com/" target="_blank">statuskoodin</a> ja siihen liittyvät tiedot. Tämän jälkeen selain päättelee, mitä vastauksella tehdään, ja esimerkiksi tuottaa vastaukseen liittyvän web-sivun käyttäjälle.</p>

                <aside class="extra">
                    <p><strong>Google Dev Tools</strong></p>

                    <p>Google Chromen DevTools-apuvälineet löytää Tools-valikosta tai painamalla F12 (Linux). Apuvälineillä voi esimerkiksi tarkastella verkkoliikennettä ja lähetettyjä ja vastaanotettuja paketteja. Valitsemalla työvälineistä Network-välilehden, ja lataamalla sivun uudestaan, näet kaikki sivua varten ladattavat osat sekä kunkin osan lataamiseen kuluneen ajan.</p>

                </aside>

                <h3>Statuskoodit</h3>

                <p>Statuskoodit (<em>status code</em>) kuvaavat palvelimella tapahtunutta toimintaa kolmella numerolla. Statuskoodien avulla palvelin kertoo mahdollisista ongelmista tai tarvittavista lisätoimenpiteistä. Yleisin statuskoodi on <code>200</code>, joka kertoo kaiken onnistuneen oikein. HTTP/1.1 sisältää viisi kategoriaa vastausviesteihin.</p>

                <ul>
                    <li>1**: informaatioviestit (esim 100 "Continue")</li>
                    <li>2**: onnistuneet tapahtumat (esim 200 "OK")</li>
                    <li>3**: asiakasohjelmistolta tarvitaan lisätoimintoja (esim 301 "Moved Permanently" tai 304 "Not Modified" eli hae välimuistista)</li>
                    <li>4**: virhe pyynnössä tai erikoistilanne (esim 401 "Not Authorized" ja 404 "Not Found")</li>
                    <li>5**: virhe palvelimella (esim 500 "Internal Server Error")</li>
                </ul>

                <p>Humoristisia kuvia statuskoodeista löytyy osoitteesta <a href="http://httpcats.herokuapp.com" target="_blank">http://httpcats.herokuapp.com</a>.</p>


                <aside class="extra">
                    <h1>HTTP-liikenteen testaaminen telnet-työvälineellä</h1>

                    <p>Linux-ympäristöissä on käytössä telnet-työkalu, jota voi käyttää yksinkertaisena asiakasohjelmistona pyyntöjen simulointiin. Telnet-yhteyden tietyn koneen tiettyyn porttiin saa luotua komennolla <code>telnet isäntäkone portti</code>. Esimerkiksi TKTL:n www-palvelimelle saa yhteyden seuraavasti:</p>

                    <pre>
$ telnet cs.helsinki.fi 80
                    </pre>

                    <p>Tätä seuraa telnetin infoa yhteyden muodostamisesta, jonka jälkeen pääsee kirjoittamaan pyynnön.</p>

                    <pre>
Trying 128.214.166.78...
Connected to cs.helsinki.fi.
Escape character is '^]'.

                    </pre>

                    <p>Yritetään pyytää HTTP/1.1 -protokollalla juuridokumenttia. Huom! HTTP/1.1 -protokollassa tulee pyyntöön lisätä aina Host-otsake. Jos yhteys katkaistaan ennen kuin olet saanut kirjoitettua viestisi loppuun, ota apuusi tekstieditori ja copy-paste. Muistathan myös että viesti lopetetaan aina kahdella rivinvaihdolla.</p>

                    <pre>
GET / HTTP/1.1
Host: cs.helsinki.fi

                    </pre>

                    <p>Palvelin lähettää meille vastauksen, jossa on statuskoodi ja otsakkeita sekä dokumentin runko.</p>

                    <pre>
HTTP/1.1 302 Found
Date: Mon, 02 Sep 2013 18:31:30 GMT
Server: Apache/2.2.14 (Ubuntu)
Location: http://www.cs.helsinki.fi/
Vary: Accept-Encoding
Content-Length: 290
Content-Type: text/html; charset=iso-8859-1

&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;
&lt;html&gt;&lt;head&gt;
&lt;title&gt;302 Found&lt;/title&gt;
&lt;/head&gt;&lt;body&gt;
&lt;h1&gt;Found&lt;/h1&gt;
&lt;p&gt;The document has moved &lt;a href="http://www.cs.helsinki.fi/"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;address&gt;Apache/2.2.14 (Ubuntu) Server at cs.helsinki.fi Port 80&lt;/address&gt;
&lt;/body&gt;&lt;/html&gt;
                    </pre>

                    <p>Juuripolkua palvelimelta <code>cs.helsinki.fi</code> haettaessa palvelin vastaa että dokumentti on löytynyt (<code>302 Found</code>), mutta se sijaitsee muualla (<code>Location: http://www.cs.helsinki.fi/</code>).</p>

                </aside>

                <aside class="pohdi">
                    <h1>Kuinka monta hyppyä?</h1>

                    <p>Käytä telnetiä ja aloita osoitteesta <code>cs.helsinki.fi</code>, tavoitteenasi on päästä laitoksen etusivulle <code>http://www.cs.helsinki.fi/home/</code>. Kuinka monta uudelleenohjausta saat ennenkuin pääset etusivulle?</p>

                    <p>Jos et ehdi kirjoittamaan komentoa telnet-ikkunaan, voit ensin kirjoittaa sen esimerkiksi tekstieditoriin, ja kopioida sen sieltä telnet-ikkunaan.</p>

                </aside>

                <h3>HTTP-protokollan pyyntötavat</h3>

                <p>HTTP-protokolla määrittelee kahdeksan erillistä pyyntötapaa (Request method), joista yleisimmin käytettyjä ovat <code>GET</code> ja <code>POST</code>. Pyyntötavat määrittelevät rajoitteita ja suosituksia viestin rakenteeseen ja niiden prosessointiin palvelinpäässä. Esimerkiksi <a href="http://jcp.org/aboutJava/communityprocess/mrel/jsr154/index2.html" target="_blank">Java Servlet API (versio 2.5)</a> sisältää seuraavan suosituksen GET-pyyntotapaan liittyen:</p>

                <p><em>The GET method should be safe, that is, without any side effects for which users are held responsible. For example, most form queries have no side effects. If a client request is intended to change stored data, the request should use some other HTTP method.</em></p>

                <p>Suomeksi yksinkertaistaen: Palvelinpuolen toiminnallisuutta suunniteltaessa kannattaa pyrkiä tilanteeseen, missä <code>GET</code>-tyyppisillä pyynnöillä ei voida muuttaa palvelimella olevaa dataa.</p>

                <h4>GET</h4>

                <p>GET-pyyntötapaa käytetään esimerkiksi dokumenttien hakemiseen: kun kirjoitat osoitteen selaimen osoitekenttään ja painat enter, selain tekee GET-pyynnön. GET-pyynnöt eivät tarvitse otsaketietoja HTTP/1.1:n vaatiman Host-otsakkeen lisäksi. Mahdolliset kyselyparametrit lähetetään palvelimelle osana haettavaa osoitetta.</p>

                <pre>
GET /sivu.html?porkkana=1 HTTP/1.1
Host: palvelimen-osoite.net

                </pre>

                <h4>POST</h4>

                <p>Käytännön ero POST- ja GET-kyselyn välillä on se, että POST-tyyppisillä pyynnoillä kyselyparametrit liitetään pyynnön runkoon. Rungon sisältö ja koko määritellään otsakeosiossa. POST-kyselyt mahdollistavat multimedian (kuvat, videot, musiikki, ...) lähettämisen palvelimelle.</p>

                <pre>
POST /sivu.html HTTP/1.1
Host: palvelimen-osoite.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

porkkana=1
                </pre>

                <h2>HTML</h2>

                <p><em>"In '93 to '94, every browser had its own flavor of HTML. So it was very difficult to know what you could put in a Web page and reliably have most of your readership see it."</em> -- Tim Berners-Lee</p>

                <p>HTML on rakenteellinen kuvauskieli, jolla voidaan esittää linkkejä sisältävää tekstiä sekä tekstin rakennetta. HTML koostuu elementeistä, jotka voivat olla sisäkkäin ja peräkkäin. Elementtejä käytetään ohjeina dokumentin jäsentämiseen ja käyttäjälle näyttämiseen. HTML-dokumenteissa elementit avataan elementin nimen sisältävällä pienempi kuin -merkillä (&lt;) alkavalla ja suurempi kuin -merkkiin (&gt;) loppuvalla merkkijonolla (&lt;elementin_nimi&gt;), ja suljetaan merkkijonolla jossa elementin pienempi kuin -merkin jälkeen on vinoviiva (&lt;/elementin_nimi&gt;).</p>

                <p>HTML-dokumentin rakennetta voi ajatella myös puuna. Juurisolmuna on elementti <code>&lt;html&gt;</code>, jonka lapsina ovat elementit <code>&lt;head&gt;</code> ja <code>&lt;body&gt;</code>.</p>

                <p>Jos elementin sisällä ei ole muita elementtejä tai tekstisolmuja eli tekstiä, voi elementin yleensä avata ja sulkea samalla merkkijonolla: (&lt;elementin_nimi /&gt;).</p>

                <p>HTML:stä on useita erilaisia standardeja, joista viimeisin julkaistu versio on <a href="http://www.w3.org/TR/html5/" target="_blank">HTML5</a> -- myös versio <a href="http://www.w3.org/TR/html51/" target="_blank">5.1</a> työstetään tällä hetkellä (päivitetty 28.8.2015).</p>

                <pre class="sh_xml">
&lt;!DOCTYPE html&gt;
&lt;html lang="fi"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;title&gt;selainikkunassa näkyvä otsikko&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Tekstiä tekstielementin sisällä, tekstielementti runkoelementin sisällä,
       runkoelementti html-elementin sisällä. Elementin sisältö voidaan asettaa
       useammalle riville.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>

                <p>Ylläoleva HTML5-dokumentti sisältää dokumentin tyypin ilmaisevan aloitustägin (<code>&lt;!DOCTYPE html&gt;</code>), dokumentin aloittavan html-elementin (<code>&lt;html&gt;</code>), otsake-elementin ja sivun otsikon (<code>&lt;head&gt;</code>, jonka sisällä <code>&lt;title&gt;</code>), sekä runkoelementin (<code>&lt;body&gt;</code>).</p>

                <p>Elementit voivat sisältää attribuutteja ja attribuuteille voi antaa arvoja. Esimerkiksi ylläolevassa esimerkissä html-elementille on määritelty erillinen attribuutti <em>lang</em>, joka kertoo dokumentissa käytetystä kielestä.  Ylläolevan esimerkin otsakkeessa on myös metaelementti, jota käytetään lisävinkin antamiseen selaimelle: "dokumentissa käytetään UTF-8 merkistöä". Tämä kannattaa olla dokumenteissa aina.</p>

                <p>Nykyaikaiset web-sivut sisältävät paljon muutakin kuin sarjan HTML-elementtejä. Linkitetyt resurssit, kuten kuvat ja tyylitiedostot, ovat oleellisia sivun ulkoasun ja rakenteen luomisessa. Selainpuolella suoritettavat skriptitiedostot, erityisesti Javascript, ovat luoneet huomattavan määrän syvyyttä nykyaikaiseen web-kokemukseen. Tällä kurssilla emme juurikaan syvenny selainpuolen toiminnallisuuteen.</p>



		<h1>Ensimmäinen palvelinohjelmisto</h1>


                <p>Tutustutaan tässä osiossa yksinkertaisten web-palvelinohjelmistojen rakenteeseen, sekä niiden toteuttamiseen <a href="http://www.spring.io" target="_blank">Spring</a>-sovelluskehyksen <a href="http://projects.spring.io/spring-boot/" target="_blank">Spring Boot</a>-projektilla. Spring on sovelluskehys, joka tarjoaa komponentteja sovellusten toteuttamiseen ja testaamiseen, ja Spring Boot -projekti tarjoaa näistä komponenteista koostuvia valmiita aloituspaketteja.</p>


                <h2>Hello World!</h2>

                <p>Tutustutaan "Hello World!"-tyyppisen web-sovelluksen toteuttamiseen Springin avulla. Oletetaan, että käytössämme on osoitteesta <a href="http://start.spring.io/" target="_blank">start.spring.io</a> ladattu Web-projektirunko (ruksaa Web-listan komponentti Web), jonka kansiorakenne on oletuksena seuraavankaltainen:</p>

                <pre>
├── pom.xml
└── src
    ├── main
    │   ├── java
    │   │   └── demo
    │   │       └── DemoApplication.java
    │   └── resources
    │       ├── application.properties
    │       ├── static
    │       └── templates
    └── test
        └── java
            └── demo
                └── DemoApplicationTests.java</pre>


                <h3>Kontrolleriluokka, pyynnön vastaanottaminen ja pyynnön käsittelevä metodi</h3>


                <p>Lisää kansioon <code>src/main/java/demo</code> luokka <code>HelloController</code>. Kontrollerit (<em>Controller</em>) ovat palvelinohjelmistoissa luokkia, joissa oleviin metodeihin palvelin ohjaa käyttäjän tekemiä pyyntöjä. Spring löytää kontrolleriluokkamme jos luokalle on lisätty <em>annotaatio</em> <code>@Controller</code>. Lisätään luokalle lisäksi annotaatio <code>@ResponseBody</code>, joka kertoo, että metodien palauttamat arvot lähetetään sellaisenaan takaisin pyynnön tehneelle selaimelle. Kontrolleriluokkamme runko on seuraavanlainen.</p>

<pre class="sh_java">
package demo;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
@ResponseBody
public class HelloController {

}</pre>

                <p>Pyynnöt käsitellään kontrolleriluokissa olevien metodien avulla. Jotta Spring osaa valita oikean metodin, tulee metodeille lisäksi kertoa <em>polku</em>, mitä ne kuuntelevat. Polku kerrotaan metodille määriteltävällä <code>@RequestMapping</code>-annotaatiolla. Metodi, jolla on annotaatio <code>@RequestMapping("*")</code> kuuntelisi kaikkia palvelinohjelmistoon liittyviä polkuja, kun taas annotaatiolla <code>@RequestMapping("/hello")</code> metodi kuuntelisi vain ohjelmiston polkuun <code>/hello</code> tulevia pyyntöjä. Luodaan kontrolleri, joka palauttaa selaimelle tekstin <code>"Hello!"</code> riippumatta siitä, mihin polkuun pyyntö tulee.</p>

		<pre class="sh_java">
package demo;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
@ResponseBody
public class HelloController {

    @RequestMapping("*")
    public String hello() {
        return "Hello!";
    }
}</pre>

	

                <h3>Sovelluksen käynnistäminen komentoriviltä</h3>

                <p>Sovelluksen käynnistäminen onnistuu suorittamalla projektijuuressa (hakemisto, missä on tiedosto pom.xml) komento <code>mvn spring-boot:run</code>. Käytännössä komento käynnistää projektissa mukana olevan palvelimen, ja asentaa siihen kehittämämme sovelluksen.</p>

                <p>Kun sovellus käynnistetään, siihen liittyvä palvelin käynnistyy oletuksena osoitteeseen <code>http://localhost:8080</code>. Voit tarkastella sovelluksen toimintaa web-selaimella. </p>


		<h3>Sovelluksen käynnistämisestä ja pakkauksista</h3>
		
		<p>Esimerkkipohjan mukana tuleva Spring-sovellus käynnistyy luokan <code>DemoApplication</code> kautta.</p>
		
		<pre class="sh_java">package demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}</pre>
		
		<p>Luokassa oleva annotaatio <code>@SpringBootApplication</code> pyytää sovellusta muunmuassa etsimään oleellisia luokkia projektista. Oletuksena luokkien tulee olla pakkauksen <code>demo</code> sisällä, tai sen alipakkauksissa kuten <code>demo.controller</code>. Käytämme kurssilla tehtävissä usein juuripakkauksen nimenä termiä <code>wad</code>, joka on kurssia varten keksitty lyhenne sanoista Web Application Development.</p>

		<p>Materiaalin esimerkeissä käytetty pakkausnimentä vaihtelee ajoittain.</p>
		

                <hr/>

                <div class="tehtavat">

                    <p>Tästä eteenpäin materiaalissa on myös ohjelmointitehtäviä. Tehtävien tekeminen ja palautus tapahtuu NetBeans-ympäristössä Test My Code-liitännäisen avulla. Test My Code lataa tehtäväpohjat sinulle valmiiksi, eli et tarvitse <code>start.spring.io</code>-osoitteen projektipohjia tehtävien tekemiseen. Muistathan palauttaa jokaisen tehtävän (<em>submit solution</em>). Tehtävät avataan tehtävän otsikkoa klikkaamalla.</p>
		    
                    <div class="tehtava" id="t-helloweb-ex">

                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-helloweb">
                                    Hello World!
                                </a>
                            </h1>
                        </header>

                        <div id="t-helloweb" class="collapse">

                            <p>Kuten huomattava osa ohjelmointikursseista, tämäkin kurssi alkaa tehtävällä, jossa toteutettava ohjelma kirjoittaa tekstin <code>Hello World!</code>.</p>

                            <p>Toteuta pakkauksessa <code>wad.controller</code> olevaan luokkaan <code>HelloWorldController</code> kontrollerimetodi, joka kuuntelee kaikkia osoitteita. Kun palvelin vastaanottaa pyynnön, tulee palvelimen palauttaa merkkijono "Hello World!".</p>

                            <p>Käynnistä palvelin painamalla NetBeansin play-nappia tai suorittamalla <code>Application</code>-luokan <code>main</code>-metodi. Avaa nettiselain, mene osoitteeseen <a href="http://localhost:8080/" target="_blank">http://localhost:8080/</a>, ja näet selaimessasi tekstin "Hello World!".</p>

                            <p><img class="browser-img" src="img/exercises/w1e01.png"/></p>

                            <p>Palvelin sammutetaan NetBeansissa punaista nappia painamalla -- vain yksi sovellus voi olla kerrallaan päällä samassa osoitteessa. Palauta tehtävä lopuksi Test My Code:n submit-napilla.</p>
                        </div>
                    </div>

                    <div class="tehtava" id="t-vieraslaskuri">

                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-vieraslaskuri">
                                    Vieraslaskuri
                                </a>
                            </h1>
                        </header>
                        <div id="t-vieraslaskuri" class="collapse">
                            <p>Vieraslaskuri kertoo kävijälle kuinka monta kävijää sivulla on käynyt tähän mennessä. Ensimmäinen kävijä näkee luvun 1, toinen kävijä luvun 2, jne.</p>

                            <p>Toteuta pakkauksessa <code>wad.controller</code> olevaan luokkaan <code>VisitCountController</code> polkua <code>/visits</code> kuunteleva metodi, joka toteuttaa toivotun toiminnallisuuden. Vinkki! Kontrolleriluokka luodaan vain kerran palvelimen käynnistyksen yhteydessä, joten voinet hyödyntää jotain sopivaa oliomuuttujaa.</p>

                            <p>Testaa sovellustasi. Ensimmäisellä pyynnöllä osoitteeseen <code>http://localhost:8080/visits</code> sinun pitäisi nähdä numero 1, toisella pyynnöllä numero 2 jne. Kun käynnistät palvelimen uudelleen, laskuri alkaa taas yhdestä.</p>
                        </div>
                    </div>
                </div>



                <h2>Pyynnön parametrit</h2>

                <p>Kun käyttäjä avaa osoitteen web-selaimella, selain tekee GET-tyyppisen pyynnön palvelimelle. Pyynnön mukana voi kulkea parametreja, jotka lisätään haettavan osoitteen perään. Esimerkiksi, osoitteessa <code>http://localhost:8080/autot?numero=95&amp;nimi=salama</code> on kaksi parametria. Parametrin <code>numero</code> arvo on <code>95</code> ja parametrin <code>nimi</code> arvo on <code>salama</code>. Parametrit erotetaan toisistaan <code>&amp;</code>-merkillä.</p>

                <p>Kontrollerimetodit voivat vastaanottaa näitä pyyntöjä määrittelemällä pyynnön vastaanottavalle metodille parametreja. Seuraava osoitetta <code>/tervehdi</code>-kuunteleva kontrollerimetodi olettaa, että pyynnön mukana tulee parametri <code>nimi</code>, ja palauttaa viestin "Hei ", jonka perään on liitetty parametrina saatu arvo.</p>

                <pre class="sh_java">
package demo;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
@ResponseBody
public class HelloController {

    @RequestMapping("/tervehdi")
    public String hello(@RequestParam String nimi) {
        return "Hei " + nimi;
    }
}</pre>

                <p>Jos ylläolevan sovelluksen käynnistää, ja hakee selaimella osoitetta <code>http://localhost:8080/tervehdi?nimi=Winnetou</code> -- olettaen että sovellus on käynnistetty omalla koneella -- käyttäjä näkee tekstin <code>Hei Winnetou</code>. Käytännössä osoitteessa oleva parametrin nimi kytketään automaattisesti metodissa käytettävään muuttujan nimeen.</p>

                <p>Kuten <code>@RequestMapping</code>-annotaatiolle, myös <code>@RequestParam</code>-annotaatiolle voi antaa toimintaa tarkentavia parametreja. Parametrit <code>required</code> ja <code>defaultValue</code> ovat molemmat hyödyllisiä; ensimmäisellä määritellään että tuleeko parametrin olla pyynnössä, ja toisella määritellään parametrin oletusarvo jos parametria ei ole.</p>

                <p>Seuraavassa esimerkissä todetaan, että pyynnön ei tarvitse sisältää parametria <code>sijainti</code>, ja että parametriin asetetaan oletuksena arvo "Kumpula".</p>

                <pre class="sh_java">
    @RequestMapping("/sijainti")
    public String etsi(@RequestParam(required=false, defaultValue="Kumpula") String sijainti) {
        return "Haetaan " + sijainti;
    }</pre>

                <p>Käytännössä jos selain tekee pyynnön osoitteeseen <code>http://localhost:8080/sijainti</code>, palauttaa palvelin merkkijonon "Haetaan Kumpula".</p>

                <p>Parametreja voi olla pyynnössä myös useampia. Seuraavassa esimerkissä metodi osaa käsitellä sekä <code>sijainti</code> että <code>vuosi</code> -nimiset parametrit. Huomaa, että oletusarvot asetetaan aina merkkijonona.</p>

                <pre class="sh_java">
    @RequestMapping("/sijainti")
    public String etsi(@RequestParam(required=false, defaultValue="Kumpula") String sijainti,
                       @RequestParam(required=false, defaultValue="1970") Integer vuosi) {
        return "Haetaan " + sijainti + " vuonna " + vuosi;
    }</pre>



                <p>Käytämme viittaustyyppisiä muuttujia (esim. <code>Integer</code>) myös tapauksissa, joissa alkeistyyppisen muuttujan (esim. <code>int</code>) käyttö olisi periaatteessa mahdollista. Tällä ohjelmointityylillä vältämme ongelmia, joita ilmenee kun sovelluskehys yrittää asettaa puuttuvaa parametrin arvoa (oletuksena <code>null</code>) alkeistyyppiseen muuttujaan (kokeile mitä tapahtuu jos koodissasi on komennot <code>Integer arvo = null; int a = arvo;</code>).</p>


                <div class="tehtavat">

                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-kaikupalvelu">
                                    Papukaija Bob
                                </a>
                            </h1>
                        </header>
                        <div id="t-kaikupalvelu" class="collapse">
                            <p>Papukaija <a href="https://www.youtube.com/watch?v=6NG37huf2dU" target="_blank">Bob</a> on netti-ilmiö, joka on oppinut sanoja, joita se toistaa. Tässä tehdään Bobille vastine, joka osaa toistaa sille sanottavia asioita.</p>

                            <p>Toteuta luokkaan <code>ParrotController</code> kontrollerimetodi, joka kuuntelee pyyntöjä <code>/bob</code>-osoitteessa. Jos pyynnön mukana ei ole <code>message</code>-nimistä parametria, on vastaus <code>"Krraaa"</code>. Muuten, vastaus on <code>"Krraaa"</code>, jota seuraa välilyönti ja <code>message</code>-parametrin arvo.</p>

                            <p>Kun testaat sovellusta, pyyntö osoitteeseen <code>http://localhost:8080/bob</code> näyttää sivun, jossa on merkkijono <code>"Krraaa"</code>, kun taas esimerkiksi pyyntö <code>http://localhost:8080/bob?message=keksii</code> palauttaa merkkijonon <code>"Krraaa keksii"</code>.</p>
                        </div>
                    </div>
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-laskin">
                                    Laskin
                                </a>
                            </h1>
                        </header>
                        <div id="t-laskin" class="collapse">

                            <p>Toteuta luokkaan <code>CalculatorController</code> kontrollerimetodi, joka kuuntelee pyyntöjä <code>/calculate</code>-osoitteessa. Pyynnön mukana voi olla kolme parametria. Parametri <code>"op"</code> kertoo laskuoperaation, <code>"first"</code> kertoo ensimmäisen laskettavan luvun, ja <code>"second"</code> kertoo toisen laskettavan luvun.</p>

                            <p>Jos parametria <code>"op"</code> ei ole pyynnössä mukana, tulee sen saada oletusarvoksi <code>"plus"</code>. Jos parametri <code>"first"</code> puuttuu, saa se oletuksena arvon 0. Myös parametri <code>"second"</code> saa puuttuessaan arvon 0.</p>

                            <p>Laskimen tulee toteuttaa seuraavat operaatiot:</p>

                            <ul>
                                <li>Kun operaatio (op) on <code>"plus"</code> laskin palauttaa lukujen <code>"first"</code> ja <code>"second"</code> summan. Esim. pyyntö osoitteeseen <code>http://localhost:8080/calculate?op=plus&first=3&second=1</code> palauttaa arvon <code>4</code>.</li>
                                <li>Kun operaatio (op) on <code>"minus"</code> laskin palauttaa lukujen <code>"first"</code> ja <code>"second"</code> erotuksen. Esim. pyyntö osoitteeseen <code>http://localhost:8080/calculate?op=minus&first=7&second=2</code> palauttaa arvon <code>5</code>.</li>
                                <li>Kun operaatio (op) on <code>"multiply"</code> laskin palauttaa lukujen <code>"first"</code> ja <code>"second"</code> tulon. Esim. pyyntö osoitteeseen <code>http://localhost:8080/calculate?op=multiply&first=11&second=3</code> palauttaa arvon <code>33</code>.</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <h2>Näkymät ja data</h2>

                <p>Aiemmat sovelluksemme ovat vastaanottaneet tiettyyn osoitteeseen tulevan pyynnön ja palauttaneet käyttäjälle esimerkiksi merkkijonomuodossa olevaa dataa. Tämä ei kuitenkaan ole ainoa palvelinohjelmistojen toimintatyyppi, vaan palvelin voi myös luoda käyttäjälle näkymän, jonka selain lopulta näyttää käyttäjälle. Näkymät luodaan tyypillisesti HTML-kielellä siten, että HTML-kielen sekaan on upotettu komentoja, joiden perusteella näkymään lisätään palvelimen tuottamaa tietoa.</p>



                <h3>Näkymän luominen: Thymeleaf</h3>

                <p>Eräs apuväline näkymän luomiseen on <a href="http://www.thymeleaf.org/" target="_blank">Thymeleaf</a>-templatemoottori, joka tarjoaa välineitä datan lisäämiseen HTML-sivuille. Käytännössä luomme näkymät ensin HTML-sivuina, jonka jälkeen sivuihin lisätään komentoja Thymeleafin käsiteltäväksi.</p>

                <p>Esimerkiksi, kun allaolevaa HTML-sivua käsitellään palvelimella, siinä olevan elementin <code>&lt;span th:text="${viesti}"&gt;hello world!&lt;/span&gt;</code> sisältö vaihdetaan palvelimella pyyntöön lisättyyn muuttujaan <code>viesti</code>.</p>

                <pre class="sh_xml">
&lt;!DOCTYPE html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;title&gt;selainikkunassa näkyvä otsikko&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Tekstiä tekstielementin sisällä, tekstielementti runkoelementin sisällä,
       runkoelementti html-elementin sisällä. Elementin sisältö voidaan asettaa
       useammalle riville.&lt;/p&gt;

    &lt;p&gt;palvelimelta saatu teksti: &lt;span th:text="${viesti}"&gt;hello world!&lt;/span&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>

                <p>Thymeleaf-sivut eroavat HTML-sivuista siinä, että niillä on <code>html</code>-määrittelyssä <code>xml</code>-nimiavaruuden <code>th</code>-määrittely, jonka avulla komennot kuten <code>th:text</code> tunnistetaan.</p>

                <p>Thymeleaf-sivut ("templatet") sijaitsevat tällä kurssilla projektin kansiossa <code>src/main/resources/templates</code> tai sen alla olevissa kansioissa. NetBeansissa kansio löytyy kun klikataan "Other Sources"-kansiota.</p>

		<aside class="info">
		  <br/>
		  <h1>Thymeleafin käyttöönotto</h1>

                  <p>Thymeleafin käyttöönotto vaatii <code>pom.xml</code>-tiedostossa olevien riippuvuuksien muokkaamista. Spring-sovelluskehyksen perusweb-toiminnallisuus on tuotu käyttöömme riippuvuudella</p>

                <pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>

		<p>Vaihtamalla ylläoleva riippuvuus allaolevaan muotoon, otamme Thymeleafin käyttöön.</p>

                <pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>

		<p>Joudumme myös hakemaan projektin riippuuvuuksia. Tämä onnistuu joko kirjoittamalla komentorivillä projektin juuressa komento <code>mvn dependency:resolve</code> tai valitsemalle NetBeansissa projektiin liittyvä kansio <em>Dependencies</em> oikealla hiirennapilla, ja painamalla <em>Download Declared Dependencies</em>.</p>

		<p>tämän lisäksi, HTML-sivujen <code>html</code>-elementin määrittelyssä tulee olla seuraavat määrittelyt.</p>  

                <pre class="sh_xml">
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt;</pre>        

                <p>Thymeleaf etsii näkymiä oletuksena kansiosta <code>src/main/resources/templates</code>. Spring etsii kansiosta <code>src/main/resources</code> konfiguraatiotiedostoa <code>application.properties</code>, johon lisäämme seuraavat rivit.</p>

                <pre>
spring.thymeleaf.suffix=.html
spring.thymeleaf.cache=false</pre>

                <p>Yllä olevalla konfiguraatiolla määrittelemme, että näkymätiedostojen pääte on <code>.html</code>; sitä ei tarvitse erikseen kertoa kontrollerissa. Tämän lisäksi, rivi <code>spring.thymeleaf.cache=false</code> sanoo sovellukselle, että näkymiä ei tule ladata välimuistiin; tämän avulla näemme näkymiin tehtävät muutokset myös palvelimen ollessa käynnissä.</p>

                <p>Nyt jos palautamme kontrollerista esimerkiksi merkkijonon <code>messages</code>, Spring etsii sivun <code>src/main/resources/templates/messages.html</code>, pyytää Thymeleafia luomaan sen, ja palauttaa sen käyttäjälle.</p>

                <pre class="sh_java">
@RequestMapping(method = RequestMethod.GET)
public String view() {
    return "messages";
}</pre>        

		</aside>


                <h3>Näkymän löytäminen ja näyttäminen</h3>

                <p>Sovellukseen tulevat pyynnöt otetaan vastaan ensin Spring-sovelluskehyksen toimesta, jonka tehtävänä on ohjata pyynnöt sopiville kontrollerimetodeille. Nämä päätellään <code>@RequestMapping</code>-annotaatioista. Kontrollerimetodien vastuulla on sekä datan liittäminen pyyntöön että vastauksen ohjaaminen joko suoraan käyttäjälle tai komponentille, joka luo datan avulla näkymän (esim. Thymeleaf).</p>

		<p>Aiemmin kontrolleriluokissa käyttämämme annotaatio <code>@ResponseBody</code> on käytännössä tarkoittanut sitä, että metodin palauttama data palautetaan sellaisenaan käyttäjälle. Kun otamme sen pois, käyttämämme sovelluskehys yrittää etsiä palauttamamme merkkijonon perusteella näkymää, jonka voisi näyttää käyttäjälle.</p>

                <p>Palauttamalla kontrollerimetodista merkkijono, sovellus etsii merkkijonoon liittyvää näkymää. Esimerkiksi, jos metodi palauttaa arvon "index", hakee Spring --  Thymeleafia käytettäessä -- kansiosta <code>src/main/resources/templates/</code> tiedostoa <code>index.html</code> ja näyttää sen sisällön käyttäjälle.</p>  

                <pre class="sh_java">
package wad.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class HelloController {

    @RequestMapping("*")
    public String view() {
        return "index";
    }
}</pre>

                <h3>Tiedon lisääminen pyyntöön</h3>

                <p>Sivua ei lähetetä suoraan käyttäjälle, vaan se käsitellään ensin palvelinohjelmistossa. Sivulle voi lisätä tietoa ns. <em>Model</em>-olion avulla, jonka voimme määritellä kontrollerimetodeihin. Spring asettaa oliolle arvon automaattisesti pyynnön saapuessa. Seuraava koodi lisää pyynnössä olevalle Model-oliolle attribuutin <code>viesti</code>, jonka arvoksi asetetaan merkkijono "aikamoista.". Tämän jälkeen metori palauttaa merkkijonon, jonka perusteella etsitään näkymän määrittelevä tiedosto. Tämä tiedosto ja model-oliossa oleva data käsitellään Thymeleafin toimesta, ja lopulta valmis sivu palautetaan käyttäjälle.</p>

                <pre class="sh_java">
package wad.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class HelloController {

    @RequestMapping("*")
    public String view(Model model) {
        model.addAttribute("viesti", "aikamoista.");
        return "index";
    }
}</pre>

        
		<p>Näkymän luonnin yhteydessä data asetetaan määriteltyihin kohtiin ja Thymeleaf-projektiin liittyvät viitteet poistetaan. Jos sivu "index.html" olisi aiemmin materiaalissa näkemämme HTML-sivu, saisi käyttäjä lopulta seuraavalta näyttävän sivun.</p>


                <pre class="sh_xml">
&lt;!DOCTYPE html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;title&gt;selainikkunassa näkyvä otsikko&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Tekstiä tekstielementin sisällä, tekstielementti runkoelementin sisällä,
       runkoelementti html-elementin sisällä. Elementin sisältö voidaan asettaa
       useammalle riville.&lt;/p&gt;

    &lt;p&gt;palvelimelta saatu teksti: &lt;span&gt;aikamoista&lt;/span&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>     

	

                <p>Kontrollerimetodit voivat luonnollisesti sekä vastaanottaa pyynnön parametreja, että lisätä dataa Model-olioon. Allaolevassa esimerkissä metodi odottaa kahta parametria ja lisää niiden arvot model-oliolle näkymän luomista varten.</p>

                <pre class="sh_java">
    @RequestMapping("/sijainti")
    public String etsi(Model model,
                       @RequestParam(required=false, defaultValue="Kumpula") String sijainti,
                       @RequestParam(required=false, defaultValue="1970") Integer vuosi) {
        model.addAttribute("sijainti", sijainti);
        model.addAttribute("vuosi", vuosi);
        return "index";
    }</pre>

                <div class="tehtava">
                    <header>
                        <h1>
                            <a data-toggle="collapse" class="collapsed" href="#t-nakyma-ja-lomake">
                                Näkymä ja lomake
                            </a>
                        </h1>
                    </header>
                    <div id="t-nakyma-ja-lomake" class="collapse">
                        <p>Sovelluksessa oleva luokka <code>FormController</code> sisältää metodin, joka vastaanottaa minkä tahansa pyynnön, asettaa <code>model</code>-olion <code>data</code>-parametrin arvoksi <code>content</code>-muuttujan, sekä ohjaa pyynnön luomaan sivun kansiossa <code>src/main/resources/templates/</code> olevasta <code>index.html</code>-sivusta. Sivu sisältää valmiin lomakkeen, jonka avulla palvelimelle voi lähettää tietoa. Jos HTML-lomakkeet eivät ole tuttuja, tutustu esimerkiksi osoitteessa <a href="http://www.w3schools.com/html/html_forms.asp" target="_blank">http://www.w3schools.com/html/html_forms.asp</a> olevaan oppaaseen.</p>

			<p>Kun tarkastelet valmista lomaketta tarkemmin, on <code>action</code>-attribuutti hieman erilainen kuin normaalisti. Thymeleafissa lomakkeen <code>action</code>-attribuutti määritellään muodossa <code>th:action="@{/submit}"</code>, minkä avulla osoite voidaan muuttaa automaattisesti sovelluksen sijainnin muuttuessa.</p>

                        <p>Muokkaa sovellusta siten, että lomakkeella lähetetty data muuttaa palvelimella olevaa <code>content</code>-muuttujaa, ja että käyttäjälle näytetään aina <code>content</code>-muuttujan uusin arvo. Jos taas pyynnössä ei tule <code>data</code>-nimistä parametria, säilytetään <code>content</code>-muuttujan arvo sellaisenaan. Varmista lopuksi, että käyttäjä näkee sivun myös ilman lomakkeen lähetystä.</p>

                        <p>Käytännössä sivun tulee toimia seuraavasti:</p>

                        <ul>
                            <li>Kun sivu avataan ensimmäisen kerran, käyttäjä näkee tekstin "i got nothing.."</li>
                            <li>Kun lomakkeella lähetetään dataa, esimerkiksi "testi", käyttäjä näkee tekstin "i got testi"</li>
                            <li>Kun sivu avataan tämän jälkeen uudestaan, käyttäjä näkee vieläkin tekstin "i got testi"</li>
                        </ul>
                    </div>
                </div>


                <h3>Pyynnöistä ja poluista</h3>


                <p>HTML-sivuilla olevien lomakkeiden avulla käyttäjä voi lähettää dataa sekä GET- että POST-tyyppisellä pyynnöllä. Pyynnön tyyppi määritellään lomakkeen <code>method</code>-osiossa, esimerkiksi seuraavalla lomakkella tehdään POST-tyyppinen pyyntö, jossa palvelimen polkuun <code>/persons</code> lähetetään parametri nimeltä <code>name</code> -- (palvelimen päälläollessa käytännössä <code>http://localhost:8080/persons</code>). Käytännössä GET-tyyppisiä pyyntöjä ei tule käyttää ohjelmiston sisäisen tilan muokkaamiseen (esimerkiksi henkilöiden poistamiseen), sillä esimerkiksi web-indeksoijat tekevät GET-tyyppisiä pyyntöjä ja seuraavat sivujen linkkejä.</p>

                <pre class="sh_xml">
        &lt;form th:action="@{/persons}" method="POST"&gt;
            &lt;input type="text" name="name"/&gt;
            &lt;input type="submit"/&gt;
        &lt;/form&gt;</pre>

                <p>Allaoleva kontrollerimetodi vastaanottaa sekä GET- että POST-tyyppisiä pyyntöjä.</p>

                <pre class="sh_java">
    @RequestMapping("/persons")
    public String post(@RequestParam String name) {
        // tee jotain parametrille name
        return "index";
    }</pre>


                <p>Pyynnön tyypin voi kertoa eksplisiittisesti osana <code>@RequestMapping</code>-annotaatiota. Alla oleva metodi käsittelee vain POST-tyyppisiä pyyntöjä.</p>

                <pre class="sh_java">
    @RequestMapping(value = "/persons", method = RequestMethod.POST)
    public String post(@RequestParam String name) {
        // tee jotain parametrille name
        return "index";
    }</pre>

                <p>POST-tyyppiset pyynnöt ovat hieman ongelmallisia jos pyynnön vastauksena palautetaan näytettävä sivu. Tällöin käyttäjä voi sivun uudelleenlatauksen (esim. painamalla F5) yhteydessä lähettää aiemmin lähettämänsä datan vahingossa uudelleen. Esimerkiksi edellisessä tehtävässä, jos painat F5-näppäintä sen jälkeen kun olet lähettänyt lomakkeen, huomaat tämän ilmiön.</p>

                <p>On tyylikkäämpää toteuttaa lomakkeen dataa vastaanottavat kontrollerit siten, että ne vastaanottavat pyynnön ja pyytävät selainta hakemaan sivun uudestaan. Tämä tapahtuu palauttamalla kontrollerimetodista merkkijono <code>redirect:</code>, johon on liitetty haluttava polku. Esimerkiksi merkkijonon <code>redirect:/persons</code> palauttaminen luo tilanteen, missä selaimelle lähetetään viesti, jossa sitä ohjeistetaan tekemään GET-tyyppinen haku osoitteeseen <code>/persons</code>. Tätä toteutustapaa kutsutaan <a href="http://en.wikipedia.org/wiki/Post/Redirect/Get" target="_blank">Post/Redirect/Get</a>-suunnittelumalliksi, ja sillä mm. estetään lomakkeiden uudelleenlähetys, jonka lisäksi vähennetään toiminnallisuuden toisteisuutta.</p>

                <p>Ylläolevan esimerkin voi toteuttaa uudestaan siten, että lomake vastaanotetaan yhdessä kontrollerimetodissa ja näkymä palautetaan toisessa. Lisätään annotaatioon <code>@RequestMapping</code> parametri <code>method</code>, jolla kerrotaan pyyntötyyppi, jota kontrollerimetodi kuuntelee.</p>

                <pre class="sh_java">
    @RequestMapping(value = "/persons", method = RequestMethod.GET)
    public String get() {
        return "index";
    }

    @RequestMapping(value = "/persons", method = RequestMethod.POST)
    public String post(@RequestParam String name) {
        // tee jotain parametrille name
        return "redirect:/persons";
    }</pre>

                <p>Kontrollerimetodiin <code>get</code> voisi luonnollisesti lisätä myös Model-parametrin, johon voisi asettaa näkymään lisättävää tietoa.</p>

                <p>Jatketaan esimerkkiä vielä hieman. Oletetaan, että käsittelemme henkilöitä, joilla jokaisella on jonkinlainen yksilöllinen tunnus, ja haluamme näyttää henkilöön liittyvän sivun. Eräs vaihtoehto olisi lisätä pyynnön parametriin näytettävän henkilön tunnus, minkä perusteella pyyntöä käsittelevä metodi hakisi tarvittavan henkilön.</p>

                <p>Toinen vaihtoehto on ajatella pyyntöpolkua haettavan henkilön, tai resurssin tunnistajana, ja hakea henkilön tietoja esimerkiksi osoitteen <code>/persons/5</code> kautta, missä tunnus <code>5</code> on haettavan henkilön tunnus. Parametrien erottaminen pyyntöpolusta onnistuu <code>@PathVariable</code>-annotaation avulla. Yllä oleva esimerkki jatkuu siten, että muokkaamme <code>get</code>-metodin nimen muotoon <code>list</code>, ja lisäämme toisen metodin nimeltä <code>get</code>, jonka avulla voidaan hakea yksittäinen henkilö. Kokonaisuudessaan henkilöiden noutamiseen ja lisäämiseen tarvittava kontrolleriluokka on seuraavanlainen.</p>


                <pre class="sh_java">
package wad.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

@Controller
public class PersonController {

    // ..

    @RequestMapping(value = "persons", method = RequestMethod.GET)
    public String list(Model model) {
        // hae kaikki henkilöt ja lisää ne modeliin
        // palauta sopiva sivu
        return "persons"; // erillinen persons.html
    }

    @RequestMapping(value = "persons/{id}", method = RequestMethod.GET)
    public String get(Model model, @PathVariable String id) {
        // etsi henkilö tunnuksella id, lisää se modeliin
        // palauta sopiva sivu
        return "person"; // erillinen person.html
    }

    @RequestMapping(value = "persons", method = RequestMethod.POST)
    public String post(@RequestParam String name) {
        // luo uusi henkilö nimen perusteella
        return "redirect:/persons";
    }
}</pre>

                <p>Huomaamme kuitenkin metodeissa hieman toistoa. Voimme siirtää osan <code>@RequestMapping</code>-määrittelystä luokkatasolle seuraavasti. Tällöin kaikki alla olevassa luokassa olevat metodit kuuntelevat polkua <code>persons</code> tai sen alipolkuja.</p>


                <pre class="sh_java">
// ..

@Controller
@RequestMapping(value = "persons")
public class PersonController {

    @RequestMapping(method = RequestMethod.GET)
    public String list(Model model) {
        // ..
    }

    @RequestMapping(value = "/{id}", method = RequestMethod.GET)
    public String get(Model model, @PathVariable String id) {
        // ..
    }

    @RequestMapping(method = RequestMethod.POST)
    public String post(@RequestParam String name) {
        // ..
    }
}</pre>

                <h3>Olioiden luominen pyynnöstä</h3>

                <p>Jatketaan edellistä esimerkkiä vielä hieman. Oletetaan, että haluamme käsitellä <code>Person</code>-luokan ilmentymiä. Jos luokan attribuuttien nimet ovat samat pyynnössä olevien parametrien kanssa, voidaan pyynnön parametreista luoda olio automaattisesti. Oletetaan, että käytössämme on seuraava <code>Person</code>-luokka.</p>

                <pre class="sh_java">
//..
public class Person {

    private String name;

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }
}</pre>

                <p>Luokalle tulee olla ns. getterit ja setterit, sillä Spring käyttää niitä arvojen asettamiseen. Näiden luominen on automaattista NetBeansissa: kun olet luonut oliomuuttujat, klikkaa lähdekoodi-ikkunaa oikealla hiirennapillä, ja valitse <code>Insert code</code>.</p>

                <p>Kun käytössämme on luokka <code>Person</code>, voimme muokata aiempaa kontrolleriluokkaamme siten, että lomakkeen vastaanottava <code>post</code> metodi luo pyynnöstä automaattisesti <code>Person</code>-olion. Tämä tapahtuu <code>@ModelAttribute</code>-annotaatiolla.</p>

                <pre class="sh_java">
    @RequestMapping(method = RequestMethod.POST)
    public String post(@ModelAttribute Person person) {
        // tee luodulle oliolle jotain

        return "redirect:/persons";
    }</pre>

                <div class="tehtava">
                    <header>
                        <h1>
                            <a data-toggle="collapse" class="collapsed" href="#t-vieraslista">
                                Vieraslista
                            </a>
                        </h1>
                    </header>
                    <div id="t-vieraslista" class="collapse">
                        <p>Tehtävässä kehitetään vieraslistausta. Tässä tehtävässä on kaksi osaa, joista kummastakin saa tehtäväpisteen.</p>

                        <h1>Vieraiden lisääminen</h1>

                        <p>Muokkaa <code>GuestController</code>-luokkaa siten, että kun osoitteeseen <code>/guests</code> tehdään POST-pyyntö, jonka mukana lähetetään vierasta kuvaavat <code>name</code> ja <code>menu</code>-parametrit, vieraslistaan (lista nimeltä <code>guests</code>) lisätään uusi vieras. Lisää vieras jos ja vain jos name-parametri ei ole tyhjä.</p>

                        <p>Huomioi, että luokka <code>GuestController</code> kuuntelee jo <code>/guests</code>-osoitetta!</p>

                        <p>Kun uusi vieras on lisätty, pyyntö tulee <em>uudelleenohjata</em> vieraat listaavalle kontrollerimetodille.</p>


                        <h1>Vieraiden poisto</h1>

                        <p>Toteuta vieraiden poistotoiminnallisuus.</p>

                        <p>Poistotoiminnallisuuden tulee tapahtua POST-tyyppisen pyynnön avulla vieraskohtaisiin osoitteisiin. Esimerkiksi, vieraan, jonka tunnus (id) on "x9z41f", poisto tapahtuu tekemällä pyyntö osoitteeseen <code>/guests/x9z41f/delete</code>. Annotaatiosta <code>@PathVariable</code> on tässä hyötyä. Huom! Älä hyväksy GET-tyyppisiä pyyntöjä, jotka yrittävät poistaa vierasta listalta!</p>

                        <p>Kun vieras on poistettu, uudelleenohjaa pyyntö vieraat listaavalle kontrollerimetodille.</p>
                    </div>
                </div>


                <h3>Olioiden ja kokoelmien käyttäminen näkymässä</h3>

                <p>Edellisessä tehtävässä käytetyssä HTML-sivussa oli muutamia mystisiä kommentteja. Selvennetään niistä muutamia.</p>

                <p>Jos model-olioon on lisätty olio, pääsemme olion muuttujiin käsiksi piste-operaattorin <code>.</code> avulla. Esimerkiksi lause <code>${person.name}</code> hakee <code>person</code>-nimiseen olioon liittyvän <code>name</code>-muuttujan arvoa. Muuttujien arvojen hakemisessa käytetään gettereitä ja settereitä, joten ne kannattaa olla luokkamäärittelyssä.</p>

                <p>Käytännössä siis jos Person-luokan ilmentymä lisätään pyynnön model-olioon, pääsee Thymeleaf sen <code>getName</code>-metodiin käsiksi.</p>

                <pre class="sh_java">
    ...
    Person p = new Person();
    p.setName("James Gosling");
    model.addAttribute("person", p);
    ...
                </pre>

                <p>Kun olio on lisätty pyynnön attribuutiksi nimellä <code>person</code>, voidaan siihen liittyviin get-metodeihin viitata muodossa <code>${person.<em>ominaisuus</em>}</code>. Tämä tekisi metodikutsun <code>getOminaisuus()</code>. Metodia <code>getName()</code> voi taas kutsua seuraavasti:</p>

                <pre class="sh_xml">
    ...
    &lt;body&gt;
        &lt;p&gt;Ja seuraavana vuorossa on: &lt;span th:text="${person.name}"&gt;jack bauer?&lt;/span&gt;&lt;/p&gt;
    &lt;/body&gt;
    ...
                </pre>

                <p>Yllä oleva esimerkki luo seuraavanlaisen tulostuksen.</p>

                <pre class="naytto">
Ja seuraavana vuorossa on: James Gosling
                </pre>

                <p>Thymeleaf sisältää toiminnallisuudet mm. perusohjelmoinnissa käytettävien kontrollirakenteiden käyttöön sekä erilaisten tietotyyppien kuten päivämäärän formatointiin. Tällä kurssilla hyödynnämme lähinnä kontrollirakenteita, joista toistolauseke lienee tärkein.</p>

                <p>Komentoa <code>th:each</code> käytetään Collection-rajapinnan toteuttavien kokoelmien läpikäyntiin. Sen määrittely saa muuttujan nimen, johon kokoelmasta otettava alkio kullakin iteraatiolla tallennetaan, sekä läpikäytävän kokoelman. Perussyntaksiltaan <code>th:each</code> on seuraavanlainen.</p>

                <pre class="sh_xml">
    ...
    &lt;pre&gt;
        &lt;p th:each="alkio : ${joukko}"&gt;
            &lt;span th:text="${alkio}"&gt;hello world!&lt;/span&gt;
        &lt;/p&gt;
    &lt;/pre&gt;
    ...
                </pre>

                <p>Yllä käytämme attribuuttia nimeltä <code>joukko</code>, ja tulostamme yksitellen sen sisältämät alkiot.</p>

                <p><em>Huom! Eräs klassinen virhe on määritellä iteroitava joukko merkkijonona <code>th:each="alkio : joukko"</code>. Tämä ei luonnollisesti toimi.</em></p>

                <p>Iteroitavan joukon alkioiden ominaisuuksiin pääsee käsiksi aivan samalla tavalla kuin muiden model-olioon lisättävien attribuuttien. Tutkitaan seuraavaa esimerkkiä, jossa listaan lisätään kaksi henkilöä, lista lisätään pyyntöön, ja lopulta luodaan Thymeleafin avulla.</p>


                <pre class="sh_java">
    ...
    Person p = new Person();
    p.setName("James Gosling");

    Person p2 = new Person();
    p2.setName("Martin Odersky");

    List&lt;Person&gt; list = new ArrayList&lt;&gt;();
    list.add(p);
    list.add(p2);

    model.addAttribute("persons", list);
    ...
                </pre>

                <pre class="sh_xml">
    ...
    &lt;p&gt;And the talks are given by:&lt;/p&gt;
    &lt;ol&gt;
        &lt;li th:each="person : ${persons}"&gt;
            &lt;span th:text="${person.name}"&gt;has no name&lt;/span&gt;
        &lt;/li&gt;
    &lt;/ol&gt;
    ...
                </pre>

                <p>Käyttäjälle lähetettävä sivu näyttää palvelimella tapahtuneen prosessoinnin jälkeen seuraavalta.</p>


                <pre class="sh_xml">
    ...
    &lt;p&gt;And the talks are given by:&lt;/p&gt;
    &lt;ol&gt;
            &lt;li&gt;&lt;span&gt;James Gosling&lt;/span&gt;&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;Martin Odersky&lt;/span&gt;&lt;/li&gt;
    &lt;/ol&gt;
    ...
                </pre>


                <h2>Tietokannan käyttäminen</h2>

                <p>Vaikka sovelluksemme ovat melko huikeita, on samalla hieman tylsää, että sovelluksiin liittyvä tieto katoaa aina kun palvelin käynnistetään uudelleen. Tietokannat ovat palvelinohjelmistosta erillisiä sovelluksia, joiden ensisijainen tehtävä on varmistaa, että käytettävä tieto ei katoa. Otetaan ensiaskeleet tietokannan käyttöön web-palvelinohjelmistoissa -- tutustumme tietokantoihin tarkemmin myöhemmin kurssilla. Käytämme tietokantatoiminnallisuuden toteuttamisessa <a href="http://projects.spring.io/spring-data-jpa/" target="_blank">Spring Data JPA</a>-komponenttia, johon löytyy myös aloituspaketti käyttämästämme Spring Bootista.</p>

		<aside class="info">

		  <br/>

		  <h1>Spring Data JPA:n käyttöönotto</h1>

		  <p>Saadaksemme Spring Data JPA:n käyttöömme, tulee meidän lisätä se <code>pom.xml</code>-tiedostoon. Spring Bootin kautta löytyy näppärä paketti <code>spring-boot-starter-data-jpa</code>, joka vähentää yksittäisten riippuvuuksien lisäämistä. Tämän lisäksi tarvitsemme testikäyttöön sopivan tietokannan -- valitaan <a href="http://hsqldb.org/" target="_blank">HSQLDB</a>, jonka voi ladata muistiin sovelluksen käynnistyessä.</p>

		  <p>Lisätään projektiin seuraavat riippuvuudet:</p>

		  <pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.hsqldb&lt;/groupId&gt;
    &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>

		  <p>Kun projektin riippuvuudet noudetaan Mavenin avulla, on tietokanta valmis testikäyttöön.</p>

		</aside>

                <p>Jotta voimme tallentaa luokan ilmentymiä tietokantaan, meidän tulee asettaa luokalle <code>@Entity</code>-annotaatio, sekä tehdä sille tunnuskenttä, jonka avulla se voidaan yksilöidä. Voimme käyttää tunnuskentän luomiseen Spring Data JPA:n valmiiksi tarjoamaa <code>AbstractPersistable</code>-yliluokkaa, jota perittäessä kerromme uniikin tunnuksen tyypin. Esimerkiksi <code>Person</code>-luokasta voidaan tehdä tietokantaan tallennettava seuraavilla muutoksilla.</p>

                <pre class="sh_java">
package wad.domain;

import javax.persistence.Entity;
import org.springframework.data.jpa.domain.AbstractPersistable;

@Entity
public class Person extends AbstractPersistable&lt;Long&gt; {

    private String name;

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }
}</pre>

                <p>Kun käytössämme on tietokantaan tallennettava luokka, voimme luoda tietokannan käsittelyyn käytettävän <em>rajapinnan</em>. Kutsutaan tätä rajapintaoliota nimellä <code>PersonRepository</code>.</p>

                <pre class="sh_java">
// pakkaus

import wad.domain.Person;
import org.springframework.data.jpa.repository.JpaRepository;

public interface PersonRepository extends JpaRepository&lt;Person, Long&gt; {

}</pre>

                <p>Rajapinta perii Spring Data-projektin <code>JpaRepository</code>-rajapinnan; samalla kerromme, että tallennettava olio on tyyppiä <code>Person</code> ja että tallennettavan olion tunnus on <code>Long</code>-tyyppiä. Tämä tyyppi on sama kuin aiemmin <code>AbstractPersistable</code>-luokan perinnässä parametriksi asetettu tyyppi. Spring osaa käynnistyessään myös etsiä mm. JpaRepository-rajapintaluokan periviä luokkia. Jos niitä löytyy, se luo niiden pohjalta tietokannan käsittelyyn sopivan olion sekä asettaa olion ohjelmoijan haluamiin muuttujiin. Nämä muuttujat määritellään annotaatiolla <code>@Autowired</code> -- jokaiselle muuttujalle tulee oma annotaatio -- palaamme myöhemmin kurssilla tarkemmin tähän ns. olioiden automaattiseen asettamiseen.</p>

                <p>Kun olemme luoneet rajapinnan <code>PersonRepository</code>, voimme lisätä sen käyttöömme esimerkiksi kontrolleriluokkaan. Tämä tapahtuu seuraavasti.</p>

                <pre class="sh_java">
// ...

@Controller
@RequestMapping(value = "persons")
public class PersonController {

    @Autowired
    private PersonRepository personRepository;

    // ...
}</pre>

                <p>Nyt tietokantaan pääsee käsiksi <code>personRepository</code>-olion kautta. Osoitteessa <a href="http://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/JpaRepository.html" target="_blank">http://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/JpaRepository.html</a> on JpaRepository-rajapinnan API-kuvaus, mistä löytyy rajapinnan tarjoamien metodien kuvauksia. Voimme esimerkiksi toteuttaa tietokannassa olevien olioiden listauksen sekä yksittäisen olion haun seuraavasti:</p>

                <pre class="sh_java">
// ...

@Controller
@RequestMapping(value = "persons")
public class PersonController {

    @Autowired
    private PersonRepository personRepository;

    @RequestMapping(method = RequestMethod.GET)
    public String list(Model model) {
        model.addAttribute("list", personRepository.findAll());
        return "persons"; // erillinen persons.html
    }

    @RequestMapping(value = "/{id}", method = RequestMethod.GET)
    public String get(Model model, @PathVariable Long id) {
        model.addAttribute("person", personRepository.findOne(id));
        return "person"; // erillinen person.html
    }
}</pre>


                <h3>Tietokantatransaktiot ja tietokantaolioiden muuttaminen</h3>

                <p>Kun tietokannasta lataa olion, sen muuttaminen ei automaattisesti vie muutoksia takaisin tietokantaan. Esimerkiksi, seuraavassa kontrollerimetodissa <code>person</code>-oliolle tehdyt muutokset eivät tallennu tietokantaan.</p>

                <pre class="sh_java">
    @RequestMapping(value = "{id}/example", method = RequestMethod.POST)
    public String post(@PathVariable Long id) {
        Person p = personRepository.findOne(id);
        p.setName("example");
        // ..
        return "redirect:/person/" + id;
    }</pre>

                <p>Jos muutokset halutaan tallentaa tietokantaan, tulee olio joko tallentaa erikseen <code>personRepository</code>-olion <code>save</code>-metodilla, tai kontrollerimetodille asettaa annotaatio <code>@Transactional</code>. Annotaatio <code>@Transactional</code> määrittelee metodin toiminnallisuuden sellaiseksi, että kaikki metodin sisällä tapahtuvat asiat tapahtuvat tietokantatransaktion sisällä, jonka aikana tehdyt muutokset viedään tietokantaan metodin suorituksen lopuksi. Seuraavassa esimerkissä haetun henkilön nimi päivittyy tietokantaan.</p>

                <pre class="sh_java">
    @Transactional
    @RequestMapping(value = "{id}/example")
    public String post(@PathVariable Long id) {
        Person p = personRepository.findOne(id);
        p.setName("example");
        // ..
        return "redirect:/person/" + id;
    }</pre>



                <div class="tehtava">
                    <header>
                        <h1>
                            <a data-toggle="collapse" class="collapsed" href="#t-tehtavalista">
                                Tehtävälista
                            </a>
                        </h1>
                    </header>
                    <div id="t-tehtavalista" class="collapse">

                      <p>Tässä tehtävässä toteutetaan tehtävälistatoiminnallisuutta. Tehtäväpohjassa on valmis tietokantakonfiguraatio, missä käytetään muistiin ladattavaa tietokantaa -- tietokanta tyhjenee palvelimen sammuessa.</p>

                        <h1>Tehtävien listaaminen</h1>

                        <p>Toteuta <code>TaskController</code>-luokkaan <code>/tasks</code>-osoitteeseen tulevia GET-tyyppisiä pyyntöjä kuunteleva kontrollerimetodi. Pyynnön tulee lisätä <code>model</code>-parametriin <code>tasks</code> kaikki tietokannasta löytyvät tehtävät. Tässä <code>taskRepository</code>-olion <code>findAll</code>-metodi on hyödyksi. Palauta käyttäjälle kansiossa <code>src/main/resources/templates</code> olevasta <code>index.html</code>-tiedostosta luotu näkymä.</p>

                        <h1>Tehtävän lisääminen</h1>

                        <p>Toteuta <code>TaskController</code>-luokkaan <code>/tasks</code>-osoitteeseen tulevia POST-tyyppisiä pyyntöjä kuunteleva kontrollerimetodi. Pyynnön mukana tulee <code>name</code> ja <code>done</code>-parametrit, joiden pohjalta luodaan uusi tehtävä. Jos tehtävän nimi (<em>name</em>) ei ole tyhjä ja se ei ole null, tulee tehtävä tallentaa tietokantaan. Tässä <code>taskRepository</code>-olion <code>save</code>-metodi on hyödyksi.</p>

                        <p>Kun uusi tehtävä on lisätty, uudelleenohjaa pyyntö aiemmin toteuttamallesi tehtävät listaavalle kontrollerimetodille.</p>

                        <h1>Tehtävän poistaminen</h1>

                        <p>Toteuta <code>TaskController</code>-luokkaan <code>/tasks/{id}/delete</code>-osoitteeseen POST-tyyppisiä pyyntöjä kuunteleva kontrollerimetodi. Poistettavan tehtävän <code>id</code> on osana osoitetta. Tässä <code>taskRepository</code>-olion <code>delete</code>-metodi on hyödyksi.</p>

                        <p>Kun tehtävä on poistettu, uudelleenohjaa pyyntö aiemmin toteuttamallesi tehtävät listaavalle kontrollerimetodille.</p>

                        <h1>Tehtävän muuttaminen tehdyksi</h1>

                        <p>Toteuta <code>TaskController</code>-luokkaan <code>/tasks/{id}/done</code>-osoitteeseen POST-tyyppisiä pyyntöjä kuunteleva kontrollerimetodi. Tehtävän, joka tulee asettaa tehdyksi, <code>id</code> on osana osoitetta. Tässä <code>taskRepository</code>-olion <code>findOne</code>-metodi on hyödyksi.</p>

                        <p>Kun tehtävä on on asetettu tehdyksi, uudelleenohjaa pyyntö aiemmin toteuttamallesi tehtävät listaavalle kontrollerimetodille. Huom! Jotta tietokannasta hakemaasi olioon tehdyt muutokset päivittyvät, sinun tulee joko käyttää <code>@Transactional</code>-annotaatiota, tai tallentaa olio muutosten jälkeen.</p>
                    </div>
                </div>

                <h3>Tietokannassa olevat oliot ja toisiin olioihin viittaaminen</h3>

                <p>Kuten olio-ohjelmoinnissa yleensäottaen, tietokantaan tallennettavat oliot voivat viitata toisiinsa. Oletetaan, että käytössämme on <code>Person</code>-luokan lisäksi <code>VipList</code>-luokka, joka sisältää listan henkilöitä. Yhtä Vip-listaa kohden on monta henkilöä, joten merkitään yhteys <code>@OneToMany</code>-annotaatiolla. Palaamme myös yhteystyyppeihin myöhemmin kurssilla.</p>

                <pre class="sh_java">
package wad.domain;

import java.util.List;
import javax.persistence.Entity;
import javax.persistence.OneToMany;
import org.springframework.data.jpa.domain.AbstractPersistable;

@Entity
public class VipList extends AbstractPersistable&lt;Long&gt; {

    @OneToMany
    private List&lt;Person&gt; persons;

    public List&lt;Person&gt; getPersons() {
        return this.persons;
    }

    public void setPersons(List&lt;Person&gt; persons) {
        this.persons = persons;
    }
}</pre>

                <p>Täysin uuden henkilön luominen ja lisääminen vip-listalle tapahtuu seuraavasti. Oletetaan, että käytössämme on <code>personRepository</code>-olio henkilöiden hallintaan ja <code>vipListRepository</code>-vip-listojen hallintaan.</p>

                <pre class="sh_java">
    @Transactional
    @RequestMapping(value = "viplists/{id}/persons", method = RequestMethod.POST)
    public String post(@PathVariable Long id, @ModelAttribute Person person) {
        // tallennetaan henkilö ja otetaan viite tallennettuun olioon haltuun
        person = personRepository.save(person);
        // haetaan vip-lista ja lisätään henkilö listalle
        vipListRepository.findOne(id).getPersons().add(person);

        // ohjataan pyyntö sopivaan näkymään
        return "redirect:/viplists";
    }</pre>

                <p>Henkilön poistaminen vip-listalta tapahtuu vastaavasti.</p>

                <pre class="sh_java">
    @Transactional
    @RequestMapping(value = "viplists/{id}/persons/{personId}/delete", method = RequestMethod.POST)
    public String removePerson(@PathVariable Long id, @PathVariable Long personId) {
        person = personRepository.findOne(personId);
        vipListRepository.findOne(id).getPersons().remove(person);

        // ohjataan pyyntö sopivaan näkymään
        return "redirect:/viplists";
    }</pre>

                <p>Huom! Vaikka käytämme ensimmäisellä viikolla POST-pyyntöjä resurssien (esimerkiksi henkilöiden) poistamiseen, on käytäntö melko huono. Opimme myöhemmin parempia tapoja.</p>

                <p>Jos henkilö halutaan poistaa kokonaisuudessaan, tulee hänet ensin poistaa listoilta, joihin hän on lisätty. Palaamme taustasyihin myöhemmin...</p>

                <div class="tehtava">
                    <header>
                        <h1>
                            <a data-toggle="collapse" class="collapsed" href="#t-albumilista">
                                Albumilista
                            </a>
                        </h1>
                    </header>
                    <div id="t-albumilista" class="collapse">

                        <p>Muokattavaan albumilistasovellukseen on toteutettu jo albumien lisääminen ja listaaminen. Tässä tehtävässä lisätään albumeihin kappaleita. Älä huoli <code>wad.profiles</code>-pakkauksen alla olevista tiedostoista tai muista projektiin lisätyistä uusista riippuvuuksista :).</p>

                        <h1>Kappaleen lisääminen</h1>

                        <p>Lisää <code>AlbumController</code>-luokkaan kontrollerimetodi, joka kuuntelee POST-tyyppisiä pyyntöjä osoitteeseen <code>/albums/{albumId}/tracks</code>, missä <code>albumId</code> on olemassaolevan albumin tunnus. Pyynnöissä tulee mukana <code>name</code>-niminen parametri, jonka arvona on lisättävän kappaleen nimi.</p>

                        <p>Tallenna lisättävä kappale tietokantaan ja lisää se albumille, jonka tunnus (<em>id</em>) on sama kuin polussa oleva {albumId}.</p>

                        <p>Kun kappale on lisätty albumille, ohjaa pyyntö edelleen albumit listaavalle kontrollerimetodille.</p>


                        <h1>Kappaleen poistaminen</h1>


                        <p>Lisää <code>AlbumController</code>-luokkaan kontrollerimetodi, joka kuuntelee POST-tyyppisiä pyyntöjä osoitteeseen <code>/albums/{albumId}/tracks/{trackId}/delete</code>, missä <code>albumId</code> on olemassaolevan albumin tunnus, ja <code>trackId</code> on poistettavan kappaleen tunnus.</p>

                        <p>Kun kontrollerimetodia kutsutaan, tulee sen poistaa annettu kappale annetulta albumilta. Huomaa, että kappale tulee sekä poistaa albumilta, että poistaa kappaletietokannasta.</p>

                        <p>Kun kappale on poistettu, ohjaa pyyntö edelleen albumit listaavalle kontrollerimetodille.</p>
                    </div>
                </div>

                <h2>Sovelluksen siirtäminen verkkoon</h2>

                <p>Albumilistamme, kuten muutkin sovelluksemme, on melko jepa, mutta olisi kiva näyttää sitä myös jollekin muulle. Tutustutaan tämän viikon lopuksi sovelluksen verkkoon siirtämiseen. Tarvitset tässä tunnukset <a href="https://www.heroku.com/" target="_blank">Heroku</a>-palveluun, joka tarjoaa ilmaisen sijoituspaikan vähän resursseja kuluttaville sovelluksille.</p>

                <p>Kun olet luonut tunnuksen Herokuun, asenna osoitteesta <a href="https://toolbelt.heroku.com/" target="_blank">https://toolbelt.heroku.com/</a> työvälineet sovelluksen Herokuun siirtämiseen. Seuraa myös sivun "Getting started"-ohjetta, ja suorita sen <code>heroku login</code>-osio.</p>

                <p>Mene tämän jälkeen Albumilista-tehtävän kansioon, missä on myös tiedosto <code>pom.xml</code>. Kirjoita kansiossa komento <code>git init</code>, mikä lisää kansioon versionhallintakansion <code>.git</code>.</p>

                <pre>        
avihavai@aavikkokettu:<em>polku</em>/W1E08.Albumilista$ git init
Initialized empty Git repository in <em>polku</em>/W1E08.Albumilista/.git/</pre>

                <p>Kirjoita tämän jälkeen komento <code>heroku create</code>, mikä luo paikan minne sovelluksen voi lähettää.</p>

                <pre>       
avihavai@aavikkokettu:<em>polku</em>/W1E08.Albumilista$ heroku create
Creating aqueous-lowlands-6350... done, stack is cedar
http://aqueous-lowlands-6350.herokuapp.com/ | git@heroku.com:aqueous-lowlands-6350.git</pre>

                <p>Komennolla <code>git remote add heroku git@heroku.com:aqueous-lowlands-6350.git</code> lisätään juuri luotu heroku-sijainti projekti käyttöömme. Huomaa, että <code>git@heroku.com:aqueous-lowlands-6350.git</code> on sama kuin komennon <code>heroku create</code> tulostama sijainti.</p>

                <pre>       
avihavai@aavikkokettu:<em>polku</em>/W1E08.Albumilista$ git remote add heroku git@heroku.com:aqueous-lowlands-6350.git
avihavai@aavikkokettu:<em>polku</em>/W1E08.Albumilista$</pre>        

                <p>Nyt voimme lisätä sovelluksen verkkoon. Jos tehtäväkansiossa on target-kansio, poista se tässä välissä. Kirjoita seuraavaksi komento <code>git add .</code>, jonka jälkeen komento <code>git commit -m "initial commit"</code>. Näillä komennoilla lisäät sovelluksen nykyisen version versionhallintaan. Kirjoita tämän jälkeen <code>git push heroku master</code>, mikä lähettää sovelluksen verkkoon.</p>

                <pre>       
avihavai@aavikkokettu:<em>polku</em>/W1E08.Albumilista$ git add .
avihavai@aavikkokettu:<em>polku</em>/W1E08.Albumilista$ git commit -m "initial commit"
[master (root-commit) 2cbc76b] initial commit
 tulostusta...
avihavai@aavikkokettu:<em>polku</em>/W1E08.Albumilista$ git push heroku master
 tulostusta...
-----> Discovering process types
       Procfile declares types -> web

-----> Compressing... done, 135.6MB
-----> Launching... done, v6
       http://aqueous-lowlands-6350.herokuapp.com/ deployed to Heroku
 hieman tulostusta</pre>

                <p>Nyt, voimme käydä tarkistamassa sovelluksen herokun palvelussa. Yllä olevassa esimerkissä sovellus on lisätty osoitteeseen <a href="http://aqueous-lowlands-6350.herokuapp.com/" target="_blank">http://aqueous-lowlands-6350.herokuapp.com/</a>.</p>
            </section>
            <!-- END WEEK1 -->


            <!-- BEGIN WEEK2 -->
            <section class="weeklimit" data-week-id="2">
                <header>
                    <h1 id="viikko2">Viikko 2</h1>
                </header>
		
                <aside class="info">
		  
		  <br/>
                  <h1>Muutama sana sovelluksen logikonfiguraatiosta</h1>
		  
                  <p>Sovelluksen sisäisen sielunelämän näkeminen vaatii sovelluksen logikonfiguraation määrittelyä. Oma konfiguraatiotiedosto <code>application.properties</code> löytyy kansiosta <code>src/main/resources</code>, ja siellä määritellään muunmuassa Thymeleafin käyttöön liittyviä komentoja.</p>
		  
		  <p>Tämän lisäksi, tiedostolla voidaan ohjata muunmuassa minkälaisia viestejä sovelluksen logeissa näytetään. Esimerkiksi tietokantakyselyitä Spring Data JPA:n alla tekevän Hibernate-kirjaston tietokantakyselyt saadaan näkyviksi seuraavilla komennoilla. Komento <code>logging.file=</code> ohjaa viestit konsoliin.</p>
		  
                  <pre>
logging.level.org.springframework.web.servlet.DispatcherServlet=DEBUG
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type=TRACE
logging.file=</pre>

                  <p>Jos haluat tietoosi <em>kaiken</em> mitä sovelluksessa tapahtuu, muokkaa logikonfiguraatio seuraavanlaiseksi:</p>
		  
                  <pre>
logging.level.=TRACE
logging.file=</pre>

                </aside>
		
                <hr/>

                <h1>Kerrosarkkitehtuuri</h1>

                <p>Kerrosarkkitehtuuria noudattamalla pyritään tilanteeseen, missä sovellus on jaettu itsenäisiin kerroksiin, jotka toimivat vuorovaikutuksessa muiden kerrosten kanssa. Käyttöliittymäkerros sisältää näkymät (esim. Thymeleafin html-sivut) sekä mahdollisen logiikan tiedon näyttämiseen (esim tägit html-sivuilla). Käyttöliittymä näkyy käyttäjän selaimessa, ja käyttäjän selain tekee palvelimelle pyyntöjä käyttöliittymässä tehtyjen klikkausten ja muiden toimintojen pohjalta. Palvelimella toimivan sovelluksen kontrollerikerros ottaa vastaan nämä pyynnöt, ja ohjaa ne eteenpäin sovelluksen sisällä. Tällä kurssilla kerrosarkkitehtuurilla tarkoitetaan yleisesti ottaen seuraavaa jakoa:</p>

                <ul>
                    <li>Käyttöliittymäkerros</li>
                    <li>Kontrollerikerros</li>
                    <li>Sovelluslogiikka ja palvelut</li>
                    <li>Tietokanta-abstraktio ja tietokantapalvelut</li>
                </ul>

                <p>Kerrosarkkitehtuuria noudattaessa ylempi kerros hyödyntää alemman kerroksen tarjoamia toiminnallisuuksia, mutta alempi kerros ei hyödynnä ylempien kerrosten tarjoamia palveluita. Puhtaassa kerrosarkkitehtuurissa kaikki kerrokset ovat olemassa, ja kutsut eivät ohita kerroksia ylhäältä alaspäin kulkiessaan. Tällä kurssilla noudatamme avointa kerrosarkkitehtuuria, missä kerrosten ohittaminen on sallittua.</p>


                <p>Tutustutaan seuraavaksi näihin hieman tarkemmin.</p>


                <h2>Kontrollerikerros</h2>

                <p>Kontrollerien ensisijaisena vastuuna on pyyntöjen kuuntelu, pyyntöjen ohjaaminen sopiville palveluille, sekä tuotetun tiedon ohjaaminen oikealle näkymälle tai näkymän generoivalle komponentille.</p>

                <p>Jotta palveluille ei ohjata epäoleellista dataa, esimerkiksi huonoja arvoja sisältäviä parametreja, on kontrolleritason vastuulla myös pyynnössä olevien parametrien validointi.</p>

                <h3>Pyyntöparametrien validointi</h3>

                <p>Lomakkeiden ja lähetettävän datan validointi, eli oikeellisuuden tarkistaminen, on tärkeää. Ensimmäinen askel -- jonka olemme jo ottaneet -- on tallennettavan datan esittäminen ohjelmaan liittyvien käsitteiden kautta. Olemme käyttäneet datan tallentamisessa olioita, joihin on määritelty sopivat kenttien tyypit. Tämä helpottaa työtämme jo hieman: esimerkiksi numerokenttiin ei saa asetettua merkkijonoja. Käyttämämme Spring Bootin mukana tulee <a href="http://hibernate.org/" target="_blank">Hibernate</a>-projektin komponentti, joka tarjoaa validointitoiminnallisuuden.</p>

                <p>Validaatiosääntöjen määrittely tapahtuu annotaatioilla. Muokataan alla määriteltyä luokkaa <code>Person</code> siten, että henkilöllä tulee olla henkilötunnus, nimi ja sähköpostiosoite.</p>


                <pre class="sh_java">
// pakkaus jne
public class Person {

    private String socialSecurityNumber;
    private String name;
    private String email;

    // getterit ja setterit
}</pre>


                <p>Sovitaan että henkilötunnus ei saa koskaan olla tyhjä ja sen tulee olla tasan 11 merkkiä pitkä. Nimen tulee olla vähintään 5 merkkiä pitkä, ja korkeintaan 30 merkkiä pitkä, ja sähköpostiosoitteen tulee olla validi sähköpostiosoite. Annotaatio <code>@NotBlank</code> varmistaa ettei annotoitu attribuutti ole tyhjä -- lisätään se kaikkiin kenttiin. Annotaatiolla <code>@Length</code> voidaan määritellä pituusrajoitteita muuttujalle, ja annotaatiolla <code>@Email</code> varmistetaan, että attribuutin arvo on varmasti sähköpostiosoite.</p>


                <pre class="sh_java">
// pakkaus

import org.hibernate.validator.constraints.Email;
import org.hibernate.validator.constraints.Length;
import org.hibernate.validator.constraints.NotBlank;

public class Person {

    @NotBlank
    @Length(min = 11, max = 11)
    private String socialSecurityNumber;

    @NotBlank
    @Length(min = 5, max = 30)
    private String name;

    @NotBlank
    @Email
    private String email;

    // getterit ja setterit</pre>


                <h3>Olion validoinnin päälle kytkeminen tapahtuu kontrollerissa</h3>

                <p>Kontrollerimetodit validoivat olion jos kontrollerimetodissa olevalle <code>@ModelAttribute</code>-annotaatiolla merkatulle oliolle on asetettu myös annotaatio <code>@Valid</code> (<code>javax.validation.Valid</code>).</p>

                <pre class="sh_java">
    @RequestMapping(method = RequestMethod.POST)
    public String create(@Valid @ModelAttribute Person person) {
        // .. esimerkiksi tallennus ja uudelleenohjaus
    }</pre>

                <p>Spring validoi olion pyynnön vastaanottamisen yhteydessä, mutta validointivirheet eivät ole kovin kaunista luettavaa. Yllä olevalla kontrollerimetodilla virheellisen nimen kohdalla saamme hieman kaoottisen ilmoituksen.</p>

                <pre>
Whitelabel Error Page

This application has no explicit mapping for /error, so you are seeing this as a fallback.

<em>aika</em>
There was an unexpected error (type=Bad Request, status=400).
Validation failed for object='person'. Error count: 1</pre>

		<p>Virheelle täytyy selvästi tehdä jotain..</p>


                <h3>Validointivirheiden käsittely</h3>


                <p>Validointivirheet aiheuttavat poikkeuksen, joka näkyy ylläolevana virheviestinä, jos niitä ei erikseen käsitellä. Validointivirheiden käsittely tapahtuu luokan <code>BindingResult</code> avulla, joka toimii validointivirheiden tallennuspaikkana. Luokan <code>BindingResult</code> kautta voimme käsitellä virheitä. <code>BindingResult</code>-olio kuvaa aina yksittäisen olion luomisen ja validoinnin onnistumista, ja se tulee asettaa heti validoitavan olion jälkeen. Seuraavassa esimerkki kontrollerista, jossa validoinnin tulos lisätään automaattisesti <code>BindingResult</code>-olioon.</p>

                <pre class="sh_java">
    @RequestMapping(method = RequestMethod.POST)
    public String create(@Valid @ModelAttribute Person person, BindingResult bindingResult) {
        if(bindingResult.hasErrors()) {
            // validoinnissa virheitä: virheiden käsittely
        }

        // muu toteutus
    }</pre>

                <p>Ylläolevassa esimerkissä kaikki validointivirheet tallennetaan <code>BindingResult</code>-olioon. Oliolla on metodi <code>hasErrors</code>, jonka perusteella päätämme jatketaanko pyynnön prosessointia vai ei. Yleinen muoto lomakedataa tallentaville kontrollereille on seuraavanlainen:</p>

                <pre class="sh_java">
    @RequestMapping(method = RequestMethod.POST)
    public String create(@Valid @ModelAttribute Person person, BindingResult bindingResult) {
        if(bindingResult.hasErrors()) {
            return "lomakesivu";
        }

        // .. esimerkiksi tallennus

        return "redirect:/index";
    }</pre>

                <p>Yllä oletetaan että lomake lähetettiin näkymästä <em>"lomakesivu"</em>: käytännössä validoinnin epäonnistuminen johtaa nyt siihen, että pyyntö ohjataan takaisin lomakesivulle.</p>


                <h3>Thymeleaf-lomakkeet ja BindingResult</h3>


                <p>Lomakkeiden validointivirheet saadaan käyttäjän näkyville Thymeleafin avulla. Lomakkeet määritellään kuten normaalit HTML-lomakkeet, mutta niihin lisätään muutama apuväline. Lomakkeen attribuutti <code>th:object</code> kertoo olion, johon lomakkeen kentät tulee pyrkiä liittämään (huom! tämän tulee olla määriteltynä myös lomakkeen palauttavassa kontrollerimetodissa -- palaamme tähän kohta). Sitä käytetään yhdessä kontrolleriluokan <code>ModelAttribute</code>-annotaation kanssa. Lomakkeen kentät määritellään attribuutin <code>th:field</code> avulla, jossa oleva <code>*{arvo}</code> liitetään lomakkeeseen liittyvään olioon. Oleellisin virheviestin näkymisen kannalta on kuitenkin attribuuttiyhdistelmä <code>th:if="${#fields.hasErrors('arvo')}" th:errors="*{arvo}"</code>, joka näyttää virheviestin jos sellainen on olemassa.</p>

                <p>Luodaan lomake aiemmin nähdyn <code>Person</code>-olion luomiseen.</p>


                <pre class="sh_xml">
&lt;form action="#" th:action="@{/persons}" th:object="${person}" method="POST"&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;SSN: &lt;/td&gt;
            &lt;td&gt;&lt;input type="text" th:field="*{socialSecurityNumber}" /&gt;&lt;/td&gt;
            &lt;td th:if="${#fields.hasErrors('socialSecurityNumber')}" th:errors="*{socialSecurityNumber}"&gt;SSN Virheviesti&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;Name: &lt;/td&gt;
            &lt;td&gt;&lt;input type="text" th:field="*{name}" /&gt;&lt;/td&gt;
            &lt;td th:if="${#fields.hasErrors('name')}" th:errors="*{name}"&gt;Name Virheviesti&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;Email: &lt;/td&gt;
            &lt;td&gt;&lt;input type="text" th:field="*{email}" /&gt;&lt;/td&gt;
            &lt;td th:if="${#fields.hasErrors('email')}" th:errors="*{email}"&gt;Email Virheviesti&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;&lt;button type="submit"&gt;Submit&lt;/button&gt;&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form&gt;</pre>

                <p>Yllä oleva lomake lähettää lomakkeen tiedot osoitteessa <code>&lt;sovellus&gt;/persons</code> olevalle kontrollerimetodille. Lomakkeelle tullessa tarvitsemme erillisen tiedon käytössä olevasta oliosta. Alla on näytetty sekä kontrollerimetodi, joka ohjaa GET-pyynnöt lomakkeeseen, että kontrollerimetodi, joka käsittelee POST-tyyppiset pyynnöt. Huomaa erityisesti <code>@ModelAttribute</code>-annotaatio kummassakin metodissa. Metodissa <code>view</code> olion nimi on <code>person</code>, joka vastaa lomakkeessa olevaa <code>th:object</code>-attribuuttia. Tämän avulla lomake tietää, mitä oliota käsitellään.</p>

                <pre class="sh_java">
    @RequestMapping(method = RequestMethod.GET)
    public String view(@ModelAttribute Person person) {
        return "lomake";
    }

    @RequestMapping(method = RequestMethod.POST)
    public String create(@Valid @ModelAttribute Person person, BindingResult bindingResult) {
        if(bindingResult.hasErrors()) {
            return "lomake";
        }

        // .. tallennus ja uudelleenohjaus
    }</pre>

                <p>Jos lomakkeella lähetetyissä kentissä on virheitä, virheet tallentuvat <code>BindingResult</code>-olioon. Tarkistamme kontrollerimetodissa <code>create</code> ensin virheiden olemassaolon -- jos virheitä on, palataan takaisin lomakkeeseen. Tällöin validointivirheet tuodaan lomakkeen käyttöön <code>BindingResult</code>-oliosta, jonka lomakkeen kentät täytetään <code>@ModelAttribute</code>-annotaatiolla merkitystä oliosta. Huomaa että virheet ovat pyyntökohtaisia, ja uudelleenohjauspyyntö kadottaa virheet.</p>

                <p><strong>Huom!</strong> Springin lomakkeita käytettäessä lomakesivut haluavat käyttöönsä olion, johon data kytketään jo sivua ladattaessa. Yllä lisäsimme pyyntöön <code>Person</code>-olion seuraavasti:</p>

                <pre class="sh_java">
    @RequestMapping(method = RequestMethod.GET)
    public String view(@ModelAttribute Person person) {
        return "lomake";
    }</pre>

                <p>Toinen vaihtoehto on luoda kontrolleriluokkaan erillinen metodi, jonka sisältämä arvo lisätään automaattisesti pyyntöön. Tällöin lomakkeen näyttävä kontrollerimetodi ei tarvitse erikseen ModelAttribute-parametria. Tällöin toteutus olisi esimerkiksi seuraavanlainen:</p>

                <pre class="sh_java">
    @ModelAttribute
    private Person getPerson() {
        return new Person();
    }
        
    @RequestMapping(method = RequestMethod.GET)
    public String view() {
        return "lomake";
    }

    @RequestMapping(method = RequestMethod.POST)
    public String create(@Valid @ModelAttribute Person person, BindingResult bindingResult) {
        if(bindingResult.hasErrors()) {
            return "lomake";
        }

        // .. tallennus ja uudelleenohjaus
    }</pre>


                <p>Thymeleafin avulla tehdyistä lomakkeista ja niiden yhteistyöstä Springin kanssa löytyy lisää osoitteesta <a href="http://www.thymeleaf.org/doc/tutorials/2.1/thymeleafspring.html#creating-a-form" target="_blank">http://www.thymeleaf.org/doc/tutorials/2.1/thymeleafspring.html#creating-a-form</a>.</p>


                <h3>Validointi ja entiteetit</h3>

                <p>Vaikka edellisessä esimerkissä käyttämäämme <code>Person</code>-luokkaa ei oltu merkitty <code>@Entity</code>-annotaatiolla -- eli se ei ollut tallennettavissa JPAn avulla tietokantaan -- mikään ei estä meitä lisäämästä sille <code>@Entity</code>-annotaatiota. Toisaalta, lomakkeet voivat usein sisältää tietoa, joka liittyy useaan eri talletettavaan olioon. Tällöin voi luoda erillisen lomakkeen tietoihin liittyvän <em>lomakeolio</em>, jonka pohjalta luodaan tietokantaan tallennettavat oliot kunhan validointi onnistuu. Erilliseen lomakeobjektiin voi täyttää myös kannasta haettavia listoja ym. ennalta.</p>

                <p>Kun validointisäännöt määritellään entiteetille, tapahtuu validointi kontrollerin lisäksi myös tietokantatallennusten yhteydessä.</p>


		<aside class="info">
		  <br/>
		  <h1>Spring Loaded</h1>

		  <p>Tehtäväpohjissa olevassa <code>pom.xml</code>-konfiguraatiossa on mukana <a href="https://github.com/spring-projects/spring-loaded" target="_blank">Spring Loaded</a>-kirjasto, jonka ansiosta -- kun se toimii -- lähdekoodissa tehtyjä muutoksia ladataan automaattisesti palvelimelle. Komponentti ei kuitenkaan ole vielä erinomaisessa kunnossa. Jos ohjelma ei toimi koneellasi, tai sovellukset eivät lähde käyntiin (erit. jos käy käyttöjärjestelmänä on Windows), voi seuraavat rivit kommentoida pois <code>pom.xml</code>-tiedostosta:</p>
		 
<pre class="sh_xml">
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;springloaded&lt;/artifactId&gt;
        &lt;version&gt;1.2.4.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
&lt;executions&gt;
    &lt;execution&gt;
        &lt;goals&gt;
            &lt;goal&gt;repackage&lt;/goal&gt;
        &lt;/goals&gt;
    &lt;/execution&gt;
&lt;/executions&gt;
</pre>

		  <p>Toisaalta, jos käytät esimerkiksi tietojenkäsittelytieteen laitoksella olevia laitteita, on hyvä kokeilla käynnistää sovellukset komentoriviltä komennolla <code>mvn spring-boot:run</code> ja kokeilla tehdä pieniä muutoksia esimerkiksi kontrolleriluokkien koodiin -- ja testata muutoksia heti selaimessa ilman palvelimen uudelleenkäynnistystä.</p>

		  <p>Jos kyseinen vaihtoehto ei toimi, muita mahdollisuuksia ovat mm. <a href="http://www.hotswapagent.org/" target="_blank">HotswapAgent</a> ja <a href="http://zeroturnaround.com/software/jrebel/" target="_blank">JRebel</a>, joista jälkimmäinen on maksullinen.</p>


		</aside>

                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1 class="panel-title">
                                <a data-toggle="collapse" class="collapsed" href="#t-ilmoittautuminen">
                                    Ilmoittautuminen
                                </a>
                            </h1>
                        </header>
                        <div id="t-ilmoittautuminen" class="collapse">

                            <p>Tehtävän mukana tulee sovellus, jota käytetään ilmoittatumiseen. Tällä hetkellä käyttäjä voi ilmoittautua juhliin oikeastaan minkälaisilla tiedoilla tahansa. Tehtävänäsi on toteuttaa parametreille seuraavanlainen validointi:</p>

                            <ol>
                                <li>Nimen (<code>name</code>) tulee olla vähintään 4 merkkiä pitkä ja enintään 30 merkkiä pitkä.</li>
                                <li>Osoitteen (<code>address</code>) tulee olla vähintään 4 merkkiä pitkä ja enintään 50 merkkiä pitkä.</li>
                                <li>Sähköpostiosoitteen (<code>email</code>) tulee olla validi sähköpostiosoite.</li>
                            </ol>


                            <p>Tehtäväpohjan mukana tuleviin sivuihin on toteutettu valmiiksi lomake. Tehtävänäsi on toteuttaa validointitoiminnallisuus pakkauksessa <code>wad.domain</code> olevaan luokkaan <code>Registration</code>.</p>

                            <p>Jos yksikin tarkastuksista epäonnistuu, tulee käyttäjälle näyttää rekisteröitymislomake uudelleen. Muista lisätä kontrolleriin validoitavalle parametrille annotaatio <code>@Valid</code>. Virheviestien ei tule näkyä vastauksessa jos lomakkeessa ei ole virhettä. Käyttöliittymä on tehtävässä valmiina.</p>

                        </div>
                    </div>
                </div>

                <h3>Uudelleenohjaukset kontrollerimetodeissa</h3>

                <p>Kun käyttäjä ohjataan tekemään uusi pyyntö <code>redirect:</code>-komennon avulla, palvelin palauttaa selaimelle HTTP statuskoodin 303 (tai 302) ja osoitteen. Tämä aiheuttaa sen, että selain tekee pyynnön uuteen osoitteeseen. Koska HTTP on <em>tilaton protokolla</em>, ei sillä ole välineistöä käyttäjän pyyntöjen yhdistämiseen: aiemmassa pyynnössä käytössä oleva data ei ole käytössä seuraavassa pyynnössä.</p>

                <p>Tämä on yleensä täysin hyväksyttävää, ja toivottavaakin, mutta joissain tapauksissa ohjelmoija haluaa aiemmasta pyynnöstä tietoja myös seuraavaan pyyntöön. Tyypillinen käyttötapaus on tietyn informaatioviestin lisääminen sivulle, johon käyttäjä ohjataan. Yksi vaihtoehto on <code>RedirectAttributes</code>-parametrin lisääminen kontrollerimetodille. RedirectAttributes-olioon voi lisätä attribuutteja, jotka halutaan käyttäjän seuraavan pyynnön käyttöön. Käytännössä <code>RedirectAttributes</code>-olio tallentaa attribuutit <em>sessioon</em>, josta ne lisätään <code>Model</code>-olion attribuutteihin seuraavan pyynnön yhteydessä.</p>

                <p>Pohditaan tilannetta, jossa olemme luomassa uutta <code>Person</code>-oliota. Kun olio on luotu, käyttäjä ohjataan suoraan sivulle, jossa on juuri luodun olion tiedot. Tämän lisäksi, kun käyttäjä tulee sivulle ensimmäisen kerran, sivulla näytetään myös viesti "New person created!". Oletetaan, että <code>Person</code>-luokka on seuraavanlainen.</p>

                <pre class="sh_java">
// pakkaus

// importit

@Entity
public class Person extends AbstractPersistable&lt;Long&gt; {

    @NotBlank
    @Length(min = 11, max = 11)
    private String socialSecurityNumber;

    @NotBlank
    @Length(min = 5, max = 30)
    private String name;

    @NotBlank
    @Email
    private String email;

    // getterit ja setterit</pre>


                <p>Muokataan <code>PersonController</code>-luokan <code>create</code> metodia siten, että se saa parametrina <code>RedirectAttributes</code>-olion. Parametrina saatu <code>Person</code>-olio tallennetaan. Tämän jälkeen asetamme <code>RedirectAttributes</code>-oliolle kaksi attribuuttia.</p>

                <p>Normaali attribuutti, joka lisätään metodilla <code>addAttribute</code> on käytössä tämän pyynnön loppuun asti. Alla olevassa esimerkissä lisäämme attribuutin <code>id</code>, jonka Spring myöhemmin asettaa osaksi osoitetta, johon käyttäjä ohjataan. Tällöin pyyntö ohjautuu juuri luotua <code>Person</code>-oliota käsittelevälle sivulle. Toinen attribuutti, joka lisätään metodilla <code>addFlashAttribute</code>, on käytössä vain seuraavan pyynnön ajan. Attribuutti <code>message</code> löytyy automaattisesti seuraavan pyynnön model-oliosta.</p>

                <pre class="sh_java">
// pakkaus ja importit

@Controller
@RequestMapping("/persons")
public class PersonController {

    @Autowired
    private PersonRepository personRepository;

    // lomakkeen näyttäminen

    @RequestMapping(method = RequestMethod.POST)
    public String create(RedirectAttributes redirectAttributes,
            @Valid @ModelAttribute Person person,
            BindingResult bindingResult) {
        if(bindingResult.hasErrors()) {
            return "form";
        }

        person = personRepository.save(person);

        redirectAttributes.addAttribute("id", person.getId());
        redirectAttributes.addFlashAttribute("message", "New person created!");
        return "redirect:person/{id}";
    }

// muut metodit
                </pre>

                <p>Jos osoitetta <code>persons/{id}</code> kuuntelee kontrollerimetodi, se saa käyttöönsä attribuutin <code>message</code> <em>ensimmäisellä kerralla kun käyttäjä päätyy sivulle</em>. Kontrollerimetodi, joka kuuntelee osoitetta <code>persons/{id}</code> voi olla esimerkiksi seuraavanlainen.</p>

                <pre class="sh_java">
    // ...
    @RequestMapping(value = "/{personId}", method = RequestMethod.GET)
    public String viewPerson(Model model, @PathVariable Long personId) {
        model.addAttribute("person", personRepository.findOne(personId));
        return "form";
    }

    // ...
                </pre>

                <p>Sivu <code>person.html</code> voi näyttää esimerkiksi seuraavanlaiselta (huomaa mielikuvituksen puute):</p>

                <pre class="sh_xml">
&lt;!DOCTYPE html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"/&gt;
        &lt;title th:text="${person.name}"&gt;person name&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;&lt;span th:text="${person.name}"&gt;person name&lt;/span&gt; &lt;span th:if="${message}" th:text="${message}"&gt;le viesti&lt;/span&gt;&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre>


                <p>Oleellista tässä on se, että kun käyttäjä luo uuden <code>Person</code> olion, hänet ohjataan sivulle, joka näyttää käyttäjän tiedot. Sivun voi tallentaa kirjanmerkiksi, sillä sivu on aina olemassa. Kuitenkin ensimmäisellä kerralla käyttäjän tullessa sivulle, eli juuri silloin, kun käyttäjä on luotu, sivulla näkyy myös käyttäjäystävällinen viesti <code>"New person created!"</code>.</p>

                <div class="tehtava">
                    <header>
                        <h1>
                            <a data-toggle="collapse" class="collapsed" href="#t-tilauspalvelu">
                                Tilauspalvelu
                            </a>
                        </h1>
                    </header>
                    <div id="t-tilauspalvelu" class="collapse">

                        <p>Parannellaan erään tilauspalvelun toimintaa.</p>

                        <h1>Validointi</h1>

                        <p>Tällä hetkellä käyttäjän syöttämiä tietoja ei validoida millään tavalla. Lisää sovellukseen tilauksen (<code>Order</code>) validointi seuraavasti:</p>

                        <ul>
                            <li>Nimen (<code>name</code>) tulee olla vähintään 4 merkkiä ja enintään 30 merkkiä pitkä.</li>
                            <li>Osoitteen (<code>address</code>) tulee olla vähintään 4 merkkiä ja enintään 50 merkkiä pitkä.</li>
                            <li>Tilatut esineet (<code>items</code>) ei saa olla tyhjä.</li>
                        </ul>

                        <p>Jos joku edelläolevista ehdoista ei täyty, näytä käyttäjälle lomake siten, että siinä näkyy virheviestit ja jo syötetyt tiedot. Käyttöliittymä on rakennettu puolestasi, joten sinun tarvitsee muokata vain luokkia <code>OrderController</code> ja <code>Order</code>. Huom! Kannattanee käyttää <code>@NotEmpty</code>-annotaatiota esineiden tyhjyyden tarkistamiseen.</p>


                        <h1>POST, Redirect, GET</h1>


                        <p>Muuta sovellusta siten, että lomakkeen lähetyksen onnistuessa käyttäjä ohjataan erilliseen osoitteeseen, jossa näkyy hänen juuri tekemänsä ostos. Käyttäjän tulee pystyä asettamaan osoite kirjanmerkiksi, eli sen tulee olla pysyvä. Kun käyttäjä ohjautuu sivulle ensimmäistä kertaa, sivulla tulee näkyä viesti <code>Order placed!</code>. Toteuta uudelleenohjaus käyttämällä <code>RedirectAttributes</code> luokkaa osana toteutusta: aseta attribuutiksi <code>orderId</code> luodun tilauksen <code>id</code>, sekä lisää pyyntöön flash-attribuutti <code>message</code>, joka sisältää viestin <code>Order placed!</code>. Joudut myös muokkaamaan metodin palauttamaa merkkijonoa sopivasti.</p>

                    </div>
                </div>


                <h3>PUT ja DELETE HTML-lomakkeissa</h3>

                <p>Selaimet tekevät vain GET- ja POST-tyyppisiä pyyntöjä, mutta HTTP-spesifikaatiossa on myös mm. DELETE ja PUT metodit.</p>

		<p>Haluamme toteuttaa kontrollerin metodit siten, että käytetyt metodit vastaavat todellista toiminnallisuutta. Esimerkiksi elementin poistaminen on hyvä toteuttaa DELETE-tyyppisillä pyynnöillä: tällöin kuvataan todellista toimintaa. Sovelluskehykset tarjoavat tuen pyyntötyyppien muokkaukseen siten, että lomakkeisiin asetetaan pyynnön tyypin määrittelevä attribuutti.</p>

                <p>Pyyntötyypin muuttaminen onnistuu <code>th:method</code>-attribuutin avulla. Tällöin lomakkeet voidaan muokata siten, että niiden mukana tulevat tiedot kertovat Springille, että pyyntö tulee käsitellä PUT- tai DELETE-pyyntöjä käsittelevissä metodeissa. 

. Esimerkiksi seuraavaa lomaketta voisi käyttää henkilön poistamiseen.</p>

                <pre class="sh_xml">
    &lt;form ... th:method="DELETE"&gt;
        &lt;input type="submit"&gt;
    &lt;/form:form&gt;
                </pre>

                <p>Käytännössä tämä luo lomakkeelle piilokentän, jonka nimenä on <code>_method</code> ja arvona <code>DELETE</code>; pyyntö muunnetaan ennen pyynnön ohjaamista kontrollerimetodille.</p>

                <pre class="sh_xml">
    &lt;form ... method="post"&gt;
        &lt;input type="hidden" name="_method" value="DELETE"/&gt;
        &lt;input type="submit"/&gt;
    &lt;/form&gt;
                </pre>


                <p>Huom! Kun toteutat PUT- tai DELETE-tyyppisiä pyyntöjä käsitteleviä kontrollerimetodeja, ohjaa käyttäjä tekemään uusi GET-pyyntö metodin lopussa.</p>



                <h2>Palvelukerros</h2>


                <p>Palvelukerros tarjoaa kontrollerikerrokselle palveluita, joita kontrollerikerros voi käyttää. Palvelut voivat esimerkiksi abstrahoida kolmannen osapuolen tarjoamia komponentteja tai rajapintoja, tai sisältää toiminnallisuutta, jonka toteuttaminen kontrollerissa ei ole järkevää esimerkiksi sovelluksen ylläpidettävyyden kannalta. Tutkitaan seuraavaa luokkaa, joka tutkii <a href="http://mbar.fi/apidoc/" target="_blank">MBarin avoimesta rajapinnasta</a> onko tälle päivälle tapahtumia. Palvelu hyödyntää Springin <a href="http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html" target="_blank">RestTemplate</a>-luokkaa, minkä avulla HTTP-pyyntöjen tekeminen on hieman suoraviivaisempaa.</p>

                <pre class="sh_java">
// pakkaus
import org.springframework.web.client.RestTemplate;

public class MBarEvents {

    public Boolean hasEventsToday() {
        RestTemplate restTemplate = new RestTemplate();
        String result = restTemplate.getForObject("http://mbar.fi/api/v1/event/?datefilter=today", String.class);
        return result.contains("start_time");
    }
}</pre>

                <p>Jos vastauksessa on merkkijono <code>start_time</code>, on päivälle merkitty tapahtuma, ja metodi palauttaa arvon <code>true</code>.</p>

                <p>Vaikka ylläolevan toiminnallisuuden voisi sisällyttää kontrollerikerrokseen, kontrollerikerros ennen mittaa täyttyisi tällöin epämääräisistä koodipätkistä. Haluamme saada luokan kontrollerikerroksen käyttöön, mutta kuitenkin niin, että meidän ei tarvitse luoda sitä itse. Lisätään ylläolevalle luokalle annotaatio <code>@Service</code> (<em>palvelu</em>), jolloin se näyttää seuraavalta.</p>

                <pre class="sh_java">
// pakkaus
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

@Service
public class MBarEvents {

    public Boolean hasEventsToday() {
        RestTemplate restTemplate = new RestTemplate();
        String result = restTemplate.getForObject("http://mbar.fi/api/v1/event/?datefilter=today", String.class);
        return result.contains("start_time");
    }
}</pre>

                <p>Nyt, mikä tahansa kontrolleriluokkamme voi käyttää palvelua. Palvelun käyttöönotto tapahtuu <code>@Autowired</code>-annotaation avulla.</p>


                <pre class="sh_java">
// ..

@Controller
@RequestMapping("/events")
public class EventController {

    @Autowired
    private MBarEvents mbarEvents;

    @RequestMapping(method = RequestMethod.GET)
    public String list(Model model) {
        model.addAttribute("mbar", mbarEvents.hasEventsToday());
        return "sopiva näkymä";
    }

    ...</pre>        

                <p>Annotaatioiden <code>@Autowired</code> ja <code>@Service</code> perusteella Spring osaa päätellä että luokasta <code>MBarEvents</code> tulee luoda ilmentymä, sekä injektoida sen kontrolliluokkaamme.</p>


                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-rakkausmittari">
                                    Rakkausmittari
                                </a>
                            </h1>
                        </header>
                        <div id="t-rakkausmittari" class="collapse">

                            <p>Tehtävässä hyödynnetään ysärihittiä ja jatkokehitetään sovellusta, jota käytetään kahden henkilön yhteensopivuuden laskemiseen.</p>

                            <p>Lisää ensiksi LoveService-luokalle <code>@Service</code>-annotaatio, ja <em>injektoi</em> se luokkaan <code>LoveController</code>. Toteuta tämän jälkeen kontrolleriluokkaan metodi, joka ottaa POST-tyyppisen pyynnön vastaan, ja luo pyynnössä olevista parametreista <code>Pair</code>-olion.</p>

                            <p>Kun Pair-olio on vastaanotettu, käytä kontrolleriin injektoitua <code>LoveService</code>-oliota yhteensopivuuden laskemiseksi.</p>

                            <p>Lopuksi, ohjaa käyttäjä tekemään GET-pyyntö <code>/loves</code>-osoitteeseen. Lisää <code>RedirectAttributes</code>-luokan avulla seuraavaan pyyntöön yhteensopivuutta kuvaava arvo sekä pyynnön parametreista generoitu <code>Pair</code>-luokka. Kun lisäät edellä mainittuja <code>RedirectAttributes</code>-olioon, käytä yhteensopivuusarvon nimenä merkkijonoa <code>match</code> ja pair-olion nimenä merkkijonoa <code>pair</code>. </p>

                        </div>
                    </div>
                </div>


                <p>Käytännössä palvelin ja sovelluskehys ottaa vastuuta luokkien hallinnoinnista. Sovelluskehys syöttää riippuvuudet niitä tarvittaessa. Molemmat toiminnallisuudet ovat oleellisia kerrosarkkitehtuurin kerrosten toisistaan erottamisessa.</p>

                <aside class="extra">
                    <h1>Dependency Injection ja Inversion of Control</h1>

                    <p>Jokaisella oliolla on oma selkeä vastuualueensa, ja niiden sekoittamista tulee välttää. Inversion of Control ja Dependency Injection ovat suunnitelumalleja, joilla pyritään vähentämään olioiden turhia riippuvuuksia.</p>

                    <p>Perinteisissä ohjelmistoissa ilmentymien luominen on ohjelmoijan vastuulla. Huomasimme jo aiemmin että Spring luo käyttöömme luokkia joita tarvitsemme: Kontrollin käännöllä tarkoitetaan ohjelman toiminnan hallinnan vastuun siirtämistä sovelluskehykselle ja ohjelmaa suorittavalle palvelimelle (<em>inversion of control</em>). Spring injektoi <code>@Autowired</code>-annotaatiolla merkittyihin oliomuuttujiin ilmentymät luokista, jotka se lataa käyttöönsä palvelinohjelmiston käynnistyessä (<em>dependency injection</em>). Luokat ladataan annotaatioiden perusteella.</p>

                    <p>Lue lisää aiheesta <a href="http://martinfowler.com/articles/injection.html" target="_blank">Martin Fowlerin</a> artikkelista.</p>
                </aside>

                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-chat">
                                    Chat
                                </a>
                            </h1>
                        </header>
                        <div id="t-chat" class="collapse">

                            <p>Sovelluksessa on valmis Chat-palvelu, sekä valmis komponentti kolmannen osapuolen chattikaverin käyttämiseen, jota ei kuitenkaan ole vielä liitetty sovellukseen. Tässä kolmannen osapuolen palvelu integroidaan osaksi chat-palvelua.</p>

                            <p>Sovelluksen rakenne on seuraava. Luokka <code>MessageController</code> ottaa vastaan pyyntöjä käyttöliittymältä, ja ohjaa niitä <code>MessageService</code>-palvelulle. MessageService tarjoaa metodit viestien listaamiseen ja uuden viestin tallentamiseen: tallentaminen tapahtuu <code>MessageRepository</code>-rajapintaa käyttämällä.</p>

                            <p>Muokkaa <code>MessageService</code>-luokan tarjoamaa viestin tallennusmetodia siten, että kun käyttäjän kirjoittama viesti on tallennettu, viesti annetaan <code>ChatService</code>-oliolle, jonka palauttama viesti myös tallennetaan. Injektoi <code>ChatService</code>-palvelu <code>MessageService</code>-palveluun. Huom! Aseta injektoidun ChatService-olion nimeksi <code>chatService</code>.</p>

                            <p>Kun sovellus toimii, keskustelun pitäisi näyttää esimerkiksi seuraavanlaiselta:</p>

                            <pre>
You: hello
Mitsuku: How are you today?
You: good, all peanuts
Mitsuku: Glad to hear it.</pre>
                        </div>
                    </div>
                </div>


                <h2>Tietokantakerros</h2>


                <p>Kun tietokantoja käytetään olio-ohjelmoinnissa, hyödynnetään usein valmiita ORM-työkaluja (<em>Object Relational Mapping</em>). Nämä tarjoavat ohjelmistokehittäjälle mm. toiminnallisuutta tietokantataulujen luomiseen määritellyistä luokista. Työkalut hallinnoivat luokkien välisiä viittauksia ja ylläpitävät tietokannan eheyttä, jolloin ohjelmoijan vastuulle jää sovellukselle tarpeellisten kyselyiden toteuttaminen niiltä osin kun niitä ei tarjota valmiiksi.</p>

                <p>Relaatiotietokantojen käsittelyyn on kehitetty joukko ORM-sovelluksia. Oracle/Sun standardoi olioiden tallentamisen relaatiotietokantoihin <a href="http://en.wikipedia.org/wiki/Java_Persistence_API" target="_blank">JPA</a> (<em>Java Persistence API</em>) -standardilla. JPA:n toteuttavat kirjastot (esim. <a href="http://www.hibernate.org/" target="_blank">Hibernate</a>) abstrahoivat relaatiotietokannan, ja helpottavat kyselyjen tekemistä suoraan ohjelmakoodista. Koska huomattava osa tietokantatoiminnallisuudesta on hyvin samankaltaista ("tallenna", "lataa", "poista", ...), on perustoiminnallisuus toteutettu valmiiksi Spring Data JPA:n puolelle ja ohjelmoija määrittelee usein vain sopivan rajapintaluokan. Esimerkiksi aiemmin nähdyn <code>Person</code>-luokan tallentamistoiminnallisuuteen tarvitaan seuraavanlainen rajapinta.</p>

                <pre class="sh_java">
// pakkaus ja importit
public interface PersonRepository extends JpaRepository&lt;Person, Long&gt; {
}</pre>

                <p>Kun rajapintaa käytetään, Spring osaa injektoida sopivan toteutuksen ohjelman käyttöön.</p>

                <h3>Tallennettavat oliot</h3>

                <p>JPA-standardin mukaan oliot tulee määritellä <em>entiteetiksi</em>, jotta niitä voi tallentaa JPA:n avulla tietokantaan.</p>

                <p>Jokaisella tietokantaan tallennettavalla oliolla tulee olla annotaatio <code>@Entity</code> sekä <code>@Id</code>-annotaatiolla merkattu attribuutti, joka toimii tietokantataulun ensisijaisena avaimena. JPA:ta käytettäessä <code>id</code>-attribuutti on usein numeerinen (<code>Long</code> tai <code>Integer</code>), mutta merkkijonojen käyttö on yleistymässä. Näiden lisäksi, luokan tulee toteuttaa <code>Serializable</code>-rajapinta.</p>

                <p>Numeeriselle avainattribuutille voidaan lisäksi määritellä annotaatio <code>@GeneratedValue(strategy = GenerationType.AUTO)</code>, joka antaa id-kentän arvojen luomisen vastuun tietokannalle. Tietokantatauluun tallennettava luokka näyttää seuraavalta:</p>


                <pre class="sh_java">
// pakkaus

import java.io.Serializable;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity
public class Person implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String name;

    // getterit ja setterit</pre>

                <p>Tietokantaan luotavien sarakkeiden ja tietokantataulun nimiä voi muokata annotaatioiden avulla. Annotaatiot <code>@Column</code> ja <code>@Table</code> auttavat tässä.</p>

                <pre class="sh_java">
// pakkaus

import java.io.Serializable;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table(name = "Person")
public class Person implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name = "id")
    private Long id;
    @Column(name = "name")
    private String name;
    // getterit ja setterit</pre>

                <p>Ylläoleva konfiguraatio määrittelee luokasta <code>Person</code> tietokantataulun nimeltä "Person", jolla on sarakkeet "id" ja "name". Sarakkeiden tyypit päätellään muuttujien tyyppien perusteella.</p>


                <p>Spring Data JPA:n AbstractPersistable-luokka käytettäessä ylläolevan luokan määrittely kutistuu hieman.</p>

                <pre class="sh_java">
// pakkaus ja importit

@Entity
@Table(name = "Person")
public class Person extends AbstractPersistable&lt;Long&gt; {

    @Column(name = "name")
    private String name;
    // getterit ja setterit</pre>


                <h3>Ajan tallentaminen</h3>

                <p>Aikaa kuvaavat attribuutit tulee annotoida <code><a href="http://docs.oracle.com/javaee/6/api/javax/persistence/Temporal.html" target="_blank">@Temporal</a></code>-annotaatiolla, joka määrittelee mikä osa ajasta tallennetaan. Annotaatiolle annetaan parametrina <code><a href="http://docs.oracle.com/javaee/6/api/javax/persistence/TemporalType.html" target="_blank">TemporalType</a></code>-tyyppinen arvo, joka kertoo tarkemman tallennusmuodon. Arvo <code>TemporalType.DATE</code> tallentaa päivämäärän (esim. 2012-09-15), <code>TemporalType.TIME</code> tallentaa kellonajan (esim. 18:00:00), ja arvo <code>TemporalType.TIMESTAMP</code> tallentaa päivän ja ajan (esim. 2012-09-15 18:00:00).</p>

                <p>Annotaatiolla <code>@Temporal</code> merkityn attribuutin tulee olla joko tyyppiä <code>java.util.Date</code> tai tyyppiä <code>java.util.Calendar</code>. Alla on määritelty entiteettiluokka <code>GroceryItem</code>, joka kuvaa elintarviketta. Elintarvikkeella on myös parasta ennen-päivämäärä (bestBefore).</p>

                <pre class="sh_java">
// pakkaus ja importit

@Entity
public class GroceryItem extends AbstractPersistable&lt;Long&gt; {

    private String name;
    @Temporal(TemporalType.DATE)
    private Date bestBefore;

    // getterit ja setterit
}</pre>



                <h3>Transaktioiden hallinta</h3>

		<p>Transaktioiden avulla varmistetaan, että joko kaikki halutut operaatiot suoritetaan, tai yhtäkään niistä ei suoriteta.</p>

                <p>Tietokantatransaktiot määritellään metodi- tai luokkatasolla annotaation <code>@Transactional</code> avulla. Annotaatiolla <code>@Transactional</code> merkittyä metodia suoritettaessa metodin alussa aloitetaan tietokantatransaktio, jossa tehdyt muutokset viedään tietokantaan metodin lopussa. Jos annotaatio <code>@Transactional</code> määritellään luokkatasolla, se koskee jokaista luokan metodia.</p>

                <p>Annotaatiolle <code>@Transactional</code> voidaan määritellä parametri <code>readOnly</code>, jonka avulla määritellään kirjoitetaanko muutokset tietokantaan. Jos parametrin <code>readOnly</code> arvo on <code>true</code>, metodiin liittyvä transaktio perutaan metodin lopussa (rollback). Tällöin metodi ei yksinkertaisesti voi muuttaa tietokannassa olevaa tietoa. </p>

                <p>Spring Data JPA:n käyttämissä luokissa on määritelty luokkatason transaktiot, joten yksittäiset tallennusoperaatiot toimivat myös ilman <code>@Transactional</code>-annotaatiota.</p>

                <p>Transaktiot määritellään tyypillisesti palvelutasolla.</p>


                <h3>Omien kyselyiden toteuttaminen</h3>

                <p>Spring Data JPA ei tarjoa kaikkia kyselyitä valmiiksi. Jos tarvitset tietynlaisen kyselyn, sinun tulee yleensäottaen myös määritellä se. Laajennetaan aiemmin määriteltyä rajapintaa <code>PersonRepository</code> siten, että sillä on metodi <code>List&lt;Person&gt; findByName(String name)</code> -- eli hae henkilöt, joilla on tietty nimi.</p>


                <pre class="sh_java">
// pakkaus

import org.springframework.data.repository.JpaRepository;

public interface PersonRepository extends JpaRepository&lt;Person, Long&gt; {
    List&lt;Person&gt; findByName(String name);
}</pre>

                <p>Ylläoleva esimerkki on esimerkki kyselystä, johon Spring Data ei tarvitse erillistä toteutusta. Se arvaa että kysely olisi muotoa <code>SELECT p FROM Person p WHERE p.name= :name</code> ja luo sen valmiiksi. Lisää Spring Data JPA:n kyselyistä löytyy sen <a href="http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation" target="_blank">dokumentaatiosta</a>.</p>


                <aside class="extra">
                    <h1>Kyselyt Java Persistence Apin kautta</h1>

                    <p>Java Persistence APIn kautta tehdyt kyselyt eivät ole natiivia SQL:ää, vaan seuraavat JPQL-määritelmää (Java Persistence Query Language), joka kuitenkin muistuttaa SQL:ää. JPQL-kielestä löytyy lisää tietoa osoitteesta <a href="http://docs.oracle.com/javaee/6/tutorial/doc/bnbtg.html" target="_blank">http://docs.oracle.com/javaee/6/tutorial/doc/bnbtg.html</a>.</p>

                </aside>


                <p>Tehdään toinen esimerkki, jossa joudumme oikeasti luomaan oman kyselyn. Lisätään rajapinnalle <code>PersonRepository</code> metodi <code>findJackBauer</code>, joka suorittaa kyselyn <code>"SELECT p FROM Person p WHERE p.name = 'Jack Bauer'"</code>.</p>


                <pre class="sh_java">
// pakkaus

import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.JpaRepository;

public interface PersonRepository extends JpaRepository&lt;Person, Long&gt; {
    List&lt;Person&gt; findByName(String name);
    @Query("SELECT p FROM Person p WHERE p.name = 'Jack Bauer'")
    Person findJackBauer();
}</pre>

                <p>Käytössämme on nyt myös metodi <code>findJackBauer</code>, joka suorittaa <code>@Query</code>-annotaatiossa määritellyn kyselyn. Tarkempi kuvaus kyselyiden määrittelystä osana rajapintaa löytyy Spring Data JPAn <a href="http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.at-query" target="_blank">dokumentaatiosta</a>.</p>


                <h3>Toisiin olioiden viittaaminen</h3>


                <p>Toisiin entiteetteihin viittaaminen tapahtuu kuten normaalistikin, mutta ohjelmoijan tulee lisäksi määritellä osallistumisrajoitteet. Osallistumisrajoitteet -- yksi moneen (<em>one to many</em>), moni yhteen (<em>many to one</em>), moni moneen (<em>many to many</em>) lisätään annotaatioiden avulla. Luodaan esimerkiksi luokka <code>Person</code>, joka voi omistaa joukon esineitä. Kukin esine on vain yhden henkilön omistama -- suhde siis yksi moneen -- annotaatio <code>@OneToMany</code>.</p>

                <pre class="sh_java">
@Entity
public class Person extends AbstractPersistable&lt;Long&gt; {

    private String name;
    @OneToMany
    private List&lt;Item&gt; items;</pre>

                <p>Yllä olevaa esimerkkiä käytettäessä luokalle <code>Item</code> luodaan tietokantatauluun automaattisesti sarake, johon tallennetaan omistavan <code>Person</code>-olion yksilöivä tunnus.</p>

                <p>Moni-moneen yhteys tapahtuu tietokantatauluja suunniteltaessa liitostaulun avulla. JPA:ssa moni-moneen yhteydet määritellään annotaatiolla <code>@ManyToMany</code>. Tällöin yhteys tulee merkitä kummallekin puolelle. Jos henkilö voi omistaa useita esineitä, ja esineellä voi olla useita omistajia, toteutus on seuraavanlainen.</p>

                <pre class="sh_java">
@Entity
public class Person extends AbstractPersistable&lt;Long&gt; {

    private String name;
    @ManyToMany
    private List&lt;Item&gt; items;
    ...</pre>

                <pre class="sh_java">
@Entity
public class Item extends AbstractPersistable&lt;Long&gt; {

    private String name;
    private Double weight;
    @ManyToMany(mappedBy = "items")
    private List&lt;Person&gt; owners;</pre>

                <p>Yllä oleva määritelmä luo liitostaulun Item- ja Person-taulujen välille. Item-luokassa olevassa @ManyToMany-annotaatiossa oleva parametri <code>mappedBy = "items"</code> kertoo että Item-luokan <code>owners</code>-kenttä kytketään luokan Person listaan <code>items</code>.</p>


                <h3>Tietokantatoiminnallisuuden käyttäminen palveluista</h3>

                <p>Haluamme usein tallentaa olion joka viittaa olioon, josta viitataan takaisin. </p>

                <p>Pohditaan tätä kontekstissa, jossa tavoitteena on lisätä uusia Person-olioita olemassaolevaan huoneeseen. Huoneella on lista siinä olevista henkilöistä. Yksi ratkaisu on seuraava. </p>

                <pre class="sh_java">
    @Transactional
    public void assignPerson(Long personId, Long roomId) {
        Room room = roomRepository.findOne(roomId);
        Person person = personRepository.findOne(personId);

        person.setRoom(room);
        room.getOccupants().add(person);
    }</pre>

                <p>Koska ylläolevassa esimerkissä koodi suoritetaan transaktion sisällä, ladattuihin olioihin tehdyt muutokset viedään tietokantaan transaktion lopussa.</p>

                <p><strong>Poistaminen</strong></p>


                <p>Pohditaan seuraavaksi tilannetta, jossa haluaisimme poistaa tietyn henkilön. Ensimmäinen hahmotelma on kutakuinkin seuraavanlainen:</p>

                <pre class="sh_java">
    @Transactional
    public void removePerson(Long personId) {
        personRepository.delete(personId);
    }</pre>

                <p>Yllä olevassa lähestymistavassa ongelmana on kuitenkin se, että huoneet eivät kadota viittausta henkilöön. Käytännössä henkilö jää "haamuksi" järjestelmään tai saamme virheen poistoa yrittäessä. Jos haluamme poistaa huoneisiin liittyvät viittaukset henkilöön, joudumme tekemään sen käsin.</p>

                <pre class="sh_java">
    @Transactional
    public void removePerson(Long personId) {
        Person person = personRepository.findOne(personId);
        person.getRoom().getOccupants().remove(person);
        personRepository.delete(person);
    }</pre>



                <h3>Milloin oliot haetaan</h3>


                <p>Tietokanta-abstraktioita tarjoavat komponentit kuten Hibernate päättävät mitä tehdään haettavaan olioon liittyville viitteille. Yksi vaihtoehto on hakea viitatut oliot automaattisesti kyselyn yhteydessä ("Eager"), toinen vaihtoehto taas on hakea viitatut oliot vasta kun niitä pyydetään eksplisiittisesti esimerkiksi get-metodin kautta ("Lazy").</p>

                <p>Tyypillisesti one-to-many ja many-to-many -viitteet haetaan vasta niitä tarvittaessa, ja one-to-one ja many-to-one viitteet heti. Oletuskäyttäytymistä voi muuttaa <a href="http://docs.oracle.com/javaee/6/api/javax/persistence/FetchType.html" target="_blank">FetchType</a>-parametrin avulla. Esimerkiksi alla ehdotamme, että <code>apartments</code>-lista noudetaan heti.</p>

                <pre class="sh_java">
// pakkaus

@Entity
public class Person extends AbstractPersistable&lt;Long&gt; {

    private String name;

    // oletamme, että Apartment-entiteetti on olemassa
    @OneToMany(fetch=FetchType.EAGER)
    @JoinColumn 
    private List&lt;Apartment&gt; apartments; 

    // getterit ja setterit
}
                </pre>

                <p>Käytännössä tietokannasta tarvittaessa haku toteutetaan muokkaamalla get-metodia siten, että tietokantakysely tapahtuu metodia kutsuttaessa. Staattisesti tyypitetyissä ohjelmointikielissä tämä käytännössä vaatii sitä, että luokkien rakennetta muutetaan joko ajonaikaisesti tai lähdekooditiedostojen kääntövaiheessa -- käyttämämme komponentit tekevät tämän puolestamme.</p>




                <aside class="info">

		  <br/>
		  
                  <h1>N+1 Kyselyn ongelma</h1>
		  
                  <p>Viitattujen olioiden lataaminen vasta niitä tarvittaessa on yleisesti ottaen hyvä idea, mutta sillä on myös kääntöpuolensa. Pohditaan tilannetta, missä kirjalla voi olla monta kirjoittajaa, ja kirjoittajalla monta kirjaa -- <code>@ManyToMany</code>. Jos haemme tietokannasta listan kirjoja (1 kysely), ja haluamme tulostaa kirjoihin liittyvät kirjoittajat, tehdään jokaisen kirjan kohdalla erillinen kysely kyseisen kirjan kirjoittajille (n kyselyä). Tätä ongelmaa kutsutaan N+1 -kyselyn ongelmaksi.</p>
		  
                  <p>Jos kirjoja tarvitaan sekä ilman kirjoittajaa että kirjoittajan kanssa, on FetchType-parametrin asettaminen <code>EAGER</code>-tyyppiseksi yksi vastaus. Tällöin kuitenkin osassa tapauksista haetaan ylimääräistä dataa tietokannasta. Toinen vaihtoehto on luoda erillinen kysely yhdelle vaihtoehdoista, ja lisätä kyselyyn vinkki (<a href="http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-hints" target="_blank">Spring Data JPA, applying query hints</a>) kyselyn toivotusta toiminnallisuudesta.</p>
                </aside>
		

                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-lentokentat">
                                    Lentokentät ja lentokoneet
                                </a>
                            </h1>
                        </header>
                        <div id="t-lentokentat" class="collapse">

                            <p>Jatkokehitetään tässä tehtävässä sovellusta lentokoneiden ja lentokenttien hallintaan. Projektissa on jo valmiina ohjelmisto, jossa voidaan lisätä ja poistaa lentokoneita. Tavoitteena on lisätä toiminnallisuus lentokoneiden kotikenttien asettamiseksi.</p>

                            <h1>Tallennettavat: <code>Aircraft</code> ja <code>Airport</code>.</h1>

                            <p>Lisää luokkaan <code>Aircraft</code> attribuutti <code>airport</code>, joka kuvaa lentokoneen kotikenttää, ja on tyyppiä <code>Airport</code>. Koska usealla lentokoneella voi olla sama kotikenttä, käytä attribuutille <code>airport</code> annotaatiota <code>@ManyToOne</code>. Lisää attribuutille myös <code>@JoinColumn</code>-annotaatio, jonka avulla kerrotaan että tämä attribuutti viittaa toiseen tauluun. Lisää luokalle myös oleelliset get- ja set-metodit.</p>

                            <p>Lisää seuraavaksi <code>Airport</code>-luokkaan attribuutti <code>aircrafts</code>, joka kuvaa kaikkia koneita, keiden kotikenttä kyseinen kenttä on, ja joka on tyyppiä <code>List&lt;Aircraft&gt;</code>. Koska yhdellä lentokentällä voi olla useita koneita, lisää attribuutille annotaatio <code>@OneToMany</code>. Koska luokan <code>Aircraft</code> attribuutti <code>airport</code> viittaa tähän luokkaan, aseta annotaatioon <code>@OneToMany</code> parametri <code>mappedBy="airport"</code>. Nyt luokka <code>Airport</code> tietää että attribuuttiin <code>aircrafts</code> tulee ladata kaikki <code>Aircraft</code>-oliot, jotka viittaavat juuri tähän kenttään.</p>

                            <p>Lisää lisäksi <code>Airport</code>-luokan <code>@OneToMany</code>-annotaatioon parametri <code>fetch = FetchType.EAGER</code>, jolloin lentokenttään liittyvät lentokoneet haetaan kyselyn yhteydessä.</p>

                            <p>Lisää lopuksi luokalle <code>Airport</code> oleelliset get- ja set-metodit.</p>


                            <h1>Lentokentän asetus lentokoneelle</h1>

                            <p>Lisää sovellukselle toiminnallisuus lentokentän lisäämiseen lentokoneelle. Käyttöliittymä sisältää jo tarvittavan toiminnallisuuden, joten käytännössä sinun tulee toteuttaa luokalle <code>AircraftController</code> metodi <code>String assignAirport</code>. Kun käyttäjä lisää lentokoneelle lentokenttää, käyttöliittymä lähettää POST-tyyppisen kyselyn osoitteeseen <code>/aircrafts/{aircraftId}/airports</code>, missä <code>aircraftId</code> on lentokoneen tietokantatunnus. Pyynnön mukana tulee lisäksi parametri <code>airportId</code>, joka sisältää lentokentän tietokantatunnuksen.</p>

                            <p>Toteuta metodi siten, että haet aluksi pyynnössä saatuja tunnuksia käyttäen lentokoneen ja lentokentän, tämän jälkeen asetat lentokoneelle lentokentän ja lentokentälle lentokoneen, ja lopuksi tallennat haetut oliot.</p>

                            <p>Ohjaa lopuksi pyyntö osoitteeseen <code>/aircrafts</code></p>

                            <p>Kun olet valmis, lähetä sovellus TMC:lle tarkistettavaksi.</p>
                        </div>
                    </div>

                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-elokuvatietokanta">
                                    Elokuvatietokanta
                                </a>
                            </h1>
                        </header>
                        <div id="t-elokuvatietokanta" class="collapse">

                            <p>Tämä on avoin tehtävä jossa saat itse suunnitella huomattavan osan ohjelman sisäisestä rakenteesta. Ainoat määritellyt asiat ohjelmassa ovat käyttöliittymä ja domain-oliot, jotka tulevat tehtäväpohjan mukana. Tehtäväpohjassa on myös valmis konfiguraatio.</p>

                            <p>Tehtävästä on mahdollista saada yhteensä 4 pistettä.</p>

                            <p>Huom! Kannattanee aloittaa näyttelijän lisäämisestä ja poistamisesta. Suunnittele ensin sopiva tietokantaolio, sekä sille sopivat repository-oliot. Jatka tämän jälkeen kontrollerin toteutuksella -- sekä mahdollisesti palvelukerroksen lisäämisellä. Kannattanee hyödyntää valmiiksi tarjotuissa käyttöliittymätiedostoissa olevaa koodia osana tietokantaolioiden attribuuttien määrittelyä.</p>

                            <h1>pisteytys</h1>

                            <ol class="pisteytys">
                                <li>+ 1p: Näyttelijän lisääminen ja poistaminen onnistuu. Käyttöliittymän olettamat osoitteet ja niiden parametrit:<br/>
                                    <ul>
                                        <li><code>GET /actors</code> - näyttelijöiden listaus, ei parametreja pyynnössä. Lisää pyyntöön attribuutin <code>actors</code>, joka sisältää kaikki näyttelijät ja luo sivun <code>/src/main/resources/templates/actors.html</code> pohjalta näkymän.</li>

                                        <li><code>POST /actors</code> - parametri <code>name</code>, jossa on lisättävän näyttelijän nimi. Lisäyksen tulee lopulta ohjata pyyntö osoitteeseen <code>/actors</code>.</li>

                                        <li><code>DELETE /actors/{actorId}</code> - polun parametri <code>actorId</code>, joka sisältää poistettavan näyttelijän tunnuksen. Poiston tulee lopulta ohjata pyyntö osoitteeseen <code>/actors</code>.</li>
                                    </ul>
                                </li>

                                <p></p>

                                <li>+ 1p: Elokuvan lisääminen ja poistaminen onnistuu. Käyttöliittymän olettamat osoitteet ja niiden parametrit:<br/>
                                    <ul>
                                        <li><code>GET /movies</code> - elokuvien listaus, ei parametreja pyynnössä. Lisää pyyntöön attribuutin <code>movies</code>, joka sisältää kaikki elokuvat ja luo sivun <code>/src/main/resources/templates/movies.html</code> pohjalta näkymän.</li>

                                        <li><code>POST /movies</code> - elokuvan lisäys, parametrit <code>name</code>, joka sisältää lisättävän elokuvan nimen, ja <code>lengthInMinutes</code>, joka sisältää elokuvan pituuden minuuteissa. Lisäyksen tulee lopulta ohjata pyyntö osoitteeseen <code>/movies</code>.</li>

                                        <li><code>DELETE /movies/{movieId}</code> - polun parametri <code>movieId</code>, joka sisältää poistettavan elokuvan tietokantatunnuksen. Poiston tulee lopulta ohjata pyyntö osoitteeseen <code>/movies</code>.</li>
                                    </ul>
                                </li>

                                <p></p>

                                <li>+ 2p: Näyttelijän voi lisätä elokuvaan (kun näyttelijä tai elokuva poistetaan, tulee myös poistaa viitteet näyttelijästä elokuvaan ja elokuvasta näyttelijään). Käyttöliittymän olettamat osoitteet ja niiden parametrit:<br/>
                                    <ul>

                                        <li><code>GET /actors/{actorId}</code> - polun parametri <code>actorId</code>, joka sisältää näytettävän näyttelijän tietokantatunnuksen. Asettaa pyyntöön sekä attribuutin <code>actor</code> jossa näyttelijä-olio että attribuutin <code>movies</code>, jossa kaikki elokuvat, sekä luo sivun <code>/src/main/resources/templates/actor.html</code> pohjalta näkymän.</li>

                                        <li><code>POST /actors/{actorId}/movies</code> - polun parametri <code>actorId</code>, joka sisältää kytkettävän näyttelijän tietokantatunnuksen, ja parametri <code>movieId</code>, joka sisältää kytkettävän elokuvan tietokantatunnuksen. Lisäämisen tulee lopulta ohjata pyyntö osoitteeseen <code>/actors</code>.</li>
                                    </ul>
                                </li>
                            </ol>
                        </div>
                    </div>
                </div>


                <h3>Tietokantakyselyn tulosten järjestäminen ja rajoittaminen</h3>

                <p>Tietokantakyselyn tulokset halutaan usein hakea tai järjestää tietyn kriteerin mukaan. Jos tietokantadatan läpikäynti toteutettaisiin osana palvelua, tekisimme oikeastaan juuri sen työn, missä tietokannat loistavat.</p>

                <p>Esimerkiksi alla oleva lisäys tarjoaa metodin henkilöiden etsimiseen, joilla ei ole huonetta (oletamme että Person-luokalla on attribuutti Room).</p>

                <pre class="sh_java">
public interface PersonRepository extends JpaRepository&lt;Person, Long&gt; {
    List&lt;Person&gt; findByRoomIsNull();
}</pre>

                <p>Vastaavasti voisimme hakea esimerkiksi nimen osalla: <code>findByNameContaining(String osa)</code>.</p>

                <p>Spring Data JPAn rajapinta <a href="http://docs.spring.io/spring-data/jpa/docs/1.4.1.RELEASE/api/org/springframework/data/jpa/repository/JpaRepository.html" target="_blank">JpaRepository</a> mahdollistaa muutaman lisäparametrin käyttämisen osassa pyyntöjä. Voimme esimerkiksi käyttää parametria <a href="http://docs.spring.io/spring-data/commons/docs/1.5.2.RELEASE/api/org/springframework/data/domain/PageRequest.html" target="_blank">PageRequest</a>, joka tarjoaa apuvälineet sivuttamiseen sekä pyynnön hakutulosten rajoittamiseen. Alla olevalla PageRequest-oliolla haluasimme ensimmäiset 50 hakutulosta attribuutin name mukaan käänteisessä järjestyksessä.</p>

                <pre class="sh_java">
    Pageable pageable = new PageRequest(0, 50, Sort.Direction.DESC, "name");</pre>

                <p>Voimme muokata metodia <code>findByRoomIsNull</code> hyväksymään <code>Pageable</code>-rajapinnan toteuttavan olion parametriksi, jolloin metodi palauttaa <a href="http://docs.spring.io/spring-data/data-commons/docs/1.6.1.RELEASE/api/org/springframework/data/domain/Page.html" target="_blank">Page</a>-luokan ilmentymän.</p>

                <pre class="sh_java">
public interface PersonRepository extends JpaRepository&lt;Person, Long&gt; {
    Page&lt;Person&gt; findByRoomIsNull(Pageable pageable);
}</pre>

                <p>Yhdistämällä kaksi edellistä, voisimme hakea kaikki huoneettomat henkilöt sopivasti järjestettynä:</p>

                <pre class="sh_java">
//...
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
//...

    // tämä palvelussa
    Pageable pageable = new PageRequest(0, 50, Sort.Direction.DESC, "name");
    Page&lt;Person&gt; personPage = personRepository.findByRoomIsNull(pageable);
    List&lt;Person&gt; persons = personPage.getContent();
                </pre>



                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-viimeisetviestit">
                                    Viimeiset viestit
                                </a>
                            </h1>
                        </header>
                        <div id="t-viimeisetviestit" class="collapse">

                            <p>Tehtävässä on käytössä Chat-tehtävästä tuttu sovellus. Muokkaa sovellusta siten, että MessageServicen <code>list</code>-metodi palauttaa uusimmat 10 viestiä. Käytä tässä hyödyksi yllä nähtyä Pageable-oliota.</p>

                        </div>
                    </div>
                </div>

            </section>
            <!-- END WEEK2 -->


            <!-- BEGIN WEEK3 -->
            <section class="weeklimit" data-week-id="3">
                <header>
                    <h1 id="viikko3">Viikko 3</h1>
                </header>

<!--
		<aside class="info">
		  <br/>
		  <h1>Palvelimen tuottamien virheviestien tulkinta</h1>


		</aside>
-->

                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-uniraportit">
                                    Uniraportit
                                </a>
                            </h1>
                        </header>
                        <div id="t-uniraportit" class="collapse">

                            <p>Kerrataan edellisten viikkojen teemoja, ja toteutetaan Unipalvelu, johon käyttäjä voi tallentaa tietoja nukkumisestaan. Tehtävässä kerrataan aiemmin oppimiamme asioita.</p>


                            <h1>Domain-luokka ja Repository</h1>

                            <p>Muokkaa pakkauksessa <code>wad.domain</code> olevaa luokkaa <code>Sleep</code> niin, että se toteuttaa alla olevan rungon. Tee luokasta entiteetti ja periytä se luokasta <code>AbstractPersistable</code> siten, että luokan ID-kentän tyypiksi tulee <code>Long</code>. Muista myös luoda getterit ja setterit attribuuteille.

                            <pre class="sh_java sh_sourceCode">
import org.springframework.format.annotation.DateTimeFormat;

//...
    @DateTimeFormat(pattern = "d.M.y H:m")
    private Date start;

    @DateTimeFormat(pattern = "d.M.y H:m")
    private Date end;

    private String feeling;
// ..
                            </pre>


                            <p><code>@DateTimeFormat</code> annotaatiolla Spring muuntaa tekstihahmon <code>d.M.y H:m</code> muotoisen merkkijonoesityksen päivämäärästä ja ajasta (kuten 23.9.2014 18:41) <code>Date</code>-olioksi. Voimme siis syöttää lomakkeessa merkkijonon, joka muutetaan suoraan <code>Date</code>ksi.</p>


                            <h2>Attribuuteista:</h2>

                            <ul>
                                <li><code>start</code> - Käytä annotaatiota <code>@Temporal</code> tyypillä <code>TIMESTAMP</code>. Validoi myös että attribuutti ei ole null.</li>
                                <li><code>end</code> - Kuten edeltävä attribuutti.</li>
                                <li><code>feeling</code> - Validoi ettei attribuutti ole tyhjä tai null.</li>
                            </ul>


                            <h2>Repository</h2>

                            <p>Tee entiteetille repository-rajapinta <code>SleepRepository</code> pakkaukseen <code>wad.repository</code>. Rajapinnan tulee tuttuun tapaan periä Spring Data JPA:n rajapintaluokka <code>JpaRepository</code> siten, että tallennettava olio on tyyppiä <code>Sleep</code> ja avaimena on <code>Long</code>.</p>


                            <h1>Kontrollerit (2p)</h1>

                            <p>Toteuta pakkaukseen <code>wad.controller</code> kontrolleriluokka <code>SleepController</code>. Injektoi luokkaan <code>@Autowired</code>-annotaatiota käyttäen <code>SleepRepository</code>-toteutus. Luokan metodien tulee toimia seuraavanlaisesti:</p>

                            <p>Huom! Tarkista aiemmasta materiaalista mitä GET-pyynnön yhteydessä tulee antaa luotavalle näkymälle kun sivulla on Thymeleafin validoima lomake-elementti -- tarvitset Sleep-olion jo GET-pyyntöön.</p>

                            <ul>
                                <li>
                                    <code>public String list(Model model)</code>
                                    <ol>
                                        <li>Vastaa GET-pyyntöihin osoitteessa <code>sleeps</code>.</li>
                                        <li>Hakee tietokannasta listan kaikista <code>Sleep</code> entiteeteistä ja lisää ne <code>model</code>iin attribuutilla <code>sleeps</code>.</li>
                                        <li>Palauttaa näkymästä <code>/src/main/resources/templates/sleeps.html</code> luodun sivun.</li>
                                    </ol>
                                </li>
                                <li>
                                    <code>public String create(RedirectAttributes redirectAttrs, Sleep sleep, BindingResult result)</code>
                                    <ol>
                                        <li>Vastaa POST-pyyntöihin osoitteessa <code>sleeps</code>.</li>
                                        <li>Parametrina saadaan lomakkeesta generoitu <code>Sleep</code> entiteetti. Käytä <code>@ModelAttribute</code>-annotaatiota ja varmista, että entiteetti on validi. Tarkista tiedon lähettämiseen käytetystä html-sivusta minkä niminen @ModelAttribute-annotaatiota seuraavan olion tulee olla.</li>
                                        <li>Mikäli <code>result</code> oliossa on virheitä, palauta näkymästä <code>/src/main/resources/templates/sleeps.html</code> luotu sivu virheiden näyttämistä varten. Luo erillisen <code>getSleep</code>-metodi, joka asettaa modeliin automaattisesti <code>Sleep</code>-olion -- näin näet myös virheet sivulla.</li>
                                        <li>Mikäli virheitä ei ole, metodi tallentaa <code>Sleep</code> entiteetin tietokantaan ja ohjaa käyttäjän osoitteeseen <code>/sleeps/{id}</code>, missä id-kentän arvoksi tulee juuri luodun olion tunnus. Käytä tässä hyödyksi <code>RedirectAttributes</code>-oliota. <strong>Huom!</strong> Jos et muista <code>addAttribute</code> ja <code>addFlashAttribute</code> -komentojen eroa, kertaa ne aiemman viikon materiaalista!</li>
                                    </ol>
                                </li>
                                <li>
                                    <code>public String read(Model model, Long id)</code>
                                    <ol>
                                        <li>Vastaa GET-pyyntöihin osoitteessa <code>sleeps/{id}</code>, polussa tulee haettavan <code>Sleep</code> entiteetin ID.</li>
                                        <li>Hakee palvelukerroksesta vastaavan entiteetin ja lisää sen <code>model</code>iin attribuutilla <code>sleep</code>.</li>
                                        <li>Palauttaa näkymästä <code>/src/main/resources/templates/sleep.html</code> luodun sivun.</li>
                                    </ol>
                                </li>
                                <li>
                                    <code>public String delete(Long id)</code>
                                    <ol>
                                        <li>Vastaa DELETE-pyyntöihin osoitteessa <code>sleeps/{id}</code>, polussa tulee poistettavan <code>Sleep</code> entiteetin ID.</li>
                                        <li>Poistaa kyseisen <code>Sleep</code> entiteetin tietokannasta.</li>
                                        <li>Ohjaa käyttäjän osoitteeseen <code>sleeps</code>.</li>
                                    </ol>
                                </li>
                            </ul>

                            <p>Testaa nyt ohjelma kokonaisuudessaan ja kun testit menevät läpi, lähetä sovellus TMC:lle.</p>
                        </div>
                    </div>
                </div>


                <h1>REST</h1>
                
                
                <p>Huomattava osa ohjelmointirajapinnoista on toteutettu siten, että niiden muuttaminen ei ole helppoa. Kun ohjelmistokehittäjät luovat rajapintoja käyttäviä komponentteja, tehdään tyypillisesti rajapintakohtaisia päätöksiä ja toteutuksia, jotka luonnollisesti hajoavat <em>jos</em> käytettävä rajapinta muuttuu. Organisaatioilla kuten Facebook, Twitter ja Flickr on jokaisella oma ohjelmointirajapinta. Esimerkiksi käyttäjän ystävien hakeminen <a href="https://dev.twitter.com/rest/public" target="_blank">Twitter-rajapinnasta</a> tapahtuu osoitteesta <code>api.twitter.com/1.1/friends/list.json</code> -- käyttäjän täytyy tunnistautua ennen hakua, kun taas <a href="https://developers.facebook.com/docs/graph-api" target="_blank">Facebookin rajapinnan</a> avulla käyttäjän kaverit löytyvät osoitteesta <code>graph.facebook.com/v2.4/{tunnus}/friendlists</code>, missä {tunnus} on käyttäjän tunnus -- tässäkin tapauksessa käyttäjän täytyy tunnistautua ennen hakua. Hakuosoitteiden muoto, tunnistautuminen ja vastausdata ovat tyypillisesti organisaatiokohtaisia.</p>
                
                <p>Tähän liittyy useita ongelmia, joista ensisijaiset liittyvät rajapinnan käyttöönottoon liittyvään työmäärään. Koska rajapinnan muoto ja data on organisaatiokohtaista, tehdään jokaista rajapintaa varten oma asiakasohjelmisto. Olisiko mahdollista toteuttaa rajapinta tai rajapinnan osia siten, että rajapintaa käyttävät toteutukset olisivat yleiskäyttöisiä?</p>
                
                <p>REST-rajapinnat (<a href="http://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank">representational state transfer</a>) liittyvät <em>resursseihin</em> (henkilöt, kirjat, laskentaprosessit, laskentatulokset -- mikä tahansa voi käytännössä olla resurssi). Resursseilla on resurssikokoelmat ja yksittäiset resurssit yksilöivä <em>osoite</em> -- resurssikokoelmat voivat löytyä esimerkiksi osoitteiden <code>/persons</code>, <code>/books</code>, <code>/processes</code> tai <code>/results</code> takaa; yksittäisille resursseille määritellään uniikit osoitteet (esimerkiksi <code>/persons/1</code>). Tämän lisäksi, käsiteltävä data -- esimerkiksi JSON tai XML -- on yhdenmukaista; dataa voi lähettää ja vastaanottaa samassa muodossa. Lopulta, rajapinnat ovat <em>löydettäviä ja navigoitavia</em> -- palvelimen palauttama data voi sisältää esimerkiksi hypermedialinkkejä muihin resursseihin. Resurssien käsittelyyn (muokkaaminen, lisääminen, poisto, ...) käytetään HTTP-protokollan metodeja.</p>
                
                <p>REST on hyödyllinen malli mm. olemassaolevien jo hieman ikääntyneiden palveluiden kapselointiin sekä uusien rajapintojen tarjoamiseen. Sovelluskehittäjä voi kehittää uuden käyttöliittymän ja käyttää vanhaan sovellukseen liittyvää toiminnallisuutta REST-rajapinnan kautta. REST-palvelun ovat nykyään hyvin yleisiä ja niiden luomiseen on tehty huomattava määrä apuohjelmia.</p>

                <aside class="info">
		  <br/>

                  <h1>Tiedon alkulähteille</h1>
		  
                  <p>Tutustu Roy T. Fieldingin ja Richard N. Taylorin artikkeliin <a href="resources/principled-design-of-the-modern-web-architecture.pdf" target="_blank">"Principled Design of the Modern Web Architecture"</a>, jossa REST määritellään. Vaikka emme tässä kappaleessa täytä kaikkia REST-rajapintoihin liittyviä vaatimuksia -- ainakaan aluksi -- on Roy Fielding sitä mieltä, että <a href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven" target="_blank">oleellista on mahdollisuus resurssien välillä navigointiin</a>.</p>
		  
                  <p><em>"A truly RESTful API looks like hypertext. Every addressable unit of information carries an address, either explicitly (e.g., link and id attributes) or implicitly (e.g., derived from the media type definition and representation structure). Query results are represented by a list of links with summary information, not by arrays of object representations (query is not a substitute for identification of resources)."</em></p>

                </aside>
                

                <h2>Omat REST-rajapinnat</h2>
                
                <p>Tutkitaan seuraavaa kirjojen ylläpitämiseen tarkoitettua kuvitteellista rajapintaa.</p>

                <ul>
                    <li>GET-pyyntö osoitteeseen <code>/books</code> palauttaa kaikkien kirjojen tiedot.</li>
                    <li>GET osoitteeseen <code>/books/{id}</code>, missä <code>{id}</code> on yksittäisen kirjan yksilöivä tunniste, palauttaa kyseisen kirjan tiedot.</li>
                    <li>PUT osoitteeseen <code>/books/{id}</code>, missä <code>{id}</code> on yksittäisen kirjan yksilöivä tunniste, muokataan kyseisen kirjan tietoja. Kirjan uudet tiedot lähetetään osana pyyntöä.</li>
                    <li>DELETE osoitteeseen <code>/books/{id}</code> poistaa kirjan tietyllä tunnuksella.</li>
                    <li>POST osoitteeseen <code>/books</code> luo uuden kirjan pyynnön rungossa lähetettävän datan pohjalta. Palvelun vastuulla on päättää kirjalle tunnus.</li>
                </ul>

                <p>Kuten huomaat, osoitteissa käytetään substantiivejä -- ei <code>books?id={id}</code> vaan <code>/books/{id}</code>, ja pyyntötyypeistä voi päätellä halutun operaation. DELETE-tyyppisellä pyynnöllä poistetaan, POST-tyyppisellä pyynnöllä lisätään, PUT-tyyppisellä pyynnöllä päivitetään tietoja, ja GET-tyyppisellä pyynnöllä haetaan. Kuten HTTP-kommunikaatiossa yleensäkin, <em>GET-pyynnöt eivät muokkaa tallennettua dataa</em>.</p>

                <p>REST-rajapinnan käyttämä dataformaatti on toteuttajan päätettävissä. Nykyään huomattava osa palveluista käyttää <a href="http://en.wikipedia.org/wiki/JSON" target="_blank">JSON</a>-dataformaattia, sillä sen käyttäminen osana selainohjelmistoja on suoraviivaista JavaScriptin kautta. Myös palvelinohjelmistot tukevat olioiden muuttamista JSON-muotoon.</p>

                <p>Oletetaan että edelläkuvattu kirjojen käsittelyyn tarkoitettu rajapinta käsittelee JSON-muotoista dataa. Kirjaa kuvaava luokka on seuraavanlainen:</p>
                
                <pre class="sh_java">
package wad;

public class Book {
    private Long id;
    private String name;

    public Long getId() {
        return this.id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return this.name;
    }

    public String setName(String name) {
        this.name = name;
    }
}</pre>
                
                <p>Kun luokasta on tehty olio, jonka <code>id</code>-muuttujan arvo on <code>2</code> ja nimi <code>"Harry Potter and the Chamber of Secrets"</code>, on sen JSON-esitys seuraavanlainen:</p>

                <pre>
{
  "id":2,
  "name":"Harry Potter and the Chamber of Secrets"
}</pre>
                
                <p>Käytännössä siis JSON-notaatio määrittelee olion alkavalla aaltosululla <code>{</code>, jota seuraa oliomuuttujien nimet ja niiden arvot. Lopulta olio päätetään sulkevaan aaltosulkuun <code>}</code>. Oliomuuttujien nimet ovat hipsuissa <code>"</code> sillä ne käsitellään merkkijonoina; muuttujien arvot voivat olla hipsuissa, riippuen arvon tyypistä. Tarkempi kuvaus JSON-notaatiosta löytyy esimerkiksi sivulta <a href="http://json.org/" target="_blank">json.org</a>.</p>


                <p>Pyynnön rungossa lähetettävän JSON-muotoisen datan muuttaminen olioksi tapahtuu annotaation <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RequestBody.html" target="_blank">@RequestBody</a> avulla. Annotaatio @RequestBody edeltää kontrollerimetodin parametrina olevaa oliota, johon sovelluskehittäjä pyytää Spring-sovelluskehystä asettamaan JSON-muotoisen datan arvot.</p>

                <pre class="sh_java">
    @RequestMapping(method=RequestMethod.POST)
    public String postBook(@RequestBody Book book) {
        bookRepository.save(book);
        return "redirect:/books";
    }</pre>

                <p>Vastauksen saa lähetettyä käyttäjälle JSON-muodossa (tai muussa muodossa, riippuen käytössä olevista riippuvuuksista) lisäämällä pyyntöä käsittelevään metodiin annotaation <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/ResponseBody.html" target="_blank">@ResponseBody</a>. Annotaatio @ResponseBody pyytää Spring-sovelluskehystä asettamaan palvelimen tuottaman datan selaimelle lähetettävän vastauksen runkoon. Jos vastaus on olio, muutetaan se automaattisesti esimerkiksi JSON-muotoiseksi vastaukseksi.</p>

                <pre class="sh_java">
    @RequestMapping(method=RequestMethod.GET)
    @ResponseBody
    public Book getBook() {
        Book book = new Book();
        book.setName("Spring API");
        return book;
    }</pre>

                <p>Edellä mainitut annotaatiot voi myös yhdistää. Oletetaan, että käytössä on <code>bookRepository</code>-niminen olio, jonka metodi <code>save</code> lisää kirjalle yksilöivän tunnuksen ja varastoi sen myöhempää käyttöä varten. Metodi myös palauttaa viitteen uuteen kirja-olioon. Uuden kirjan lisääminen tapahtuisi tällöin seuraavasti.</p> 

                <pre class="sh_java">
    @RequestMapping(method=RequestMethod.POST)
    @ResponseBody
    public Book postBook(@RequestBody Book book) {
        return bookRepository.save(book);
    }</pre>
                
                <p>Nyt palvelulle voi lähettää JSON-muotoista dataa; vastaus on myös JSON-muotoinen, mutta luotavaan kirjaan on liitetty sen yksilöivä tunnus.</p>

                <p>Voimme lisätä annotaatioon @RequestMapping lisätietoa metodin tuottamasta datasta. Attribuutti <code>consumes</code> kertoo minkälaista dataa metodin kuuntelema osoite hyväksyy. Metodi voidaan rajoittaa vastaanottamaan JSON-muotoista dataa merkkijonolla <code>"application/json"</code>. Vastaavasti metodille voidaan lisätä tietoa datasta, jota se tuottaa. Attribuutti <code>produces</code> kertoo tuotettavan datatyypin. Alla määritelty metodi sekä vastaanottaa että tuottaa JSON-muotoista dataa.</p>

                <pre class="sh_java">
    @RequestMapping(method=RequestMethod.POST, 
                      consumes="application/json", produces="application/json")
    @ResponseBody
    public Book postBook(@RequestBody Book book) {
        return bookStorage.create(book);
    }</pre>


                <p>Käytännössä kannattaa käyttää <code>@RestController</code>-annotaatiota kontrolleriluokan määrittelyssä. Tämä asettaa jokaisen luokan metodiin annotaation <code>@ResponseBody</code> sekä sopivan datatyypin -- tässä tapauksessa "application/json".</p>

                <p>Toteutetaan seuraavaksi kaikki tarvitut metodit kirjojen tallentamiseen. Kontrolleri hyödyntää erillistä luokkaa, joka tallentaa kirjaolioita tietokantaan, sekä tarjoaa tuen aiemmin määrittelemiemme books-osoitteiden ja pyyntöjen käsittelyyn -- PUT-metodi on jätetty omaa kokeilua varten.</p>


                <pre class="sh_java">
// importit

@RestController
@RequestMapping("books")
public class BookController {

    @Autowired
    private BookRepository bookRepository;

    @RequestMapping(method=RequestMethod.GET)
    public List&lt;Book&gt; getBooks() {
        return bookRepository.findAll();
    }

    @RequestMapping(value="/{id}", method=RequestMethod.GET)
    public Book getBook(@PathVariable Integer id) {
        return bookRepository.findOne(id);
    }

    @RequestMapping(value="/{id}", method=RequestMethod.DELETE)
    public Book deleteBook(@PathVariable Integer id) {
        return bookRepository.delete(id);
    }    

    @RequestMapping(method=RequestMethod.POST)
    public Book postBook(@RequestBody Book book) {
        return bookRepository.save(book);
    }
}</pre>

                <aside class="info">
		  <br/>
                  <h1>Apuvälineitä rajapinnan tarjoavan sovelluksen testaamiseen</h1>
		  
                  <p>Palvelinohjelmistot, jotka tarjoavat vain avoimen rajapinnan kolmannen osapuolen ohjelmistoille, eivät tyypillisesti sisällä erillistä käyttöliittymää. Tällöin niiden testaaminen tapahtuu tyypillisesti sekä automaattisilla testeillä, että erilaisilla selainohjelmistoilla. Yksi hyvin hyödyllinen apuväline on <a href="https://www.getpostman.com/" target="_blank">Postman</a>, jonka saa lisättyä Google Chromeen Googlen web-storesta.</p>
		  
                  <p>Postmanin hyödyntäminen on erittäin suositeltavaa -- kannattaa katsoa sen johdatusvideo, joka löytyy Postmanin sivulta. Katso myös <a href="https://www.youtube.com/watch?v=7YcW25PHnAA" target="_blank">RESTiä käsittelevä</a> Youtube-video, missä Postmania käytetään hieman.</p>
                </aside>
		
                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-tulospalvelu">
                                    Tulospalvelu
                                </a>
                            </h1>
                        </header>
                        <div id="t-tulospalvelu" class="collapse">

                            <p>Tässä tehtävässä toteutetaan pelitulospalvelu, joka tarjoaa REST-rajapinnan pelien ja tuloksien käsittelyyn. <strong>Huom! Kaikki syötteet ja vasteet ovat JSON-muotoisia olioita.</strong> Tehtäväpohjassa on toteutettu valmiiksi luokat <code>Game</code> ja <code>Score</code> sekä käytännölliset <code>Repository</code>-rajapinnat.</p>

                            <h1>GameController</h1>

                            <p>Pelejä käsitellään luokan <code>Game</code> avulla.</p>

                            <p>Toteuta pakkaukseen <code>wad.controller</code> luokka <code>GameController</code>, joka tarjoaa REST-rajapinnan pelien käsittelyyn:</p>
                            <ul>
                                <li><code>POST /games</code> luo uuden pelin sille annetun pelin tiedoilla ja palauttaa luodun pelin tiedot. (Huom. vieläkin! Pyynnön <strong>rungossa</strong> oleva data on aina JSON-muotoista. Vastaukset tulee myös palauttaa JSON-muotoisina.)</li>
                                <li><code>GET /games</code> listaa kaikki talletetut pelit.</li>
                                <li><code>GET /games/{name}</code> palauttaa yksittäisen pelin tiedot <strong>pelin nimen perusteella</strong>.</li>
                                <li><code>DELETE /games/{name}</code> poistaa nimen mukaisen pelin. Palauttaa poistetun pelin tiedot.</li>
                            </ul>

                            <h1>ScoreController</h1>

                            <p>Jokaiselle pelille voidaan tallettaa pelikohtaisia tuloksia (luokka <code>Score</code>). Jokainen pistetulos kuuluu tietylle pelille, ja tulokseen liittyy aina pistetulos <code>points</code> numerona sekä pelaajan nimimerkki <code>nickname</code>.</p>

                            <p>Toteuta luokka <code>wad.controller.ScoreController</code>, joka tarjoaa REST-rajapinnan tuloksien käsittelyyn:</p>

                            <ul>
                                <li><code>POST /games/{name}/scores</code> luo uuden tuloksen pelille <code>name</code> ja asettaa tulokseen pelin tiedot. Tuloksen tiedot lähetetään kyselyn rungossa.</li>
                                <li><code>GET /games/{name}/scores</code> listaa pelin <code>name</code> tulokset.</li>
                                <li><code>GET /games/{name}/scores/{id}</code> palauttaa tunnuksella <code>id</code> löytyvän tuloksen <code>name</code>-nimiselle pelille.</li>
                                <li><code>DELETE /games/{name}/scores/{id}</code> poistaa avaimen <code>id</code> mukaisen tuloksen peliltä <code>name</code> (pelin tietoja ei tule pyynnön rungossa). Palauttaa poistetun tuloksen tiedot.</li>
                            </ul>

                        </div>
                    </div>
                </div>


                <h2>Valmiin palvelun käyttäminen</h2>

                <p>Palvelinohjelmistoista valmiiseen REST-rajapintaan pääsee kätevästi käsiksi <a href="http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html" target="blank">RestTemplate</a>-luokan avulla. Voimme luoda oman komponentin kirjojen hakemiseen.</p>
                
<pre class="sh_java">
// importit

@Service
public class BookService {

    private RestTemplate restTemplate;
    
    public BookService() {
        this.restTemplate = new RestTemplate();
    }

    // tänne luokan tarjoamat palvelut
}</pre>

                

                <ul>
                    <li>GET osoitteeseen <em>/books</em> palauttaa kaikkien kirjojen tiedot <em>tai</em> osajoukon kirjojen tiedoista -- riippuen toteutuksesta.</li>
                    <pre class="sh_java">
// kirjojen hakeminen
List&lt;Book&gt; books = restTemplate.getForObject("<em>osoite</em>/books", List.class);</pre>
                    <li>GET osoitteeseen <em>/books/{id}</em>, missä {id} on yksittäisen kirjan yksilöivä tunniste, palauttaa kyseisen kirjan tiedot.</li>
                    <pre class="sh_java">
// tunnuksella 5 määritellyn kirjan hakeminen
Book book = restTemplate.getForObject("<em>osoite</em>/books/{id}", Book.class, 5);</pre>
                    <li>PUT osoitteeseen <em>/books/{id}</em>, missä {id} on yksittäisen kirjan yksilöivä tunniste, muokkaa kyseisen kirjan tietoja tai lisää kirjan kyseiselle tunnukselle (toteutuksesta riippuen, lisäystä ei aina toteutettu). Kirjan tiedot lähetetään pyynnön rungossa.</li>

                    <pre class="sh_java">
// tunnuksella 5 määritellyn kirjan hakeminen
Book book = restTemplate.getForObject("<em>osoite</em>/books/{id}", Book.class, 5);
book.setName(book.getName() + " - DO NOT BUY!");

// kirjan tietojen muokkaaminen
restTemplate.put("<em>osoite</em>/books/{id}", book, 5);</pre>
                    <li>DELETE osoitteeseen <em>/books/{id}</em> poistaa kirjan tietyllä tunnuksella.</li>

                    <pre class="sh_java">
 // tunnuksella 32 määritellyn kirjan poistaminen
restTemplate.delete("<em>osoite</em>/books/{id}", 32);</pre>
                    <li>POST osoitteeseen <em>/books</em> luo uuden kirjan pyynnön rungossa lähetettävän datan pohjalta. Palvelun vastuulla on päättää kirjalle tunnus.</li>

                    <pre class="sh_java">
Book book = new Book();
book.setName("Harry Potter and the Goblet of Fire");

// uuden kirjan lisääminen
book = restTemplate.postForObject("<em>osoite</em>/books", book, Book.class);</pre>
                </ul>


                <p>Jos palvelua haluaa käyttää selainohjelmistosta, onnistuu se esimerkiksi <a href="http://jquery.com/" target="_blank">jQuery</a>-projektin avulla. Yksittäisen kirjan tietojen hakeminen ja nimen näyttäminen käyttäjälle onnistuu yksinkertaisimmillaan seuraavasti:</p>

                <pre class="sh_java">
$.get("<em>osoite</em>/books/5", function( data ) {
  alert( "Tunnuksella 5 löytyi kirja nimeltä: " + data.name );
});</pre>

                <p>Usein sivustot käyttävät useampaa palvelua samaan aikaan. Harjoitellaan seuraavaksi hieman tällaisen palvelun tekemistä. </p>

                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-gamerater">
                                    GameRater
                                </a>
                            </h1>
                        </header>
                        <div id="t-gamerater" class="collapse">

                            <p>Palvelu <em>GameRater</em> lisää aiempaan tulospalveluun mahdollisuuden arvostella yksittäisiä pelejä antamalla niille numeroarvosanan 0-5. Arvostelu tehdään kuitenkin erilliseen palveluun, emmekä siis laajenna edellistä palvelua suoraan.</p>

                            <p><em>GameRater</em>-palvelun tulee käyttää <em>Tulospalvelu</em>-palvelun REST-rajapintaa, jonka avulla se tarjoaa samanlaisen rajapinnan pelien ja tulosten käsittelyyn. Ainoastaan pelien arvostelut käsitellään ja talletetaan tässä palvelussa! Arvosteluihin käytettävä entiteetti <code>Rating</code> ja siihen liittyvät palveluluokat on valmiina tehtäväpohjassa.</p>

                            <p><strong>Huom!</strong> Joudut tutkimaan tehtäväpohjassa annettua koodia, jotta voit hyödyntää sitä. Joudut myös lukemaan tehtävän <em>Tulospalvelu</em> kuvausta tämän tehtävän toteutuksessa.</p>

                            <p><strong>Huom!</strong> Valmis <em>Tulospalvelu</em>-palvelu löytyy osoitteesta <code>http://wepa-scoreservice-heroku.herokuapp.com/games</code>, joten voit tehdä tämän tehtävän täysin riippumatta tulospalvelu-tehtävästä.</p>


                            <h1>GameRestClient ja GameController</h1>

                            <p>Tee luokka <code>wad.service.GameRestClient</code>, joka toteuttaa rajapinnan <code>GameService</code>. Luokan tulee käyttää <em>Tulospalvelu</em>-palvelua kaikissa rajapinnan määrittelemissä toiminnoissa. REST-rajapinnan käyttö onnistuu Springin <code>RestTemplate</code>-luokan avulla.</p>

                            <p><strong>Huom!</strong> <code>GameRestClient</code>-luokan <code>setUri</code>-metodi ottaa parametriksi yllä annetun URL-osoitteen valmiiseen <em>Tulospalvelu</em>-palveluun.</p>

                            <p>Luo luokka <code>wad.controller.GameController</code>, joka tarjoaa <strong>täsmälleen samanlaisen</strong> JSON/REST-rajapinnan kuin <em>Tulospalvelu</em>-palvelun <code>GameController</code>, mutta siten, että jokainen toiminto käyttää valmista <em>Tulospalvelu</em>-palvelua rajapinnan <code>GameService</code> kautta.</p>

                            <p><strong>Huom!</strong> Muista asettaa <code>GameService</code>-rajapinnan kautta URL-osoite valmiiseen <code>http://wepa-scoreservice-heroku.herokuapp.com/games</code>-osoitteeseen ohjelman käynnistyessä, esimerkiksi controller-luokan <code>@PostConstruct</code>-metodissa.</p>


                            <h1>RatingController</h1>

                            <p>Jokaiselle pelille voidaan tallettaa pelikohtaisia arvosteluja entiteetin <code>Rating</code> avulla. Arvosteluun liittyy numeroarvosana <code>rating</code> (0-5).</p>

                            <p>Arvostelut liittyvät peleihin, jotka on talletettu eri palveluun, joten entiteetin <code>Rating</code> viittaus peliin täytyy tallettaa suoraan avaimena. Koska peleihin viitataan REST-rajapinnassa pelin nimellä, talletetaan jokaiseen <code>Rating</code>-entiteettiin pelin nimi attribuuttiin <code>gameName</code>. Tämän attribuutin avulla voidaan siis löytää arvosteluja pelin nimen perusteella.</p>

                            <p>Toteuta luokka <code>wad.controller.RatingController</code>, joka tarjoaa REST-rajapinnan arvostelujen käsittelyyn:</p>

                            <ul>
                                <li><code>POST /games/{name}/ratings</code> luo uuden arvostelun pelille <code>name</code> - ainoa vastaanotettava attribuutti on <code>rating</code></li>
                                <li><code>GET /games/{name}/ratings</code> listaa talletetut arvostelut pelille <code>name</code></li>
                                <li><code>GET /games/{name}/ratings/{id}</code> palauttaa yksittäisen arvostelun tiedot pelin nimen <code>name</code> ja avaimen <code>id</code> perusteella</li>
                                <li><code>DELETE /games/{name}/ratings/{id}</code> poistaa avaimen <code>id</code> mukaisen arvostelun</li>
                            </ul>

                        </div>
                    </div>
                </div>
                
                

                <aside class="info">
		  <br/>
		  
                  <h1>Navigoitavuus</h1>
		  
                  <p>Tähän asti toteuttamiemme palveluiden tarjoamat rajapinnat eivät ole sisältäneet linkkejä, joiden avulla resurssien välillä navigointi olisi ollut helppoa tai mahdollista. Tutustumme kohta menetelmään, jonka avulla näiden palveluiden tekeminen helpottuu huomattavasti; toinenkin tekniikka on olemassa -- osoitteessa <a href="http://spring.io/guides/gs/rest-hateoas/" target="_blank">http://spring.io/guides/gs/rest-hateoas/</a> kuvataan eräs menetelmä navigoitavan REST-rajapinnan toteuttamiseen.</p>
                  
                </aside>
		
		
                <h2>REST-palvelun kypsyystasot</h2>

                <p>Martin Fowler käsittelee artikkelissaan <a href="http://martinfowler.com/articles/richardsonMaturityModel.html" target="_blank">Richardson Maturity Model</a> REST-rajapintojen kypsyyttä. Richardson Maturity Model (RMM) jaottelee REST-toteutuksen kolmeen tasoon, joista kukin tarkentaa toteutusta.</p>

                <p>Aloituspiste on tason 0 palvelut, joita ei pidetä REST-palveluina. Näissä palveluissa HTTP-protokollaa käytetään lähinnä väylänä viestien lähettämiseen ja vastaanottamiseen, ja HTTP-protokollan käyttötapaan ei juurikaan oteta kantaa. Esimerkki tason 0 palvelusta on yksittäinen kontrollerimetodi, joka päättelee toteutettavan toiminnallisuuden pyynnössä olevan sisällön perusteella.</p>

                <p>Tason 1 palvelut käsittelevät palveluita resursseina. Resurssit kuvataan palvelun osoitteena (esimerkiksi <code>/books</code>-resurssi sisältää kirjoja), ja resursseja voidaan hakea tunnisteiden perusteella (esim. <code>/books/nimi</code>). Edelliseen tasoon verrattuna käytössä on nyt konkreettisia resursseja; olio-ohjelmoijan kannalta näitä voidaan pitää myös olioina joilla on tila.</p>

                <p>Tasolla 2 resurssien käsittelyyn käytetään kuvaavia HTTP-pyyntötyyppejä. Esimerkiksi resurssin pyyntö tapahtuu GET-metodilla, ja resurssin tilan muokkaaminen esimerkiksi PUT, POST, tai DELETE-metodilla. Näiden lisäksi palvelun vastaukset kuvaavat tapahtuneita toimintoja. Esimerkiksi jos palvelu luo resurssin, vastauksen tulee olla statuskoodi <code>201</code>, joka viestittää selaimelle resurssin luomisen onnistumisesta. Oleellista tällä tasolla on pyyntötyyppien erottaminen sen perusteella että muokkaavatko ne palvelimen dataa vai ei (GET vs. muut).</p>

                <p>Kolmas taso sisältää tasot 1 ja 2, mutta lisää käyttäjälle mahdollisuuden ymmärtää palvelun tarjoama toiminnallisuus palvelimen vastausten perusteella. Webissä huomiota herättänyt termi <a href="https://weblogs.java.net/blog/mkarg/archive/2010/02/14/what-hateoas-actually-means" target="_blank">HATEOAS</a> käytännössä määrittelee miten web-resursseja tulisi löytää webistä.</p>


                <p>RESTin isä, Roy Fielding, pitää vain tason 3 sovellusta oikeana REST-sovelluksena. Ohjelmistosuunnittelun näkökulmasta jokainen taso parantaa sovelluksen ylläpidettävyyttä -- <em>Level 1 tackles the question of handling complexity by using divide and conquer, breaking a large service endpoint down into multiple resources; Level 2 introduces a standard set of verbs so that we handle similar situations in the same way, removing unnecessary variation; Level 3 introduces discoverability, providing a way of making a protocol more self-documenting.</em> (<a href="http://martinfowler.com/articles/richardsonMaturityModel.html" target="_blank">lähde</a>)</p>


                <p><em>Huom! Sovellusta suunniteltaessa ja toteuttaessa ei tule olettaa että RMM-tason 3 sovellus olisi parempi kuin RMM-tason 2 sovellus. Sovellus voi olla huono riippumatta toteutetusta REST-rajapinnan muodosta -- jossain tapauksissa rajapintaa ei oikeasti edes tarvita; asiakkaan tarpeet ja toiveet määräävät mitä sovelluskehittäjän kannattaa tehdä.</em></p>



                <h2>Spring Data Rest</h2>

                <p>Spring-sovelluskehys sisältää projektin <a href="http://projects.spring.io/spring-data-rest/" target="_blank">Spring Data REST</a>, minkä avulla REST-palveluiden tekeminen helpottuu hieman. Lisäämällä projektin <code>pom.xml</code>-konfiguraatioon riippuvuus <code>spring-boot-starter-data-rest</code> saamme Spring Boot-paketoidun version kyseisestä projektista käyttöömme.</p>

                <pre class="sh_xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>

                <p>Nyt Repository-luokkamme tarjoavat automaattisesti REST-rajapinnan, jonka kautta resursseihin pääsee käsiksi. REST-rajapinta luodaan oletuksena sovelluksen juureen, ja tehdään luomalla monikko domain-olioista. Esimerkiksi, jos käytössä on luokka <code>Book</code>, sekä sille määritelty <code>BookRepository</code>, joka perii Spring Data JPA:n rajapinnan, generoidaan rajapinnan <code>/books</code> alle toiminnallisuus kirja-olioiden muokkaamiseen.</p>

                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-esinevarasto">
                                    Esinevarasto
                                </a>
                            </h1>
                        </header>
                        <div id="t-esinevarasto" class="collapse">

                            <p>Luo rajapinta <code>ItemRepository</code>, joka tarjoaa <code>Item</code>-olioiden tietokantatallennustoiminnallisuuden. Lisää tämän jälkeen Spring Data REST-riippuvuus pom.xml-tiedostoon, ja tarkista REST-rajapintasi toiminta esimerkiksi Postman REST Clientin avulla. Wat is this magic?</p>

                        </div>
                    </div>
                </div


                <p>Usein käytännössä sovelluksemme kuitenkin toimivat jo palvelun juuripalvelussa, ja haluaisimme esimerkiksi tarjota rajapinnan erillisessä osoitteesssa. Spring Data REST-projektin konfiguraatiota voi muokata erillisen <code>RepositoryRestMvcConfiguration</code>-luokan kautta. Alla olevassa esimerkissä REST-rajapinta luodaan osoitteen <code>/api/v1</code>-alle. Annotaatio <code>@Configuration</code> kertoo Springille että luokka sisältää konfiguraatiota, ja perittävä luokka kertoo mistä konfiguraatiosta on kyse.</p>

                <pre class="sh_java">
// pakkaus

import java.net.URI;
import java.net.URISyntaxException;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.rest.core.config.RepositoryRestConfiguration;
import org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration;

@Configuration
public class RestConfig extends RepositoryRestMvcConfiguration {

    @Override
    protected void configureRepositoryRestConfiguration(RepositoryRestConfiguration config) {
        super.configureRepositoryRestConfiguration(config);
        try {
            config.setBaseUri(new URI("/api/v1"));
        } catch (URISyntaxException e) {
            throw new RuntimeException("Unable to bind REST API to address /api/v1");
        }
    }
}
                </pre>

                <p>Nyt jos sovelluksessa on entiteetti <code>Book</code> sekä siihen sopiva <code>BookRepository</code>, on Spring Data REST-rajapinta osoitteessa <code>/api/v1/books</code>.</p>

                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-viestiapi">
                                    ViestiApi
                                </a>
                            </h1>
                        </header>
                        <div id="t-viestiapi" class="collapse">

                            <p>Tehtävässä on käytössä viikon 2 tehtävistä tuttu viestien kirjoitus- ja lukemispalvelu. Muokkaa sovellusta siten, että sovellus tarjoaa REST-rajapinnan viestien käsittelyyn. GET-pyynnön osoitteeseen <code>/api/messages</code> tulee palauttaa lista viesteistä, POST-pyyntö osoitteeseen <code>/api/messages</code> luo uuden viestin, jne.</p>

                        </div>
                    </div>
                </div>


                <p>Käytännössä sovelluksen kehittäjä ei kuitenkaan tyypillisesti halua kaikkia HTTP-protokollan metodeja kaikkien käyttöön. Käytössä olevien metodien rajaaminen onnistuu käytettävää <code>Repository</code>-rajapintaa muokkaamalla. Alla olevassa esimerkissä <code>BookRepository</code>-rajapinnan olioita ei pysty poistamaan automaattisesti luodun REST-rajapinnan yli.</p>

                <pre class="sh_java">
// pakkaus
import wad.domain.Book;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.rest.core.annotation.RestResource;

public interface BookRepository extends JpaRepository&lt;Message, Long&gt; {

    @RestResource(exported = false)
    @Override
    public void delete(Long id);

}</pre>

                <h3>Spring Data REST ja RestTemplate</h3>

                <p>Spring Data RESTin avulla luotavien rajapintojen hyödyntäminen onnistuu RestTemplaten avulla. Esimerkiksi yllä luotavasta rajapinnasta voidaan hakea <code>Resource</code>-olioita, jotka sisältävät kirjoja. RestTemplaten metodin <code><a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html#exchange-java.lang.String-org.springframework.http.HttpMethod-org.springframework.http.HttpEntity-java.lang.Class-java.lang.Object...-" target="_blank">exchange</a></code> palauttaa vastausentiteetin, mikä sisältää hakemamme olion tiedot. Kyselyn mukana annettava <code>ParameterizedTypeReference</code> taas kertoo minkälaiseksi olioksi vastaus tulee muuntaa.</p>

                <pre class="sh_java">
RestTemplate restTemplate = new RestTemplate();
ResponseEntity&lt;Resource&lt;Book&gt;&gt; response = 
    restTemplate.exchange("<em>osoite</em>/books/1", // osoite
                          HttpMethod.GET, // metodi
                          null, // pyynnön runko; tässä tyhjä
                          new ParameterizedTypeReference&lt;Resource&lt;Book&gt;&gt;() {}); // vastaustyyppi

if (response.getStatusCode() == HttpStatus.OK) {
    Resource&lt;Book&gt; resource = response.getBody();
    Book book = resource.getContent();
}
                </pre>



                <aside class="extra">
                    <h1>HAL</h1>

                    <p>HAL on spesifikaatio siitä, miten rajapinnat tulee toteuttaa jotta ne ovat helposti löydettävissä. Spring Data RESTin avulla luodut rajapinnat toteuttavat HAL-spesifikaation -- tutustu spesifikaatioon tarkemmin osoitteessa <a href="http://stateless.co/hal_specification.html" target="_blank">http://stateless.co/hal_specification.html</a>.</p>

                </aside>


                <h1>HTTP-protokolla ja sessiot</h1>
		
                <p>HTTP on tilaton protokolla, eli se ei tarvitse jatkuvasti avoinna olevaa yhteyttä toimiakseen. Tämä tarkoittaa sitä, että HTTP ei osaa yhdistää samalta käyttäjältä tulevia pyyntöjä toisiinsa, jolloin jokainen tehty pyyntö käsitellään omana erillisenä pyyntönään. Käytännössä yhden web-sivuston hakeminen saattaa sisältää kymmeniä pyyntöjä, sillä jokaiseen sivuun liittyy joukko kuvia ja skriptitiedostoja, joista kukin on oma erillinen resurssinsa.</p>

                <p>Vaikka HTTP on tilaton protokolla, on asiakkaan tunnistamiseen käytetty pitkään erilaisia kiertotapoja. Klassinen -- mutta erittäin huono -- tapa kiertää HTTP:n tilattomuus on ollut säilyttää GET-muotoisessa osoitteessa parametreja, joiden perusteella asiakas voidaan identifioida palvelinsovelluksessa. Parametrien käyttö osoitteissa ei ole kuitenkaan ongelmatonta: osoitteessa olevia parametreja voi helposti muokata käsin, jolloin palvelinsovelluksesta saattaa löytyä tietoturva-aukkoja tai ei-toivottua käyttäytymistä.</p>

                <aside class="info">
		  <br/>
                  <h1>Case: GET-parametri tunnistautumiseen</h1>

                  <p>Eräässä järjestelmässä verkkokaupan toiminnallisuus oli toteutettu siten, että GET-parametrina säilytettiin numeerista ostoskorin identifioivaa tunnusta. Käyttäjäkohtaisuus oli toteutettu palvelinpuolella siten, että tietyllä GET-parametrilla näytettiin aina tietyn käyttäjän ostoskori. Uusien tuotteiden lisääminen ostoskoriin onnistui helposti, sillä pyynnöissä oli aina mukana ostoskorin tunnistava GET-parametri. Ostoskorit oli valitettavasti identifioitu juoksevalla numerosarjalla. Henkilöllä 1 oli ostoskori 1, henkilöllä 2 ostoskori 2 jne.. Koska käytännössä kuka tahansa pääsi katsomaan kenen tahansa ostoskoria vain osoitteessa olevaa numeroa vaihtamalla, olivat ostoskorien sisällöt välillä hyvin mielenkiintoisia.</p>
                </aside>
		
                 <p>HTTP-protokollan tilattomuus ei pakota palvelinohjelmistoja tilattomuuteen. Palvelimella tilaa pidetään yllä jollain tietyllä tekniikalla, joka taas ei näy HTTP-protokollaan asti. Yleisin tekniikka tilattomuuden kiertämiseen on evästeiden käyttö.</p>


                <h2>HTTP-protokollan tilattomuuden kiertäminen: evästeet</h2>

                <p>HTTP on tilaton protokolla, eli käyttäjän toimintaa ja tilaa ei pysty pitämään yllä puhtaasti HTTP-yhteyden avulla. Käytännössä suurin osa verkkosovelluksista kuitenkin sisältää käyttäjäkohtaista toiminnallisuutta, jonka toteuttamiseen sovelluksella täytyy olla jonkinlainen tieto käyttäjästä ja käyttäjän tilasta. HTTP/1.1 tarjoaa mahdollisuuden tilallisten verkkosovellusten toteuttamiseen evästeiden (<em>cookies</em>) avulla.</p>

                <p>Asettamalla käyttäjän tekemän pyynnön vastaukseen eväste, tulee käyttäjän jatkossa pyyntöä tehdessä aina palauttaa kyseinen eväste pyynnön otsaketietoina. Tämä tapahtuu automaattisesti selaimen toimesta. Evästeitä käytetään istuntojen (<em>session</em>) ylläpitämiseen: istuntojen avulla pidetään kirjaa käyttäjästä useampien pyyntöjen yli.</p>

                <p>Evästeet toteutetaan otsakkeiden avulla. Kun käyttäjä tekee pyynnön palvelimelle, ja palvelimella halutaan asettaa käyttäjälle eväste, palauttaa palvelun vastauksen mukana otsakkeen <code>Set-Cookie</code>, jossa määritellään käyttäjäkohtainen evästetunnus. Set-Cookie voi olla esimerkiksi seuraavan näköinen:</p>

                <pre>
Set-Cookie: SESS57a5819a77579dfb1a1466ccceee22a0=0hr0aa2ogdfgkelogg; Max-Age=3600; Domain=".helsinki.fi"
                </pre>

                <p>Ylläoleva palvelimelta lähetetty vastaus ilmoittaa pyytää selainta tallettamaan evästeen. Selaimen tulee jatkossa lisätä eväste <code>SESS57a5819a77579dfb1a1466ccceee22a0=0hr0aa2ogdfgkelogg</code> jokaiseen <code>helsinki.fi</code>-osoitteeseen. Eväste on voimassa tunnin, eli tunnin kuluttua sen voi poistaa. Tarkempi syntaksi evästeen asettamiselle on seuraava:</p>

                <pre>
Set-Cookie: nimi=arvo [; Comment=kommentti] [; Max-Age=elinaika sekunteina]
                      [; Expires=parasta ennen paiva] [; Path=polku tai polunosa jossa eväste voimassa]
                      [; Domain=palvelimen osoite (URL) tai osoitteen osa jossa eväste voimassa]
                      [; Secure (jos määritelty, eväste lähetetään vain salatun yhteyden kanssa)]
                      [; Version=evästeen versio]
                </pre>


                <p>Evästeet tallennetaan selaimen sisäiseen evästerekisteriin, josta niitä haetaan aina kun käyttäjä tekee kyselyn johonkin osoitteeseen. Evästeet lähetetään palvelimelle jokaisen viestin yhteydessä <code>Cookie</code>-otsakkeessa. </p>

                <pre>
Cookie: SESS57a5819a77579dfb1a1466ccceee22a0=0hr0aa2ogdfgkelogg
                </pre>

                <p>Evästeiden nimet ja arvot ovat yleensä monimutkaisia ja satunnaisesti luotuja niiden yksilöllisyyden takaamiseksi. Samaan osoitteeseen voi liittyä myös useampia evästeitä. Yleisesti ottaen evästeet ovat sekä hyödyllisiä että haitallisia: niiden avulla voidaan luoda yksiöityjä käyttökokemuksia tarjoavia sovelluksia, mutta niitä voidaan käyttää myös käyttäjien seurantaan ympäri verkkoa.</p>

                <aside class="info">
		  <br/>
                  <h1>Kekseliästä</h1>

                  <p>Painamalla F12 tai valitsemalla Tools -> Developer tools, pääset tutkimaan sivun lataamiseen ja sisältöön liittyvää statistiikkaa. Lisäneuvoja löytyy <a href="https://developers.google.com/chrome-developer-tools/docs/overview" target="_blank">Google Developers</a> -sivustolta.</p>

                  <p>Avaa developer tools, ja mene osoitteeseen <a href="http://www.hs.fi" target="_blank">http://www.hs.fi</a>. Valitsemalla developer toolsien välilehden <code>Resources</code>, löydät valikon erilaisista sivuun liittyvistä resursseista. Avaa <code>Cookies</code> ja valitse vaihtoehto <code>www.hs.fi</code>. Kuinka moni palvelu pitää sinusta kirjaa kun menet Helsingin sanomien sivuille?</p>

                </aside>

                <p>Springissä käyttäjäkohtaiseen <em>sessioon</em> pääsee käsiksi tarvittaessa. Jos käytettävään komponenttiin injektoidaan <code>HttpSession</code>-luokan ilmentymä, voidaan siihen lisätä tietoa joka on yllä käyttäjän session ajan. Session pituus riippuu esimerkiksi palvelimen asetuksista <code>session timeout</code> ja siitä, että salliiko käyttäjä evästeiden käytön. Yksinkertainen käyttäjäkohtainen laskuri, joka laskee pyyntöjen määrän sessiossa toteutettaisiin esimerkiksi seuraavasti.</p>

                <pre class="sh_java">
// ...
    @Autowired
    private HttpSession session;

    @RequestMapping(method = RequestMethod.GET)
    public String list(Model model) {
        Integer count = 1;
        if(session.getAttribute("count") != null) {
            count += (Integer) session.getAttribute("count");
        }
        
        session.setAttribute("count", count);
        
        model.addAttribute("count", count);
        return "counts";
    }

// ...</pre>


                <p>Session käyttö yllämainitulla tavalla on kuitenkin melko harvinaista, sillä sessiossa olevat tiedot katoavat kun käyttäjä poistaa sivun evästeet tai evästeen elinikä on kulunut loppuun.</p>

                <p>Evästeitä voi kuitenkin hyödyntää esimerkiksi väliaikaisten asioiden ja tietojen ylläpidossa. Voimme esimerkiksi luoda komponentteja, jotka ovat elossa vain session ajan. Tyypillinen esimerkki tästä on ostoskori:</p>

                <pre class="sh_java">
// importit 

@Component
@Scope(value = "session", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class ShoppingCart implements Serializable {

    private Map&lt;Item, Integer&gt; items;

    public ShoppingCart() {
        this.items = new TreeMap&lt;&gt;();
    }

    public Map&lt;Item, Integer&gt; getItems() {
        return items;
    }

    public void setItems(Map&lt;Item, Integer&gt; items) {
        this.items = items;
    }

    public boolean isEmpty() {
        return items == null || items.isEmpty();
    }
}</pre>

                <p>Ylläolevasta komponentista luotavat ilmentymät ovat elossa vain käyttäjän session ajan, eli sen aikaa kun käyttäjän eväste on elossa. Ylläolevasta ostoskorista saa lisättyä ilmentymän sovellukseen aivan kuten muistakin komponenteista, eli <code>@Autowired</code>-annotaatiolla.</p>

                <p></p>


                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-euroshopper">
                                    EuroShopper
                                </a>
                            </h1>
                        </header>
                        <div id="t-euroshopper" class="collapse">

                            <p>Tässä tehtävässä toteutetaan verkkokauppaan ostoskoritoiminnallisuus.</p>

                            <h1>Ostoskori</h1>

                            <p>Luo pakkaukseen <code>wad.domain</code> luokka <code>ShoppingCart</code>, joka tarjoaa seuraavat toiminnallisuudet.</p>

                            <ul>
                                <li> Metodi <code>getItems()</code> palauttaa <code>Map&lt;Item, Long&gt;</code>-tyyppisen olion, joka sisältää ostoskorissa olevien tuotteiden tuotekohtaisen lukumäärän.</li>
                                <li> Metodi <code>addToCart(Item item)</code> lisää ostoskoriin yhden kappaleen <code>Item</code>-tyyppistä esinettä.</li>
                                <li> Metodi <code>removeFromCart(Item item)</code> poistaa ostoskorista yhden kappaleen <code>Item</code>-tyyppistä esinettä. Jos lukumäärä laskee nollaan, <code>getItems()</code>-metodin ei tule sisältää enää kyseistä tuotetta.</li>
                            </ul>


                            <h1>Kontrolleri ostoskorille</h1>

                            <p>Tee ostoskorista sessiokohtainen, eli eri käyttäjien tulee saada eri ostoskori käyttöönsä. Annotaatiosta <code>Scope</code> on tässä hyötyä.</p>

                            <p>Luo projektiin sopiva kontrolleri, joka tarjoaa seuraavat osoitteet ja toiminnallisuudet.</p>

                            <ul>
                                <li>GET /cart asettaa model-olion "items"-nimiseen attribuuttiin ostoskorin sisällön (aiempi <code>getItems()</code>). Pyynnön vastauksena käyttäjälle näytetään sivu, joka luodaan polussa <code>/src/main/resources/templates/cart.html</code> olevasta näkymästä.</li>
                                <li>POST /cart/items/{id} lisää ostoskoriin yhden {id}-tunnuksella tietokannasta löytyvän Item-olion. Pyyntö ohjataan osoitteeseen <code>/cart</code>.</li>
                                <li>DELETE /cart/items/{id} poistaa ostoskorista yhden {id}-tunnuksella tietokannasta löytyvän Item-olion. Pyyntö ohjataan osoitteeseen <code>/cart</code>.</li>
                            </ul>

                            <h1>Tilauksen tekeminen</h1>

                            <p>Muokkaa luokkaa <code>wad.service.OrderService</code> siten, että tilaus tallennetaan tietokantaan. Tutustu luokkiin <code>Order</code>, <code>OrderItem</code> ja <code>UserDetails</code> ennen toteutusta. Varmista että esimerkiksi <code>OrderItem</code> viittaa oikeaan tietokantatauluun.</p>

                            <p>Kun tilaus on tehty, tyhjennä ostoskori.</p>

                        </div>
                    </div>
                </div>

            </section>
            <!-- END WEEK3 -->


            <!-- BEGIN WEEK4 -->
            <section class="weeklimit" data-week-id="4">
                <header>
                    <h1 id="viikko4">Viikko 4</h1>
                </header>

                <h1>Palvelukeskeiset arkkitehtuurit</h1>

                <aside class="extra">
                    <p><em>...Koska ohjelmistoista halutaan mahdollisimman nopeasti konkreettista palautetta, arkkitehti aloittaa ohjelmiston suunnittelun perustarpeista: muutamasta huoneesta, joihin palautetta antavat ihmiset muuttavat. Kun alkuperäinen suunnitelma on lähes valmis, rakennukseen muuttaa lisää ihmisiä, jotka tarvitsevat rakennukselta uusia toiminnallisuuksia. Ensisijaisina vaatimuksina ovat uudet huoneet, pesula, disko ja luonnollisesti oleskelutila, jossa on tilaa biljardipöydälle. Tällöin arkkitehti soveltaa alkuperäistä suunnitelmaansa mukauttamaan uudet ihmiset ja kehitystyö jatkuu. Kehitystyön jatkuessa alkuperäiset asukkaat alkavat valittamaan rakennusmelusta ja uhkaavat poismuutolla, jos asioihin ei saada muutosta, aiheuttaen hiusten harvenemista arkkitehdille. Toisaalta, sana uudesta biljardipöydästä kiertää, ja yhä enemmän ihmisiä muuttaa rakennukseen, ja rakennukselta vaaditaan taas uusia huoneita, mukaanlukien cartingrata ja curlinghalli.</em></p>
                </aside>

                <p>Kurssin alkupuolella ollut ohjelmistokehittäjän elämää parodioiva kuvaus kuvaa yksittäisen sovelluksen kehitystä. Sovellukseen lisättävät huoneet ovat uusia metodeja, luokkia ja kontrollereita sovelluksessa, aivan kuten pesula, disko ja muut oleelliset elintilat. Sovelluksen kasvaessa sen ylläpidettävyys ja testaus muuttuu haastavammaksi, sillä kaikki osa-alueet ovat leivottu samaan sovellukseen. Tutustutaan tässä kappaleessa toisenlaiseen ajattelutapaan; sovellusten koostamiseen palveluista.</p>


                <p>Monoliittiset "minä sisällän kaiken mahdollisen"-sovellukset ovat usein vaikeita ylläpitää, sillä uuden toiminnallisuuden lisääminen vaatii olemassaolevan sovelluksen muokkaamista sekä testaamista. Olemassaoleva sovellus voi olla kirjoitettu hyvin vähäisesssä käytössä olevalla kielellä (vrt. pankkijärjestelmät ja COBOL) ja esimerkiksi kehitystä tukevat automaattiset testit voivat puuttua siitä täysin.</p>

                <p>Yrityksen toiminta-alueiden laajentuessa sekä uusien sovellustarpeiden ilmentyessä aiemmin toteutettuihin toiminnallisuuksiin olisi hyvä päästä käsiksi, mutta siten, että toiminnallisuuden käyttäminen ei vaadi juurikaan olemassaolevan muokkausta. Kun pohdimme aiempaa rakennusesimerkkiä, lienee selvää, että esimerkiksi diskoon voisi päästää muitakin kuin rakennuksen asukkaita, kun taas yksittäiset huoneet kannattanee pitää vain muutaman henkilön käytössä.</p>

                <p>Koostamalla sovellus erillisistä palveluista saadaan luotua tilanne, missä palvelut ovat tarvittaessa myös uusien sovellusten käytössä. Palvelut tarjoavat rajapinnan (esim. REST) minkä kautta niitä voi käyttää. Samalla rajapinta kapseloi palvelun toiminnan, jolloin muiden palvelua käyttävien sovellusten ei tarvitse tietää sen toteutukseen liittyvistä yksityiskohdista. Oleellista on, että yksikään palvelu ei yritä tehdä kaikkea. Tämä johtaa myös siihen, että yksittäisen palvelun toteutuskieli ei vaikuta muiden komponenttien toimintaan -- oleellista on vain se, että palvelu tarjoaa rajapinnan jota voi käyttää ja joka löydetään.</p>

                <p>Yrityksen kasvaessa sen sisäiset toiminnat ja rakennettavat ohjelmistot sisältävät helposti päällekkäisyyksiä. Tällöin tilanne on käytännössä se, että aikaa käytetään samankaltaisten toimintojen ylläpitoon useammassa sovelluksessa -- pyörä keksitään yhä uudestaan ja uudestaan uudestaan uusia sovelluksia kehitettäessä.</p>


                <aside class="extra">

                    <h1>Amazon ja Palveluorientoituneet arkkitehtuurit</h1>

                    <p>Amazon on hyvä esimerkki yrityksestä, joka on menestynyt osittain sen takia, että se on toteuttanut tarjoamansa toiminnallisuudet palveluina. Siirtymä ei kuitenkaan ollut yksinkertainen, allaoleva viesti on katkelma Amazonin toimitusjohtajan, Jeff Bezosin, noin vuonna 2002 kirjoittamasta viestistä yritykselle (<a href="https://plus.google.com/+RipRowan/posts/eVeouesvaVX" target="_blank">lähde</a>).</p>

                    <pre>
1) All teams will henceforth expose their data and functionality 
   through service interfaces.

2) Teams must communicate with each other through these interfaces.

3) There will be no other form of interprocess communication allowed: 
   no direct linking, no direct reads of another team's data store, 
   no shared-memory model, no back-doors whatsoever. The only communication 
   allowed is via service interface calls over the network.

4) It doesn't matter what technology they use. HTTP, Corba, Pubsub, 
   custom protocols — doesn't matter.

5) All service interfaces, without exception, must be designed from the 
   ground up to be externalizable. That is to say, the team must plan 
   and design to be able to expose the interface to developers in the 
   outside world. No exceptions.

6) Anyone who doesn't do this will be fired.</pre>

                    <p>Oikeastaan, hyvin suuri syy sille, että Amazon tarjoaa nykyään erilaisia pilvipalveluita (kts. <a href="http://aws.amazon.com/" target="_blank">Amazon Web Services</a>) liittyy siihen kokemukseen, mitä yrityksen työntekijät sekä yritys on kerännyt kun yrityksen sisäistä toimintaa kehitettiin kohti palveluja tarjoavia ohjelmistotiimejä.</p>
                </aside>

                <p>SOA (<em><a href="http://en.wikipedia.org/wiki/Service-oriented_architecture" target="_blank">Service Oriented Architecture</a></em>), eli palvelukeskeinen arkkitehtuuri, on suunnittelutapa, jossa eri sovelluksen komponentit on suunniteltu toimimaan itsenäisinä avoimen rajapinnan tarjoavina palveluina. Pilkkomalla sovellukset erillisiin palveluihin pyritään luomaan tilanne, jossa palveluita voidaan käyttää myös tulevaisuudessa kehitettävien sovellusten toimesta.</p>

                <p>SOA-palveluita käyttävät esimerkiksi toiset palvelut tai selainohjelmistot. Selainohjelmistot voivat hakea palvelusta JSON-muotoista dataa Javascriptin avulla ilman tarvetta omalle palvelinkomponentille. SOA-arkkitehtuurin avulla voidaan helpottaa myös ikääntyvien sovellusten jatkokäyttöä: ikääntyvät sovellukset voidaan kapseloida rajapinnan taakse, jonka kautta sovelluksen käyttö onnistuu myös jatkossa.</p>


                <p><em>Huom! Kuten aiemminkin olemme todenneet, terveen järjen käyttäminen on tässäkin tärkeää. Huikean arkkitehtuurin ei tule olla yrityksen päätavoite, mutta se voi olla tapa päästä tavoitteeseen.</em></p>

                <aside class="extra">

                    <h1>Palveluiden löytäminen</h1>

                    <p>Palveluorientoituneiden arkkitehtuurien yleistyessä markkinoille on myös ilmestynyt ESB (<a href="http://en.wikipedia.org/wiki/Enterprise_service_bus" target="_blank">enterprise service bus</a>)-sovelluksia, joiden tehtävä on toimia viestinvälittäjänä palveluiden välillä. Viestinvälityspalveluiden käyttäminen johtaa siihen, että palvelut ovat paremmin eriytettynä toisistaan -- palvelua A käyttävä palvelu B tietää vain viestinvälittäjän sekä palvelun A tunnisteen. Palvelun A tunniste ja kuvaus voidaan saada viestinvälittäjältä, ja palvelu voi kuvata itsensä esimerkiksi RAML (<a href="http://raml.org/" target="_blank">RESTful API Modeling Language</a>)-kuvauksen tai <a href="https://helloreverb.com/developers/swagger" target="_blank">Swagger</a>in avulla.</p>

                    <p>Kantamme tällä kurssilla ESB-sovelluksiin on kuitenkin melko sama kuin Martin Fowlerilla ja Jim Webberillä; liika ylimääräinen toiminnallisuus voi vaikeuttaa palveluiden käyttöä ja kankeuttaa organisaatiota. Katso esitys <a href="http://www.infoq.com/presentations/soa-without-esb" target="_blank">Does My Bus Look Big in This?</a>.</p>

                </aside>

                <p>Toteutimme oikeastaan viime viikolla jo muutamia palveluita. Jatketaan nyt samalla teemalla.</p>

                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-huoneistot">
                                    Huoneistot
                                </a>
                            </h1>
                        </header>
                        <div id="t-huoneistot" class="collapse">

                            <p>Toteuta Spring Data RESTin avulla REST-rajapinta huoneistojen hallintaan.</p>

                            <p>Jokaisella huoneistolla tulee olla uniikki nimi (<code>name</code>), joka ei saa olla tyhjä. Huoneistojen lisäys tapahtuu tekemällä JSON-muotoinen POST-pyyntö osoitteeseen <code>/api/apartments</code> (esim. <code>{"name":"The Cupboard Under the Stairs"}</code>). Vastaavasti <code>GET</code>-pyyntö osoitteeseen <code>/api/apartments</code> palauttaa <code>HAL</code>-spesifikaatiota seuraavan JSON-vastauksen, missä huoneet on listattu.</p>

                            <p>yksittäisen huoneiston haku ja poisto tapahtuu osoitteessa <code>/api/apartments/{id}</code>, missä <code>id</code> on huoneiston uniikki tunnus.</p>

                            <p>Käytä huoneiston tunnuksena (<code>id</code>) <code>Long</code>-tyyppistä muuttujaa.</p>

                        </div>
                    </div>

                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-henkilot">
                                    Henkilöt
                                </a>
                            </h1>
                        </header>
                        <div id="t-henkilot" class="collapse">

                            <p>Toteutetaan sovellus henkilöiden luomiseen.</p>

                            <h1>Rajapinta</h1>

                            <p>Toteuta Spring Data RESTin avulla REST-rajapinta henkilöiden hallintaan.</p>

                            <p>Jokaisella henkilöllä tulee olla uniikki nimi (<code>name</code>), uniikki käyttäjätunnus (<code>username</code>) sekä salasana (<code>password</code>), joista yksikään ei saa olla tyhjä.</p>

                            <p>Henkilöiden lisäys tapahtuu tekemällä JSON-muotoinen POST-pyyntö osoitteeseen <code>/api/persons</code> (esim. <code>{"name":"Harry Potter", "username":"hedwig", "password":"nimbus2000"}</code>).</p>

                            <p>Vastaavasti <code>GET</code>-pyyntö osoitteeseen <code>/api/persons</code> palauttaa <code>HAL</code>-spesifikaatiota seuraavan JSON-vastauksen, missä henkilöt on listattu.</p>

                            <p>Yksittäinen henkilö voidaan hakea tunnuksen perusteella osoitteesta <code>/api/persons/{id}</code>, missä <code>id</code> on henkilön uniikki tunnus. Poistamisen ei kuitenkaan tule onnistua.</p>

                            <p>Käytä henkilön tunnuksena (<code>id</code>) <code>Long</code>-tyyppistä muuttujaa.</p>

                            <p><strong>Huom!</strong> Toteuta toiminnallisuus siten, että GET-pyynnön yhteydessä henkilön salasanaa ei palauteta. Vastauksen tulee siis sisältää aina vain nimi ja käyttäjätunnus. Etsi apua Googlesta, avainsanoja ovat ainakin <code>@JsonProperty</code>, <code>@JsonIgnore</code> sekä esimerkiksi haku "json ignore property on deserialization but allow on serialization".</p> 


                            <h1>Tunnistautuminen</h1>

                            <p>Lisää sovellukseen rajapinta <code>/authenticate</code>, jonka avulla voidaan tarkistaa löytyykö käyttäjärekisteristä sopiva käyttäjätunnus-salasana -pari. Rajapinnalle voidaan tehdä <code>POST</code>-tyyppinen pyyntö JSON-muodossa. JSON-data sisältää käyttäjätunnus-salasana -parin (<code>{"username":"tunnus","password":"jackbauer"}</code>). Jos tietokannasta löytyy käyttäjä annetulla käyttäjätunnuksella ja salasanalla, metodin tulee palauttaa statuskoodi <code>200</code> eli "OK", sekä käyttäjän nimi vastauksen rungossa. Jos käyttäjää ei löydy, palautettavan arvon tulee olla <code>401</code> eli "Unauthorized".</p>

                            <p>Toteuta vastaus siten että autentikointiin käytettävä kontrollerimetodi palauttaa <code><a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/http/ResponseEntity.html" target="_blank">ResponseEntity</a></code>-olion. ResponseEntitylle voi määritellä vastauksen statuskoodin sekä rungon. Alla oleva ResponseEntity-olion runko sisältää merkkijonon <code>"jack bauer"</code> ja palauttaa statuskoodin <code>200</code> eli "OK".</p>

                            <pre class="sh_java">
ResponseEntity&lt;String&gt; vastaus = new ResponseEntity&lt;&gt;("jack bauer", HttpStatus.OK);</pre>

                        </div>
                    </div>

                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-varauspalvelu">
                                    Varauspalvelu
                                </a>
                            </h1>
                        </header>
                        <div id="t-varauspalvelu" class="collapse">

                            <p>Jatkokehitetään sovellusta huoneistojen varaamiseen ja varaustilanteen tarkasteluun. Käytössäsi on huoneistojen käsittelyyn tarvittava rajapinta, jonka palveluntarjoaja on toteuttanut sinua varten. Rajapintaa käytetään <code>ApartmentService</code>-luokan avulla, joka löytyy pakkauksesta <code>wad.ext.apartments</code>.</p>

                            <p>Voit käyttää Huoneistot tehtävän vastausta osana tätä tehtävää:</p>

                            <ol>
                                <li>Paketoi tehtävä Huoneistot komennolla <code>mvn clean package</code></li>
                                <li>Käynnistä huoneistot-sovellus komennolla <code>java -Dserver.port=12345 -jar target/Huoneistot-1.0-SNAPSHOT.jar</code></li>
                                <li>Tämä käynnistää Huoneistot sovelluksen paikallisen koneesi porttiin 12345 -- sovellus siis osoitteessa <code>http://localhost:12345</code> ja sen tarjoamaa rajapintaa voi hyödyntää osoitteesta <code>http://localhost:12345/api</code>.</li>
                            </ol>

                            <h1>Rajapinnan rajoittaminen</h1>

                            <p>Tällä hetkellä sovelluksen tarjoama polussa <code>/api/reservations</code> oleva rajapinta mahdollistaa uusien varausten tekemisen sekä varausten poistamisen. Muokkaa rajapintaa siten, että sen kautta voi vain hakea tämänhetkisen varaustilanteen, mutta ei voi tehdä muutoksia siihen.</p>

                            <h1>Varaustilanteen näyttäminen</h1>

                            <p>Lisää sovellukseen kontrolleri, joka kuuntelee osoitteeseen <code>/reservations</code>-tehtäviä pyyntöjä. Kun osoitteeseen tehdään GET-tyyppinen pyyntö, tulee pyynnön modeliin lisätä sekä kaikki olemassaolevat varaukset että kaikki asunnot.</p>

                            <p>Lisää asunnot modeliin parametrin nimellä "apartments" -- huoneistoihin pääset käsiksi <code>ApartmentService</code>-toteutuksen avulla. Varausten tulee olla modelissa parametrilla "reservations". Näytä käyttäjälle polussa <code>/src/main/resources/templates/reservations.html</code> olevasta näkymästä luotu sivu.</p>

                            <p>Tämän lisäksi, kun osoitteeseen <code>/reservations</code> tehdään POST-pyyntö, missä on varauksen tiedot, varaus tulee tallentaa tietokantaan. POST-pyynnön mukana tulee muuttujat <code>reservationStart</code>, <code>reservationEnd</code> sekä <code>apartmentId</code> -- voit todennäköisesti hyödyntää luokkaa <code>Reservation</code> tässä. Kun otat pyynnön vastaan, lisää varaukseen varattavan huoneiston nimi -- voit hakea yksittäisen huoneiston tiedot huoneiston tunnuksen perusteella <code>ApartmentService</code>-palvelusta. Muistathan että POST-pyynnön jälkeen pyyntö tulee aina uudelleenohjata.</p>

                            <p>Huom! Lisää kontrollerille lisäksi <code>@PostConstruct</code>-annotaatiolla merkitty metodi, joka suoritetaan kun kontrolleri on ladattu. Aseta siinä <code>ApartmentService</code>-palvelulle osoite -- käytä aiempaa huoneistotehtävän vastausta testaukseen.</p>

                            <h1>Päällekkäisten varausten esto</h1>

                            <p>Muokkaa varaustoiminnallisuutta siten, että päällekkäisten varausten tekeminen ei onnistu. Samaa huoneistoa ei siis tule voida varata kahdesti samalle aikajaksolle tai osittain päällekkäiselle aikajaksolle.</p>


                            <h1>Maksutoiminnallisuus</h1>

                            <p>Jokaiseen varaukseen liittyy muuttuja <code>paymentStatus</code>, joka asetetaan varauksen luonnin yhteydessä <code>"UNPAID"</code>-tilaan, eli maksamattomaksi. Lisää sovellukseen toiminto, joka muuttaa varauksen maksutilaksi <code>"PAID"</code>. Tilan tulee muuttua jos osoitteeseen <code>/reservations/{id}/payment</code> tehdään POST-tyyppinen pyyntö -- tässä <code>id</code> on varauksen uniikki tunnus (<code>id</code>).</p>

                            <p>Nyt varausten maksu voitaisiin periaatteessa hoitaa erillisessä palvelussa, joka päivittäisi varauksen tilan maksun yhteydessä.</p>

                        </div>
                    </div>
                </div>


                <aside class="extra">

                    <h1>Lisää aiheesta</h1>

                    <p>Tutustu Microsoftin <a href="http://msdn.microsoft.com/en-us/library/bb833022.aspx" target="_blank">SOA-johdatukseen</a>.</p>

                </aside>


                <h1>Sovellusten testaaminen ja tuotantoon siirtäminen</h1>


                <p>Kun sovellus julkaistaan, seuraaviin asioihin kannattaa kiinnittää huomiota. </p>


                <ol>

                    <li>Palvelun (esimerkiksi käyttöliittymä, REST-API) tulee olla käyttäjien löydettävissä.</li>

                    <li>Palvelun rajapinnan (esimerkiksi käyttöliittymä, REST-API) käyttämiseen tulee olla tarjolla tukea tarvittaessa.</li>

                    <li>Palvelun tilaa tulee pystyä seuraamaan. Jos palvelu on päällä mutta siihen ei pääse käsiksi, se on turha. Palvelu on myös turha jos se on päällä, mutta joku sen sisältämä osakomponentti on rikki ja pyynnöt eivät suoritu toivotusti.</li>

                    <li>Kaikkien rajapintojen tulee olla testattu ja niiden kehityksen tulee tapahtua erillisenä tuotantopalvelusta, jolloin uusia toiminnallisuuksia voidaan testata erillään.</li>

                    <li>Palvelun tulee pystyä kestämään suuria määriä liikennettä sekä suojautumaan vihamielisiltä ohjelmistoilta ja käyttäjiltä.</li>

                </ol>

                <p>Tutustutaan tässä kappaleessa lähinnä neljänteen kohtaan.</p>


                <h2>Sovelluksen testaaminen</h2>


                <p>Kuten ohjelmistotuotannossa yleensä, myös palvelinohjelmistoja rakennettaessa testaaminen hyödyntää sekä ohjelmiston kehitystä että sen ylläpitoa. Testaaminen voidaan karkeasti jakaa kolmeen osaan: yksikkötestaukseen, integraatiotestaukseen ja järjestelmätestaukseen. Yksikkötestauksessa testataan sovellukseen kuuluvia pienimpiä yksittäisiä komponentteja ja varmistetaan että niiden tarjoamat rajapinnat toimivat tarkoitetulla tavalla. Integraatiotestauksessa testataan että komponentit toimivat yhdessä kuten niiden pitäisi, ja järjestelmätestauksessa varmistetaan, että järjestelmä toimii vaatimusten mukaan järjestelmän käyttäjille tarjotun rajapinnan (esim. selain tai REST-api) kautta.</p>


                <h3>Yksikkötestaus</h3>


                <p>Yksikkötestauksella tarkoitetaan lähdekoodiin kuuluvien yksittäisten osien testausta. Termi yksikkö viittaa ohjelman pienimpiin mahdollisiin testattaviin toiminnallisuuksiin, kuten olion tarjoamiin metodeihin. Seuratessamme <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle" target="_blank">single responsibility principle</a>ä, jokaisella oliolla ja metodilla on yksi selkeä vastuu, jota voi myös testata. Testaus tapahtuu yleensä testausohjelmistokehyksen avulla, jolloin luodut testit voidaan suorittaa automaattisesti. Yleisin Javalla käytettävä testauskehys on JUnit, jonka saa käyttöön lisäämällä siihen liittyvän riippuvuuden <code>pom.xml</code>-tiedostoon.</p>

                <pre class="sh_xml">
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;</pre>

                <p>Yksittäisen riippuvuuden määre <code>scope</code> kertoo milloin riippuvuutta tarvitaan. Määrittelemällä <code>scope</code>-elementin arvoksi <code>test</code> on riippuvuudet käytössä vain testejä ajettaessa. Uusia testiluokkia voi luoda NetBeansissa valitsemalla New -> Other -> JUnit -> JUnit Test. Tämän jälkeen NetBeans kysyy testiluokalle nimeä ja pakkausta. Huomaa että lähdekoodit ja testikoodit päätyvät erillisiin kansioihin -- juurin näin sen pitääkin olla. Kun testiluokka on luotu, on projektin rakenne kutakuinkin seuraavanlainen.</p>

                <pre>
.
|-- pom.xml
`-- src
    |-- main
    |   |-- java
    |   |   `-- wad
    |   |       `-- ... oman projektin koodit
    |   |-- resources
    |   |       `-- ... resurssit, mm. konfiguraatio ja thymeleafin templatet
    |   `-- webapp
    |           
    `-- test
        `-- java
            `-- wad
                `-- ... testikoodit!
                </pre>

                <p>Tehtäväpohjissa JUnit-testikirjasto on valmiina mukana. Yksikkötestauksesta JUnit-kirjaston avulla löytyy pieni opas kurssin <a href="https://github.com/mluukkai/OTM2013/wiki/Ohje-JUnit:in-k%C3%A4ytt%C3%B6%C3%B6n" target="_blank">Ohjelmistotekniikan menetelmät</a> sivuilta.</p>


                <h3>Integraatiotestaus</h3>

                <p>Spring tarjoaa <code>spring-test</code>-komponentin, jonka avulla JUnit-kirjasto saa @Autowired-annotaatiot toimimaan. Tämän kautta pääsemme tilanteeseen, missä voimme injektoida testimetodille esimerkiksi kokonaisen palvelun, sekä testata sen tarjoamien metodien toimintaa. Testattava palvelu voi hyödyntää muita komponentteja, jolloin testauksen kohteena on kokonaisuuden toiminta yhdessä.</p>

                <p>Spring test-komponentista on myös Spring Boot -projekti, jonka voimme ottaa käyttöömme lisäämällä seuraavan riippuvuuden pom.xml-tiedostoon. Käytetyn riippuvuuden versio liittyy Spring Boot -projektin versioon, eikä sitä tarvitse määritellä tarkemmin.</p>

                <pre class="sh_xml">
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;</pre>


                <p>Yksittäisten palvelujen testaamisessa tarvitsemme testiluokkien alkuun kaksi annotaatiota. Annotaatio <code>@RunWith(SpringJUnit4ClassRunner.class)</code> kertoo että käytämme Springiä yksikkötestien ajamiseen ja annotaatiolle <code>@SpringApplicationConfiguration</code> annetaan konfiguraation sijainti -- tässä <code>Application.class</code>, mikä tehtäväpohjissa on tyypillisestä pakkauksessa <code>wad</code>. Testiluokka, johon injektoidaan automaattisesti <code>MyService</code>-palvelu, näyttää seuraavalta.</p>


                <pre class="sh_java">
@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = Application.class)
public class ApplicationTest {

    @Autowired
    private MyService myService;

    // ... testit jne
}</pre>

                <p>Käynnistämällä Springin osana testejä, saamme käyttöömme oliokontekstin, jonka avulla voimme asettaa testattavat oliot testiluokkiin testaamista varten. Testattavien olioiden riippuvuudet asetetaan myös automaattisesti, eli jos <code>MyService</code> sisältää muita komponentteja, on ne myös automaattisesti asetettu.</p>

                <p>Voimme ylläolevalla lähestymistavalla testata myös sitä, että sovelluksemme eri osat toimivat yhteen toivotusti. Oletetaan, että käytössämme on luokka <code>PersonService</code>, joka tarjoaa metodin <code>save</code>, jonka pitäisi tallentaa parametrina annettava <code>Person</code>-olio tietokantaan. Tämän lisäksi käytössämme on <code>PersonRepository</code>, jolla on metodi <code>findByName</code>, minkä avulla voimme hakea tietokannasta henkilön sen nimen perusteella. Kummatkin toteutukset voidaan injektoida suoraan testiluokkaan, testi itsessään ensin tallentaa henkilön <code>PersonService</code>-olion avulla, ja tarkistaa sen jälkeen <code>PersonRepository</code>-oliolta että kyseinen henkilö on olemassa.</p>


                <pre class="sh_java">
// importit

@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = Application.class)
public class ApplicationTest {

    @Autowired
    private PersonService personService;

    @Autowired
    private PersonRepository personRepository;

    @Test
    public void testSavePerson() {
        Person person = new Person();
        person.setName("Jack Bauer");
        person.setAge(42);

        personService.save(person);

        Person retrieved = personService.findByName("Jack Bauer");
        assertNotNull(retrieved);
        assertEquals(42, retrieved.getAge());
    }

    // ja muita testejä
}</pre>

                <p>Ylläolevassa testissä olevat metodit <code>assertNotNull</code> ja <code>assertEquals</code> ovat JUnit-kirjaston tarjoamia toiminnallisuuksia.</p>


                <h3>Järjestelmätestaus</h3>

                <p>Järjestelmätestauksessa on tarkoitus varmistaa, että järjestelmä toimii toivotulla tavalla. Järjestelmää testataan saman rajapinnan kautta, kuin mitä sen loppukäyttäjät käyttävät. Järjestelmätestaukseen on monenlaisia työkaluja, joista käsittelemme tässä kahta. Tutustumme ensin integraatiotestauksessa käytetyn <code>spring-test</code>-komponenttiin järjestelmätason testaustoiminnallisuuteen, jonka jälkeen tutustumme harjoitustehtävän kautta <code>Selenium</code> ja <code>FluentLenium</code> -kirjastoihin.</p>

                <p>Springin tarjoama <code>spring-test</code> tarjoaa tuen järjestelmätestaamiseen. Lisäämällä testiluokkiin annotaatio <code>@WebAppConfiguration</code> testeillä on käytössä myös web-sovelluksen konteksti, jonka avulla voidaan luoda <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/test/web/servlet/MockMvc.html" target="_blank">MockMvc</a>-olio. MockMvc-oliolla pystymme tekemään pyyntöjä sovelluksen tarjoamiin osoitteisiin, tarkistelemaan pyyntöjen onnistumista, sekä tarkastelemaan vastauksena saatua dataa.</p>

                <p>Alla oleva esimerkki käynnistää sovelluksen ja tekee kolme GET-pyyntöä osoitteeseen <code>/messages</code>. Ensimmäinen pyyntö liittyy testiin, missä varmistetaan että vastaus on sisältää statuskoodin <code>200</code> eli "OK", toinen pyyntö liittyy testiin joka varmistaa että vastauksen tyyppi on JSON-muotoista dataa, ja kolmas pyyntö tarkistaa että vastauksessa on merkkijono "Awesome". Alun <code>setUp</code>-metodi luo <code>MockMvc</code>-olion injektoidun palveinkontekstin perusteella.</p>

                 <pre class="sh_java">
// muut importit

// mm. mockMvc:n get- ja post-metodit
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = Application.class)
@WebAppConfiguration
public class MessagesTest {

    private final String API_URI = "/messages";

    @Autowired
    private WebApplicationContext webAppContext;

    private MockMvc mockMvc;

    @Before
    public void setUp() {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(webAppContext).build();
    }

    @Test
    public void statusOk() throws Exception {
        mockMvc.perform(get(API_URI))
                .andExpect(status().isOk());
    }


    @Test
    public void responseTypeApplicationJson() throws Exception {
        mockMvc.perform(get(API_URI))
                .andExpect(status().isOk())
                .andExpect(content().contentType(MediaType.APPLICATION_JSON));
    }

    @Test
    public void responseContainsTextAwesome() throws Exception {
        MvcResult res = mockMvc.perform(get(API_URI))
                .andExpect(status().isOk())
                .andExpect(content().contentType(MediaType.APPLICATION_JSON))
                .andReturn();

        String content = res.getResponse().getContentAsString();
        Assert.assertTrue(content.contains("Awesome"));
    }
}</pre>

                <p>Voit myös testata modeliin asetettujen attribuuttien olemassaoloa ja oikeellisuutta. Olemassaolon voi tarkistaa <code>model()</code>-metodin kautta, ja <code>MvcResult</code>-olion kautta pääsee käsiksi modelin sisältöön.</p>

                <pre class="sh_java">
    @Test
    public void modelHasAttribute() throws Exception {
        mockMvc.perform(get(API_URI))
                .andExpect(status().isOk())
                .andExpect(model().attributeExists("messages"));
    }

    @Test
    public void modelHasAttribute() throws Exception {
        MvcResult res = mockMvc.perform(get(API_URI))
                .andExpect(status().isOk())
                .andExpect(model().attributeExists("messages"))
                .andReturn();

        // oletetaan, että kontrolleri asettaa listan Message-tyyppisiä olioita
        // modeliin

        List&lt;Message&gt; messages = (List) res.getModelAndView().getModel().get("messages");

        // tarkista lista
    }
                </pre>        


                <p>MockMvc:n avulla voi testata käytännössä suurinta osaa palvelinsovellusten toiminnallisuudesta, mutta samalla se tarjoaa pääsyn samaan rajapintaan kuin mitä selain käsitteelee.</p>



                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-lentokentatredux">
                                    Lentokentät Redux
                                </a>
                            </h1>
                        </header>
                        <div id="t-lentokentatredux" class="collapse">

                            <p>Muistamme viikolta 2 tehtävän, missä tehtiin sovellus lentokoneiden ja lentokenttien hallintaan. Tässä tehtävässä harjoitellaan hieman sekä integraatio- että järjestelmätestausta.</p>

			    <p>Huom! Tässä tehtävässä ei ole automaattisia testejä, joilla testattaisiin kirjoittamiasi testejä. Palauttaessasi tehtävän olet tarkistanut, että kirjoittamasi testit toimivat kuten tehtävänannossa on kuvattu.</p>

                            <h1>AirportServiceTest</h1>

                            <p>Sovellusessa on luokka <code>AirportService</code>, mikä sijaitsee pakkauksessa <code>wad.service</code>. Sille ei kuitenkaan ole yhtäkään testiä :(</p>

                            <p>Lisää testikansioon (<code>Test Packages</code>) pakkaus <code>wad.service</code>, ja luo sinne luokka <code>AirportServiceTest</code>.</p>

                            <p>Lisää luokalle tarvittavat annotaatiot sekä oliomuuttujat, ja toteuta luokalle testimetodit, joiden avulla testataan että haluttu lentokone todellakin lisätään lentokentälle. Haluat ainakin tietää että:</p>

                            <ul>
                                <li>Kun lentokone on lisätty lentokentälle, tietokannasta samalla tunnuksella haettavalla lentokoneella on asetettu lentokenttä, ja se on juuri se lentokenttä mihin kone on lisätty.</li>
                                <li>Kun lentokone on lisätty lentokentälle, lentokentältä löytyy myös kyseinen kone.</li>
                                <li>Kun lentokone on lisätty yhdelle lentokentälle, se ei ole muilla lentokentillä.</li>
                                <li>Lentokoneen lisääminen samalle lentokentälle useasti ei johda siihen, että lentokenttä sisältää saman koneen monta kertaa.</li>
                            </ul>

                            <p>Aina kun lisäät yksittäisen testin, voit ajaa testit klikkaamalla projektia oikealla hiirennapilla ja valitsemalla "Test".</p>                        


                            <h1>AircraftControllerTest</h1>

                            <p>Luo testikansioon pakkaus <code>wad.controller</code> ja lisää sinne luokka <code>AircraftControllerTest</code>. Lisää luokkaan tarvittavat määrittelyt, jotta voit käyttää <code>MockMvc</code>-komponenttia testeissä.</p>

                            <p>Tee seuraavat testit:</p>

                            <ul>
                                <li>Kun osoitteeseen <code>/aircrafts</code> tehdään GET-pyyntö, vastauksen status on 200 (ok) ja vastauksen model-oliossa on parametrit <code>aircrafts</code> ja <code>airports</code>.</li>
                                <li>Kun osoitteeseen <code>/aircrafts</code> tehdään POST-pyyntö, jonka parametriksi annetaan <code>name</code>-kenttä, jonka arvona on "HA-LOL", pyynnön vastaukseksi tulee uudelleenohjaus. Tee tämän jälkeen erillinen kysely tietokantaan esim. <code>AircraftRepository</code>:n avulla, ja varmista, että tietokannasta löytyy lentokone, jonka nimi on <code>HA-LOL</code>.</li>
                                <li>Kun osoitteeseen <code>/aircrafts</code> tehdään POST-pyyntö, jonka parametriksi annetaan <code>name</code>-kenttä, jonka arvona on "XP-55", pyynnön vastaukseksi tulee uudelleenohjaus. Tee tämän jälkeen GET-pyyntö osoitteeseen <code>/aircrafts</code>, ja tarkista että pyynnön vastauksena saatavan <code>model</code>-olion sisältämässä <code>"aircrafts"</code>-listassa on juuri luotu lentokone.</li>
                            </ul>

                            <p>Tässäkin tehtävässä, aina kun lisäät yksittäisen testin, voit ajaa testit klikkaamalla projektia oikealla hiirennapilla ja valitsemalla "Test".</p>                        
                        </div>
                    </div>
                </div>


                <p>Riippuen käytetystä käyttöliittymäkirjastosta, käyttöliittymä saatetaan luoda Spring-sovelluskehyksen ulkopuolella. Esimerkiksi <a href="https://en.wikipedia.org/wiki/JavaServer_Pages" target="_blank">JSP</a>-sivut luodaan käytetyllä palvelimella (esim Tomcat tai Jetty), eli ne ovat erillinen osa Spring-sovelluksesta.</p>


                <p>MockMvc:n lisäksi järjestelmätestaukseen käytetään melko paljon <a href="http://www.seleniumhq.org/" target="_blank">Selenium</a>ia ja siihen liittyviä lisäosia kuten <a href="https://github.com/FluentLenium/FluentLenium" target="_blank">FluentLenium</a>, jotka tarjoavat välineitä selaintoiminnallisuuden automatisointiin. Käytännössä edellämainitut ovat on web-selaimen toimintojen automatisointiin tarkoitettuja välineitä, jotka antavat sovelluskehittäjälle mahdollisuuden käydä läpi sovelluksen käyttöliittymää ohjelmallisesti.</p>

		<p>Lisätään FluentLenium-kirjaston vaatimat riippuvuudet, oletetaan että testit kirjoitetaan JUnit-testikirjaston avulla (FluentLenium tarjoaa myös muita vaihtoehtoja).</p>

                <pre class="sh_xml">
        &lt;dependency&gt;
            &lt;groupId&gt;org.fluentlenium&lt;/groupId&gt;
            &lt;artifactId&gt;fluentlenium-core&lt;/artifactId&gt;
            &lt;version&gt;0.10.3&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;xml-apis&lt;/groupId&gt;
            &lt;artifactId&gt;xml-apis&lt;/artifactId&gt;
            &lt;version&gt;1.4.01&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;</pre>


		<p><strong><em>FluentLenium testien kirjoittaminen</em></strong></p>


                <p>Ajatellaan loppukäyttäjän haluamaa toiminnallisuutta "Käyttäjä voi ilmoittautua oppitunnille". Järjestelmä tarjoaa sivun, jonka ensimmäinen linkki vie ilmoittautumissivulle. Ilmoittautumissivulla tulee olla tietty otsikko -- varmistamme, että olemme oikealla sivulla. Tämän lisäksi ilmoiuttautumissivulla on lomakekenttä, jonka <em>id</em> on "name" -- jos kentällä on <em>id</em>, voidaan se valita kirjoittamalla "#kentannimi". Täytetään kenttään arvo "Bob" ja lähetetään lomake. Tämän jälkeen sivulla tulee olla teksti "Ilmoittautuminen onnistui!".</p>


                <pre class="sh_java">
// importit

@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = Application.class)
@WebAppConfiguration
@IntegrationTest("server.port:0")
public class ElokuvatietokantaTest extends FluentTest {

    @Value("${local.server.port}")
    private int serverPort;
    private WebDriver webDriver = new HtmlUnitDriver();

    private String getUrl() {
        return "http://localhost:" + serverPort;
    }

    @Override
    public WebDriver getDefaultDriver() {
        return webDriver;
    }

    @Test
    public void canSignUp() {
        goTo(getUrl());

        click(find("a").first());
        assertEquals("Ilmoittautuminen", title());

        fill(find("#name")).with("Bob");
        submit(find("form").first());

        assertTrue(pageSource().contains("Ilmoittautuminen onnistui!"));
    }
// ...
                </pre>


                <p>Yllä annotaatio <code>@IntegrationTest("server.port:0")</code> käynnistää palvelimen integraatiotestausta satunnaisessa portissa, joka saadaan muuttujaan <code>serverPort</code> annotaation <code>@Value("${local.server.port}")</code> avulla. Luomma tämän lisäksi ajurin näkymien läpikäyntiin (rivi <code>private WebDriver webDriver = new HtmlUnitDriver();</code>, joka tarjotaan oman testiluokkamme peritylle toiminnallisuudelle (<code>FluentTest</code>) metodin <code>getDefaultDriver()</code> kautta.</p>

		<p>Yllä menemme ensin paikalliseen osoitteeseen <code>http://localhost:<em>portti</em></code>, missä portin numero on satunnaisesti valittu -- surffaamme siis haluttuun osoitteeseen. Haemme tämän jälkeen ensimmäisen linkin, eli <code>a</code>-elementin sivulta, ja klikkaamme sitä. Tämän jälkeen tarkistamme, että sivun otsake on <code>Ilmoittautuminen</code>. Tätä seuraa kentän, jonka id on "name" täyttäminen "Bob"-merkkijonolla, jonka jälkeen lomake lähetetään. Kun lomake on lähetetty, haetaan sivun lähdekoodista tekstiä "Ilmoittautuminen onnistui!". Jos tekstiä ei löydy, testi epäonnistuu.</p>

		<p>FluentLenium-kirjastoon liittyvää dokumentaatiota löytyy osoitteesta <a href="http://www.fluentlenium.org/" target="_blank">http://www.fluentlenium.org/</a>, jonka lisäksi googlesta löytyy apua seuraavaan tehtävään.</p>

                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-elokuvatredux">
                                    Elokuvat Redux
                                </a>
                            </h1>
                        </header>
                        <div id="t-elokuvatredux" class="collapse">

                            <p>Muistamme viikolta 2 myös tehtävän, missä tehtiin sovellus elokuvien ja näyttelijöiden hallintaan. Tässä tehtävässä harjoitellaan hieman järjestelmätestausta FluentLeniumin avulla. Tehtävässä ei ole automaattisia testejä, sillä sinun tehtävänä on toteuttaa ne.</p>

                            <h1>Näyttelijän lisääminen ja poistaminen</h1>

                            <p>Luo testikansioon <code>wad.selenium</code> testiluokka <code>ActorTest</code>, johon asetat Selenium-testaamiseen tarvittavat komponentit.</p>

                            <p>Toteuta testi, jolla varmistetaan että käyttäjän lisääminen ja poistaminen onnistuu. Testin tulee toimia seuraavasti:</p>

                            <ol>
                                <li>Menee näyttelijäsivulle</li>
                                <li>Tarkistaa ettei sivulla ole tekstiä "Van Damme"</li>
                                <li>Etsii kentän jonka id on "name", asettaa kenttään tekstin "Van Damme", ja lähettää lomakkeeseen liittyvän lomakkeen.</li>
                                <li>Tarkistaa että sivulla on teksti "Van Damme"</li>
                                <li>Klikkaa "Van Damme"en liittyvää poista-nappia </li>
                                <li>Tarkistaa että sivulla ei ole tekstiä "Van Damme"</li>
                            </ol>

                            <p>Toteuta seuraavaksi testi, joka tekee seuraavat askeleet:</p>

                            <ol>
                                <li>Menee näyttelijäsivulle</li>
                                <li>Tarkistaa ettei sivulla ole tekstiä "Van Damme"</li>
                                <li>Tarkistaa ettei sivulla ole tekstiä "Chuck Norris"</li>
                                <li>Etsii kentän jonka id on "name", asettaa kenttään tekstin "Chuck Norris", ja lähettää lomakkeeseen liittyvän lomakkeen.</li>
                                <li>Tarkistaa ettei sivulla ole tekstiä "Van Damme"</li>
                                <li>Tarkistaa että sivulla on teksti "Chuck Norris"</li>
                                <li>Etsii kentän jonka id on "name", asettaa kenttään tekstin "Van Damme", ja lähettää lomakkeeseen liittyvän lomakkeen.</li>
                                <li>Tarkistaa että sivulla on teksti "Van Damme"</li>
                                <li>Tarkistaa että sivulla on teksti "Chuck Norris"</li>
                                <li>Klikkaa "Van Damme"en liittyvää poista-nappia</li>
                                <li>Klikkaa henkilön "Chuck Norris" poista-nappia</li>
                                <li>Tarkistaa ettei sivulla ole tekstiä "Van Damme"</li>
                                <li>Tarkistaa että sivulla on teksti "Chuck Norris"</li>
                            </ol>


                            <h1>Elokuvan lisääminen ja näyttelijän lisääminen elokuvaan</h1>

                            <p>Luo testikansioon <code>wad.selenium</code> testiluokka <code>MovieTest</code>, johon asetat Selenium-testaamiseen tarvittavat komponentit.</p>

                            <p>Toteuta seuraavat askeleet</p>

                            <ol>
                                <li>Mene elokuvasivulle</li>
                                <li>Tarkista että sivulla ei ole tekstiä "Bloodsport"</li>
                                <li>Tarkista että sivulla ei ole tekstiä "Van Damme"</li>
                                <li>Etsi kenttä jonka id on "name" ja lisää siihen arvo "Bloodsport"</li>
                                <li>Etsi kenttä jonka id on "lengthInMinutes" ja lisää siihen arvo "92"</li>
                                <li>Lähetä kenttään liittyvä lomake</li>

                                <li>Tarkista että sivulla on teksti "Bloodsport"</li>
                                <li>Tarkista että sivulla ei ole tekstiä "Van Damme"</li>

                                <li>Mene näyttelijäsivulle</li>
                                <li>Tarkista ettei sivulla ole tekstiä "Van Damme"</li>
                                <li>Etsi kenttä jonka id on "name", aseta kenttään teksti "Van Damme", ja lähetä lomake.</li>
                                <li>Tarkistaa että sivulla on teksti "Van Damme"</li>
                                <li>Etsi linkki, jossa on teksti "Van Damme" ja klikkaa siitä.</li>
                                <li>Etsi nappi, jonka id on "add-to-movie", ja klikkaa sitä.</li>

                                <li>Mene elokuvasivulle</li>

                                <li>Tarkista että sivulla on teksti "Bloodsport"</li>
                                <li>Tarkista että sivulla on teksti "Van Damme"</li>
                            </ol>

                            <p>Suorita taas testit klikkaamalla projektia oikealla hiirennäppäimellä ja valitsemalla <code>Test</code>.</p>
                        </div>
                    </div>
                </div>


                <h2>Kehitys, Integraatio, QA, Tuotanto</h2>


                <p>Kun sovelluksia kehitetään suuremmassa ryhmässä, sovellus sijaitsee useammassa paikassa.</p>

                <ol>
                    <li>Jokaisella ohjelmistokehittäjällä on oma <em>hiekkalaatikko</em>, jossa ohjelmistoon voi tehdä muutoksia vaikuttamatta muiden tekemään työhön. Jokaisella ohjelmistokehittäjällä on yleensä samat tai samankaltaiset työkalut (ohjelmointiympäristö, ...), mikä helpottaa muiden kehittäjien auttamista. Tyypillisesti ohjelmistokehittäjien päivittäiset tehtävät on jaettu pieniksi erillisiksi kokonaisuuksiksi ryhmän toimesta. Kun yksittäinen tehtävä on valmis, tehtävään liittyvä koodi sekä testit lisätään versionhallintapalvelimelle.</li>
                    <li><em>Versionhallintapalvelin</em> sisältää mahdollisesti useampia versioita projektista. Esimerkiksi git-mahdollistaa ns. branchien käyttämisen, jolloin uusia ominaisuuksia voidaan toteuttaa erillään "päähaarasta". Kun uusi ominaisuus on valmis, voidaan se lisätä päähaaraan. Versionhallinnassa olevia koodeja voidaan myös tägätä julkaisuversioiksi.</li>
                    <li>Versionhallintapalvelin on tyypillisesti kytketty <em>integraatiopalvelimeen</em>, jonka tehtävänä on yhdistää ohjelmistokehitystiimin lähdekoodit ja suorittaa niihin liittyvät testit jokaisen muutoksen yhteydessä. Integraatiopalvelin kuuntelee käytännössä versionhallintajärjestelmässä tapahtuvia muutoksia, ja hakee uusimman lähdekoodiversion muutoksen yhteydessä.</li>
                    <li><em>Staging</em>-palvelin on lähes identtinen ympäristö tuotantoympäristöön verrattuna. Staging (usein myös QA)-ympäristöön kopioidaan ajoittain tuotantoympäristön data, ja se toimii viimeisenä testaus- ja validointipaikkana (Quality assurance) ennen tuotantoon siirtoa. QA-ympäristöä käytetään myös demo- ja harjoitteluympäristönä. Kun QA-ympäristössä oleva sovellus on päätetty toimivaksi, siirretään sovellus tuotantoympäristöön.</li>
                    <li><em>Tuotantoympäristö</em> voi olla yksittäinen palvelin, tai se saattaa olla joukko palvelimia, joihin uusin muutos propagoidaan hiljalleen. Tuotantoympäristö on tyypillisesti erillään muista ympäristöistä mahdollisten virheiden minimoimiseksi.</li>
                </ol>

                <p>Riippuen ohjelmistotalosta ja käytetystä julkaisumallista, on mahdollista esimerkiksi että erillistä <code>Staging</code>-palvelinta ei ole käytössä.</p>


                <h3>Integraatiopalvelin ja Continuous Integration</h3>



                <p>Jatkuvassa integroinnissa (<em><a href="http://www.extremeprogramming.org/rules/integrateoften.html" target="_blank">Continuous integration</a></em>) jokainen ohjelmistoprojektin jäsen lisää päivittäiset muutoksensa olemassaolevaan kokonaisuuteen.</p>

                <p>Jatkuvaa integrointia seuraten ohjelmistokehittäjä hakee kehityksen alla olevan version versionhallinnasta aloittaessaan työn. Hän toteuttaa uuden pienen ominaisuuden testeineen, testaten uutta toiminnallisuutta jatkuvasti. Kun ohjelmistokehittäjä on saanut muutoksen tehtyä, ja kaikki testit menevät läpi hänen paikallisella työasemalla, hän lähettää muutokset versionhallintaan. Kun versionhallintaan tulee muutos, jatkuvaa integrointia suorittava työkalu hakee uusimman version ja suorittaa sille sekä yksikkö- että integraatiotestit.</p>

                <p>Testejä sekä paikallisella kehityskoneella että erillisellä integraatiokoneella ajettaessa ohjelmistotiimi mahdollisesti huomaa virheet, jotka ovat piilossa kehittäjän paikallisen konfiguraation johdosta. Kehittäjä ei aina ota koko ohjelmistoa omalle koneelleen -- ohjelmisto voi koostua useista komponenteista --  jolloin kaikkien vaikutusten testaaminen paikallisesti on mahdotonta. Jos testit eivät mene läpi integraatiokoneella, korjataan muutokset mahdollisimman nopeasti.</p>

                <p>Työkaluja automaattiseen kääntämiseen ja jatkuvaan integrointiin ovat esimerkiksi <a href="https://travis-ci.org" target="_blank">Travis</a> ja <a href="https://coveralls.io" target="_blank">Coveralls</a>. Travis varmistaa että viimeisin lähdekoodiversio kääntyy ja että testit menevät läpi, ja Coveralls tarjoaa välineitä testikattavuuden ja projektin historian tarkasteluun -- tässä hyödyksi on esimerkiksi <a href="https://github.com/cobertura/cobertura" target="_blank">Cobertura</a>. Kummatkin ovat ilmaisia käyttää kun projektin lähdekoodi on avointa -- kumpikin tarjoaa myös suoran Github-tuen.</p>

                <p>Travisin käyttöönottoon vaaditaan käytännössä se, että projekti on esimerkiksi Githubissa ja että sen juurikansiossa on travisin konfiguraatiotiedosto <code>travis.yml</code>. Yksinkertaisimmillaan konfiguraatiotiedosto sisältää vain käytetyn ohjelmointikielen -- travis osaa esimerkiksi päätellä projektin tyypin <code>pom.xml</code>-tiedoston pohjalta.</p>

                <p>Näitä kumpaakin käytetään esimerkiksi <a href="https://github.com/kesapojat/tmc-snapshot-api" target="_blank">TMC Snapshot API</a>ssa, joka helpottaa ohjelmointiprosessin tutkimista.</p>


                <h2>Konfiguraatioprofiilit</h2>



                <p>Hyvin rakennetussa sovelluksessa ympäristön vaihtaminen ei vaadi muutoksia sovelluksen lähdekoodiin, vaan sovellusten ympäristöstä toiseen siirtäminen tapahtuu erilaisten profiilien avulla. Projekteissamme mukana olleet <code>wad.profiles</code>-pakkauksessa olleet luokat <code>DevProfile</code> ja <code>ProdProfile</code> sisältävät erilliset konfiguraatiot; ensimmäinen on kehityskäyttöön tarkoitettu ja hyödyntää vahvasti Spring Bootin oletusasetuksia, kun taas toinen ottaa käyttöön tietokannaksi PostgreSQL-kannan sovellukselle annettujen parametrien pohjalta. Esimerkiksi kun sovellus siirretään herokuun, se käyttää tuotantoprofiilia <code>"prod"</code>. Profiilin nimi määritellään profiilitiedoston alussa olevalla <code>@Profile</code>-annotaatiolla.</p>

                <p>Profiilikohtaisten asetusten muuttaminen onnistuu sekä lähdekoodista profiilitiedostoa (esim. <code>ProdProfile</code>) muokkaamalla, että esimerkiksi <code>application.properties</code>-tiedostoa muokkaamalla. Jos sovelluskehittäjä haluaa, että testiprofiililla (esim "test") on erillinen konfiguraatiotiedosto, sellaisen voi luoda. Spring etsii automaattisesti oletuskonfiguraation <code>application.properties</code> lisäksi myös profiilikohtaisia konfiguraatiotiedostoja (esim. <code>application-test.properties</code>, missä <code>test</code> on profiilin nimi.</p>

                <p>Konfiguraatiotiedostoihin voidaan asettaa myös ohjelmiston suorituksessa tarvittavaa tietoa. Esimerkiksi jos käyttäjä haluaa että sovelluksessa on erityistä tietoa, voidaan se määritellä muuttujaksi konfiguraatiotiedostoon. Alla olevassa esimerkissä konfiguraatiotiedostossa on muuttuja <code>wad.environment</code>, jolle on asetettu arvoksi <code>PRODUCTION</code>.</p>

                <pre>
wad.environment=PRODUCTION</pre>

                <p>Nyt kun sovellus käynnistetään siten, että ylläoleva konfiguraatio ladataan, on sovelluksessa käytössä konfiguraatioparametri, jonka voi injektoida suoraan sovellukseen <code>@Value</code>-annotaation avulla.</p>

                <pre class="sh_java">
// ..
@Controller
public class DefaultController {

    @Value("${wad.environment}")
    private String location;
// ...
                </pre>

                <p>Käytännössä profiilien hallinta kannattaa toteuttaa esimerkiksi niin, että eri ympäristöissä on käytössä erillinen ympäristömuuttuja, joka kertoo käytettävän profiilin. Springiä käytettäessä ympäristömuuttuja on <code>SPRING_PROFILES_ACTIVE</code> tai <code>spring.profiles.active</code>.</p>

                <p>Ympäristömuuttujan asetus tapahtuu *nix-koneilla <code>export</code>-komennolla.</p>

                <pre>
export SPRING_PROFILES_ACTIVE=production
                </pre>

                <p>Kun Springille on asetettu profiili, voidaan testiluokille määritellä myös käytettävä profiili annotaation <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/test/context/ActiveProfiles.html" target="_blank">ActiveProfiles</a> avulla. Alla olevassa esimerkissä testiluokan testit suoritetaan siten, että käytössä on profiiliin "dev" liittyvä konfiguraatio, eli se konfiguraatio, joka on määritelty annotaatiolla <code>@Profile("dev")</code> (tai <code>@Profile(values = {"dev", "muita"})</code> jos halutaan että samaa konfiguraatiota käytetään useammassa profiilissa.</p>

                <pre class="sh_java">
@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = Application.class)
@WebAppConfiguration
@ActiveProfiles("dev")
public class ApplicationTest {
    // ...
                </pre>



            </section>
            <!-- END WEEK4 -->



            <!-- BEGIN WEEK5 -->
            <section class="weeklimit" data-week-id="5">
                <header>
                    <h2 id="viikko5">Viikko 5</h2>
                </header>

                <h1>Luonnolliset näkymätemplatet</h1>

                <p>Luonnollisten näkymätemplatejen tavoitteena on mahdollistaa tilanne, missä kehitettävät näkymät näyttävät halutuilta ilman erillistä palvelimella tapahtumaa renderöintiä. Tutustutaan tässä kappaleessa tarkemmin jo pidempään käyttämäämme <a href="http://www.thymeleaf.org/" target="_blank">Thymeleaf</a>-projektiin.</p>


                <p>Thymeleaf on rakenteellisen tekstin renderöintiin tarkoitettu komponentti, minkä avulla näkymien todellisen muodon voi nähdä myös ilman palvelimen käynnistämistä. Henkilöiden listaus näyttäisi Thymeleafilla toteutettuna esimerkiksi seuraavalta:</p>

                <pre class="sh_xml">
&lt;p&gt;And the talks are given by:&lt;/p&gt;
&lt;ol&gt;
    &lt;li th:each="person : ${persons}" th:text="${person.name}"&gt;jack bauer&lt;/li&gt;
&lt;/ol&gt;</pre>

                <p>Selaimessa sivu näyttää esimerkiksi seuraavalta:</p>

                <div class="naytto">
                    <p>And the talks are given by:</p>
                    <ol>
                        <li th:each="person : ${persons}" th:text="${person.name}">jack bauer</li>
                    </ol>
                </div>

                <p>Ylläoleva esimerkki hakee käytännössä modelista attribuutin <code>persons</code> ja käy siihen liittyvän listan läpi. Jokaisen listan elementin kohdalla luodaan uusi elementti, jonka tekstiksi asetetaan listaelementtiin liittyvän muuttujan <code>name</code>-arvo. Sivua voi muokata myös siten, että siellä on visualisointitarkoituksessa lisäsisältöä.</p>

                <pre class="sh_xml">
&lt;p&gt;And the talks are given by:&lt;/p&gt;
&lt;ol&gt;
    &lt;li th:each="person : ${persons}" th:text="${person.name}"&gt;jack bauer&lt;/li&gt;
    &lt;!--/*--&gt;
    &lt;li&gt;nauris&lt;/li&gt;
    &lt;li&gt;elefantti&lt;/li&gt;
    &lt;!--*/--&gt;
&lt;/ol&gt;
                </pre>

                <p>Vaikka sivun kehitysvaiheessa lista näkyy kehittäjälle (ja esimerkiksi asiakkaalle jolle sivua demotaan), poistaa Thymeleaf elementtien <code>&lt;!--/*--&gt;</code> ja <code>&lt;!--*/--&gt;</code> välissä olevan sisällön kun sivu renderöidään palvelimella.</p>

                <div class="naytto">
                    <p>And the talks are given by:</p>
                    <ol>
                        <li th:each="person : ${persons}" th:text="${person.name}">jack bauer</li>
                        <!--/*-->
                        <li>nauris</li>
                        <li>elefantti</li>
                        <!--*/-->
                    </ol>
                </div>

                <h2>Thymealeafin käyttöönotto</h2>

                <p>Thymeleafin käyttöönotto vaatii riippuvuuden lisäämisen <code>pom.xml</code>-tiedostoon. Seuraava riippuvuus hakee Thymeleafin projektin käyttöön.</p>

                <pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;
                </pre>

                <p>Tämän lisäksi, HTML-sivuilla tulee määritellä <code>th</code>-nimiavaruus.</p>

                <pre class="sh_xml">
&lt;!DOCTYPE html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt;
    &lt;head lang="en"&gt;
        &lt;meta charset="UTF-8" /&gt;
        &lt;title&gt;Messages&lt;/title&gt;
    &lt;/head&gt;
    ...
                </pre>        


                <p>Thymeleaf etsii näkymiä oletuksena kansiosta <code>src/main/resources/templates</code>. Näkymätiedostojen pääte on <code>.html</code>; sitä ei tarvitse erikseen kertoa kontrollerissa. Jos palautamme kontrollerista esimerkiksi merkkijonon <code>messages</code>, etsii Thymeleaf näkymätemplaten <code>/src/main/resources/templates/messages.html</code> ja renderöi sen sisällön.</p>

                <pre class="sh_java">
@RequestMapping(method = RequestMethod.GET)
public String view() {
    return "messages";
}</pre>        


                <h2>Sivujen rakentaminen osista</h2>


                <p>Usein web-sivustot toimivat niin, että niissä on muuttumatonta sisältöä. Tämän muuttumattoman sisällön asettaminen jokaiselle näkymälle erikseen on huonoa ohjelmointityyliä, sillä se johtaa tilanteeseen, missä sama koodi on useammassa paikassa, ja sen ylläpidettävyys heikkenee. Thymeleaf tarjoaa muutaman tavan näkymien paloista koostamiseen.</p>

                <p>Näkymäpalasten määrittely tapahtuu komennolla <code>th:fragment</code>. Erilliset näkymäpalaset, joista sivu koostetaan, pidetään tyypillisesti <code>templates</code>-kansion alla olevassa erillisessä <code>fragments</code>-kansiossa. Oletetaan, että allaolevan sivun nimi on <code>header.html</code>, ja että se sijaitsee <code>fragments</code>-kansiossa. Sivu sisältää käytettävät otsaketiedot <code>header</code>-alueen sisällä.</p>

                <pre class="sh_xml">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;header template&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div th:fragment="header"&gt;
            &lt;ul&gt;
                &lt;li&gt;&lt;a href="#" th:href="@{/index}"&gt;Etusivu&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href="#" th:href="@{/sports}"&gt;Urheilu&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre>

                <p>Ylläolevan sivun <code>&lt;div th:fragment="header"&gt;</code>-elementin sisältämän koodin saa käyttöön komennolla <code>th:replace</code>.</p>

                <pre class="sh_xml">
&lt;!DOCTYPE html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt;
    &lt;head lang="en"&gt;
        &lt;meta charset="UTF-8" /&gt;
        &lt;title&gt;Uutisvuoto!&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div th:replace="fragments/header :: header"&gt;
            otsake.
        &lt;/div&gt;
        
        &lt;p&gt;sivun sisältöä..&lt;/p&gt;
        ...
                </pre>


                <p>Kun sivu renderöidään, aiheuttaa komento <code>th:replace="fragments/header :: header"</code> toiminnon, missä alueelle haetaan kansiosta <code>fragments</code> löytyvän tiedoston <code>header.html</code> sisältämä <code>header</code>-alue. Yksittäinen tiedosto voi luonnollisesti sisältää myös useampia palasia, joista sivun voi koostaa.</p>



                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-puutarhasuunnittelu">
                                    Puutarhasuunnittelu
                                </a>
                            </h1>
                        </header>
                        <div id="t-puutarhasuunnittelu" class="collapse">
                
			  <p>Tutustutaan hieman Thymeleafin toiminnallisuuksiin luomalla pieni sovellus puutarhan istutusten suunnitteluun. Tehtäväpohjassa on valmiina tarvittavat entiteetit sekä repositoryluokat. Pohjassa on valmiina myös template-tiedosto kasvisten luomiselle (<code>/src/main/resources/templates/vegetables.html</code>) sekä valmis otsaketiedosto (<code>/src/main/resources/templates/fragments/header.html</code>).</p>

                          <h1>Vihannesten listaus</h1>

                          <p>Tässä tehtävässä luodaan kontrolleri vihannesten lisäämiselle. Tutustu tehtäväpohjassa olevaan tiedostoon <code>/src/main/resources/templates/vegetables.html</code>. Sivu lienee muuten tutuhko, mutta katsotaan hieman <code>form</code>-elementtiä.</p>

                          <pre class="sh_xml">
&lt;form method="POST" th:action="@{/vegetables}"&gt;
    &lt;input type="text" name="name"/&gt;&lt;p th:if="${#fields.hasErrors('vegetable.name')}" th:errors="*{vegetable.name}"&gt;here be errors&lt;/p&gt;
    &lt;input type="submit" value="Add"/&gt;
&lt;/form&gt;</pre>

                          <p>Thymeleaf asettaa osoitteen <code>/vegetables</code> lomakkeen lähetysosoitteeksi komennolla <code>th:action="@{/vegetables}"</code>. Tämän lisäksi, sivu etsii modelissa olevan olion <code>vegetable</code> kenttään <code>name</code> liittyviä virheitä ja näyttää ne jos niitä on: <code>&lt;p th:if="${#fields.hasErrors('vegetable.name')}" th:errors="*{vegetable.name}"&gt;here be errors&lt;/p&gt;</code> -- komento toimii melko samalla tavalla kuin aiemmin näkemämme Spring-form -elementin errors-toiminnallisuus.</p>


                          <p>Toteuta vihannesten lisäämistä varten kontrolleri sekä metodi, joka kuuntelee GET-tyyppisiä pyyntöjä osoitteeseen <code>/vegetables</code>. Lisää pyynnön modeliin kolme attribuuttia: (1) attribuutin "message" arvoksi tulee merkkijono "Vegetables!", (2) attribuutin "vegetables" arvoksi tulee tietokannasta haettava lista Vegetable-olioita, (3) attribuutin "vegetable" arvoksi tulee uusi Vegetable-olio. Voit luoda attribuutin "vegetable" myös erillisellä metodilla, missä on <code>@ModelAttribute("vegetable")</code>-annotaatio.</p>


                          <p>Osoitteeseen <code>/vegetables</code> tehtäviä GET-pyyntöjä kuuntelevan metodin tulee palautaa merkkijono <code>"vegetables"</code>, jonka perusteella Spring etsii sopivan näkymätemplaten kansiosta <code>/src/main/resources/templates</code>.</p>


                          <h1>Vihannesten lisääminen</h1>


                          <p>Toteuta edellisessä tehtävässä tekemääsi kontrolleriin metodi, joka kuuntelee <code>/vegetables</code>-osoitteeseen tehtäviä <code>POST</code>-tyyppisiä pyyntöjä. Pyynnössä on sivulla olevat lomakkeen tiedot; ota parametrit kiinni <code>@ModelAttribute</code>-annotaation avulla <code>Vegetable</code>-olioon. Validoi myös olio samalla, ja pyydä Springiä asettamaan mahdolliset validointivirheet erilliseen <code>BindingResult</code>-olioon.</p>

                          <p>Jos <code>BindingResult</code>-olioon tulee validointivirheitä (<code>hasErrors</code>-metodi), palauta käyttäjälle vegetables-sivu -- tällöin myös validointivirheet näkyvät käyttäjälle suoraan.</p>

                          <p>Jos validointivirheitä ei ole, tallenna uusi vihannes tietokantaan ja uudelleenohjaa pyyntö osoitteeseen <code>/vegetables</code>.</p>

                          <p>Tässä vaiheessa <code>/vegetables</code>-osoitteessa olevan sivun pitäisi listata kaikki kasvikset ja sinne pitäisi voida lisätä uusia kasviksia.</p>


                          <h1>Puutarhojen listaus ja lisääminen</h1>

                          <p>Luo kansioon <code>/src/main/resources/templates</code> tiedosto <code>gardens.html</code> ja kopioi sinne tiedoston <code>vegetables.html</code> sisältö. Muokkaa sivun <code>gardens.html</code>-sisältöä siten, että vihanneksiin viittaavat tekstit muutetaan viittaamaan puutarhoihin. Poista gardens.html -sivulta <code>${message}</code>-attribuutin käyttö, ja muokkaa puutarhojen listausta siten, että puutarhat listataan seuraavalla tavalla avulla.</p>

                            <pre class="sh_xml">
&lt;h2&gt;Gardens&lt;/h2&gt;

&lt;div th:each="garden : ${gardens}"&gt;
    &lt;h3 th:text="${garden.name}"&gt;garden name&lt;/h3&gt;
            
&lt;/div&gt;
                            </pre>

                            <p>Sivun tulee toimia siten, että jos käyttäjä tekee GET-tyyppisen pyynnön <code>/gardens</code>-osoitteeseen, näytetään käyttäjälle lista olemassaolevista puutarhoista sekä annetaan käyttäjälle mahdollisuus uusien puutarhojen luomiseen.</p>


                            <p>Puutarhojen luomiseen käytettävä lomake lähettää POST-tyyppisen pyynnön osoitteeseen <code>/gardens</code>; pyyntö tulee luonnollisesti validoida ja jos pyyntö on virheellinen, tulee virheviesti näyttää käyttäjälle. Jos validointivirheitä ei ole, luodaan uusi puutarha ja tallennetaan se tietokantaan; tämän jälkeen pyyntö uudelleenohjataan <code>/gardens</code>-osoitteeseen.</p>



                            <h1>Puutarhan suunnittelu</h1>


                            <p>Puutarhan suunnitteluun kuuluu mahdollisuus kasvisten lisäämiseen puutarhalle. Muuta <code>gardens.html</code>-tiedoston sisältöä siten, että se sisältää mahdollisuuden kasvisten lisäämiseen puutarhoille. Käytä allaolevaa koodia osana näkymää.</p>

                            <pre class="sh_xml">
...
&lt;h2&gt;Gardens&lt;/h2&gt;

&lt;div th:each="garden : ${gardens}"&gt;
    &lt;h3 th:text="${garden.name}"&gt;garden name&lt;/h3&gt;

    &lt;div th:if="${not #lists.isEmpty(garden.vegetables)}"&gt;
        &lt;h4&gt;Current vegetables&lt;/h4&gt;
        &lt;ol&gt;
            &lt;li th:each="vegetable : ${garden.vegetables}" th:text="${vegetable.name}"&gt;veggie&lt;/li&gt;
        &lt;/ol&gt;
    &lt;/div&gt;
    
    &lt;div th:if="${not #lists.isEmpty(vegetables)}"&gt;
        &lt;h5&gt;plant a vegetable&lt;/h5&gt;
        
        &lt;form method="POST" th:action="@{/gardens/{id}/vegetables(id=${garden.id})}" action="/gardens/1/vegetables"&gt;
        
            &lt;select name="vegetableId"&gt;
                &lt;option th:each="vegetable : ${vegetables}" 
                    th:value="${vegetable.id}" 
                    th:text="${vegetable.name}"&gt;veg name to add&lt;/option&gt;
            &lt;/select&gt;
            
            &lt;input type="submit" value="Add"/&gt;
        &lt;/form&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;h2&gt;Add new garden&lt;/h2&gt;
...</pre>                        

                            <p>Yllä oleva koodi mahdollistaa puutarhaan liittyvien kasvisten listauksen sekä kasvisten lisäämisen puutarhaan. Muutamat komennot ovat mielenkiintoisia:</p>

                            <ul>
                                <li>Komento <code>&lt;div th:if="${not #lists.isEmpty(<em>listan nimi</em>)}"&gt;</code> tarkistaa onko annetulla listalla elementtejä. Jos lista ei ole tyhjä, elementin sisältö huomioidaan.</li>

                                <li>Komento <code>th:action="@{/gardens/{id}/vegetables(id=${garden.id})}"</code> lisää osoitteeseen arvoja suluissa annetun määrittelyn perusteella. Tässä esimerkiksi puutarhan tunnus <code>{id}</code> haetaan muuttujasta <code>${garden.id}</code>.</li>

                                <li>Näiden lisäksi <code>option</code>-elementissä käytetään toistokomentoa elementtien luomiseksi <code>select</code>-listalle; elementit luodaan annetusta listasta.</li>
                            </ul>

                            <p>Lisää osoitteeseen <code>/gardens</code> tehtävään GET-pyynnön vastaukseen attribuutti <code>vegetables</code>, mikä sisältää kaikki tietokannasta haetut kasvikset.</p>

                            <p>Lisää tämän jälkeen sovellukseen kontrollerimetodi, joka kuuntelee osoitteeseen <code>/gardens/{id}/vegetables</code> tehtäviä POST-pyyntöjä. Pyynnön polussa on puutarhan tietokantatunnus ja pyynnön parametrina tulee kasviksen tunnus <code>vegetableId</code>. Kun osoitteeseen tehdään POST-pyyntö, tulee puutarhalle lisätä haluttu kasvis.</p>

                        </div>
                    </div>
                </div>


                <h3>Käytetyn näkymän palauttaminen kontrollerimetodista</h3>

                <p>Template-tiedostot voi suunnitella myös siten, että näkymäpohjana käytetään aina samaa tiedostoa, ja kontrollerimetodi palauttaa käytettävän palasen nimen. Sivurunko voi tällöin olla seuraavanlainen:</p>


                <pre class="sh_xml">
&lt;!DOCTYPE html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt;
    &lt;head lang="en"&gt;
        &lt;meta charset="UTF-8" /&gt;
        &lt;title&gt;Uutisvuoto!&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div th:replace="fragments/header :: header"&gt;
            otsake.
        &lt;/div&gt;
        
        &lt;div th:replace="${view} :: content"&gt;
            runko.
        &lt;/div&gt;
        ...
                </pre>

                <p>Nyt kun kontrollerissa modeliin lisätään attribuutti <code>view</code>, päätellään sen arvosta tiedosto, josta <code>content</code>-pala haetaan. Sama ajatus hieman toisella tavalla toteutettuna löytyy osoitteessa <a href="http://blog.codeleak.pl/2013/11/thymeleaf-template-layouts-in-spring.html" target="_blank">http://blog.codeleak.pl/2013/11/thymeleaf-template-layouts-in-spring.html</a> olevasta blogipostista.</p>



                <h1>Mediatyypit ja tiedostojen käsittely</h1>


                <p>Pyyntöjä lähetettäessä ja vastaanottaessa palvelin vastaanottaa ja kertoo pyynnön tyypin otsakkeella <code>Content-Type</code>. Tätä tietoa lähetettävän tai vastaanotettavan datan muodosta kutsutaan <a href="http://en.wikipedia.org/wiki/Internet_media_type" target="_blank">mediatyypiksi</a>, millä dataa käsittelevä ohjelmisto voi päättää mitä datalla tehdään. Mediatyyppi sisältää yleensä kaksi osaa; mediatyypin sekä tarkenteen (esim <code>application/json</code>). Kattava lista eri mediatyypeistä löytyy IANA-organisaation ylläpitämästä <a href="http://www.iana.org/assignments/media-types/media-types.xhtml" target="_blank">mediatyyppilistasta</a>.</p>

                <p>Tyypillisiä mediatyyppejä ovat erilaiset kuvat <code>image/*</code>, videot <code>video/*</code>, äänet <code>audio/*</code> sekä erilaiset tekstimuodot kuten JSON <code>application/json</code>.</p>

                <p>Web-palvelut voivat tarjota käytännössä mitä tahansa näistä tiedostotyypeistä käyttäjälle; käyttäjän sovellusohjelmisto päättelee vastauksessa tulevan mediatyypin mukaan osaako se käsitellä tiedoston. Yksinkertaisimmillaan Springillä mediatiedoston lähetys palvelimelta toimii seuraavasti. Oletetaan, että käytössämme on levypalvelin polussa <code>/media/data/</code> oleva PNG-kuvatiedosto <code>architecture.png</code>.</p>

                <pre class="sh_java">
@RequestMapping(method = RequestMethod.GET, produces = "image/png")
public void copyImage(OutputStream out) throws IOException {
    Files.copy(Paths.get("/media/data/architecture.png"), out);
}</pre>

                <p>Yllä olevassa esimerkissä kerromme että metodi tuottaa <code>image/png</code>-tyyppistä. Spring asettaa kontrollerin metodin parametriksi automaattisesti <code>OutputStream</code>-olion, johon pyynnön vastaus voidaan kirjoittaa. <code>Files</code>-luokan tarjoama <code>copy</code>-metodi kopioi kuvan suoraan tiedostosta pyynnön vastaukseksi.</p>

                <p>Ylläolevan kontrollerimetodin palauttaman kuvan voi näyttää osana sivua <code>img</code>-elementin avulla. Jos metodi kuuntelee osoitetta <code>/media/imageimage.png</code>, HTML-elementti <code>&lt;img src="/media/image.png" /&gt;</code> hakee kuvan automaattisesti osoitteesta sivun latautuessa.</p>

                <p>Huom! Jos kuvat ovat staattisia eikä niitä esimerkiksi lisäillä tai poisteta, tulee niiden olla esimerkiksi projektin kansiossa <code>/src/main/webapp/img</code> -- niille <strong>ei</strong> tule määritellä kontrollerimetodia. Kansion <code>webapp</code>-alla oleviin tiedostoihin pääsee käsiksi web-selaimella ilman tarvetta kontrollerille (poikkeuksena WEB-INF -kansio, jonka palvelin piilottaa).</p>


                <h2>Tiedostojen tallentaminen ja lataaminen</h2>


                <p>Web-sivuilta voi lähettää tiedostoja palvelimelle. Alla oleva lomake HTML-koodi luo lomakkeen, joka voi sisältää myös binääridataa (kts. <a href="http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.2" target="_blank">multipart/form-data</a>).</p>

                <pre class="sh_xml">
&lt;form method="POST" action="/files" enctype="multipart/form-data"&gt;
    &lt;input type="file" name="file" /&gt;
    &lt;input type="submit" value="Send!"/&gt;
&lt;/form&gt;</pre>

                <p>Lomake lähettää tiedot palvelimelle, jonka tulee käsitellä pyyntö. Pyynnön käsittely tapahtuu aivan kuten minkä tahansa muunkin pyynnön, mutta tässä tapauksessa pyynnön parametrin tyyppi on <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/multipart/MultipartFile.html" target="_blank">MultipartFile</a>, joka sisältää lähetettävän tiedoston tiedot.</p>

                <p>Alla oleva kontrollerimetodi vastaanottaa pyynnön, ja tulostaa pyynnössä lähetetyn tiedoston koon ja tyypin. Se ei kuitenkaan tee vielä muuta.</p>

                <pre class="sh_java">
@RequestMapping(method = RequestMethod.POST)
public String save(@RequestParam("file") MultipartFile file) {
    System.out.println(file.getSize());
    System.out.println(file.getContentType());

    return "redirect:/files";
}</pre>

                <p>MultipartFile-olio sisältää myös tavutaulukon, missä pyynnössä lähetetty data sijaitsee.</p>

                <p>Tavutaulukon -- eli tässä tapauksessa datan -- tallennus tietokantaan onnistuu. Seuraava entiteetti <code>FileObject</code> sisältää tavutaulukon siten, että sen voi tallentaa tietokantaan.</p>

                <pre class="sh_java">
import javax.persistence.Entity;
import javax.persistence.Lob;
import org.springframework.data.jpa.domain.AbstractPersistable;

@Entity
public class FileObject extends AbstractPersistable&lt;Long&gt; {

    @Lob
    private byte[] content;

    // getterit ja setterit
}</pre>        

                <p>Annotaatiolla <a href="http://docs.oracle.com/javaee/6/api/javax/persistence/Lob.html" target="_blank">@Lob</a> kerrotaan että annotoitu muuttuja tulee tallentaa tietokantaan isona dataobjektina. Tietokantamoottorit tallentavat nämä tyypillisesti erilliseen isommille tiedostoille tarkoitettuun sijaintiin, jolloin kannan tehokkuus ei kärsi erikokoisten kenttien takia.</p>

                <p>Kun entiteetille tekee repositoryn, voi sen ottaa käyttöön myös kontrollerissa. Tietokantaan tallentaminen tapahtuu tällöin seuraavasti:</p>

                <pre class="sh_java">
@RequestMapping(method = RequestMethod.POST)
public String save(@RequestParam("file") MultipartFile file) throws IOException {
    FileObject fo = new FileObject();
    fo.setContent(file.getBytes());

    fileObjectRepository.save(fo);

    return "redirect:/files";
}</pre>

                <p>Tiedoston lähetys kontrollerista onnistuu vastaavasti. Tässä tapauksessa oletamme, että data on muotoa <code>image/png</code>; kontrolleri palauttaa tietokantaoliolta saatavan tavutaulukon pyynnön vastauksen rungossa.</p> 

                <pre class="sh_java">
@RequestMapping(value="{id}", method = RequestMethod.GET, produces = "image/png")
@ResponseBody
public byte[] get(@PathVariable Long id) {
    return fileObjectRepository.findOne(id).getContent();
}</pre>        

                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-gifbin">
                                    GifBin
                                </a>
                            </h1>
                        </header>
                        <div id="t-gifbin" class="collapse">
                            <p>Tässä tehtävässä toteutetaan sovellus gif-kuvien varastointiin ja selaamiseen. Tehtävästä saa kaksi tehtäväpistettä kun se palautetaan kokonaisena.</p>

                            <p>Pääset toteuttamaan huomattavan osan sovelluksesta itse -- tarkista että suunnittelemasi domain-oliot sopivat yhteen annetun näkymän kanssa.</p>

                            <h5>Kuvien listaaminen</h5>

                            <p>Tehtäväpohjassa olevassa <code>gifs.html</code>-sivussa on toiminnallisuus, minkä avulla kuvia näytetään käyttäjälle.</p>

                            <p>Toteuta toiminnallisuus, jonka avulla seuraavat toiminnot ovat käytössä.</p>

                            <ul>
                                <li>Kun käyttäjä tekee GET-tyyppisen pyynnön osoitteeseen <code>/gifs</code>, hänet ohjataan osoitteeseen <code>/gifs/1</code>.</li>
                                <li>Kun käyttäjä tekee GET-tyyppisen pyynnön osoitteeseen <code>/gifs/{id}</code>, hänelle näytetään sivu <code>gifs</code>. Pyynnön modeliin tulee lisätä attribuutti <code>count</code>, joka sisältää tietokannassa olevien kuvien määrän. Tämän lisäksi, pyyntöön tulee lisätä attribuutti <code>next</code>, joka sisältää seuraavan kuvan tunnuksen -- jos sellainen on olemassa,  attribuutti <code>previous</code>, joka sisältää edeltävän kuvan tunnuksen -- jos sellainen on olemassa, ja <code>current</code>, joka sisältää nykyisen kuvan tunnuksen -- jos sellainen on olemassa.</li>
                                <li>Kun käyttäjä tekee GET-tyyppisen pyynnön osoitteeseen <code>/gifs/{id}/content</code>, tulee hänelle palauttaa tunnukslla <code>{id}</code> tietokannassa oleva kuva -- vastauksen mediatyypiksi tulee asettaa myös <code>image/gif</code>.</li>
                            </ul>


                            <h5>Kuvien lisääminen</h5>

                            <p>HTML-sivulla on myös lomake, jonka avulla palvelimelle voi lähettää uusia kuvia. Toteuta palvelimelle toiminnallisuus, jonka avulla osoitteeseen <code>/gifs</code> tehdystä POST-pyynnöstä otetaan sisältö talteen ja tallennetaan se tietokantaa. Huom! Tallenna sisältö vain jos sen mediatyyppi on <code>image/gif</code>. Pyyntö uudelleenohjataan aina lopuksi osoitteeseen <code>/gifs</code>.</p>

                        </div>
                    </div>
                </div>

                <p>Kun isoja tiedostoja tallennetaan tietokantaan, kannattaa tietokanta suunnitella siten, että tiedostoja ei ladata tietokannasta sellaisten kutsujen yhteydessä, missä niitä ei tarvita. Voimme lisätä olioattribuuteille annotaatiolla <code>@Basic</code> lisämääreen <code>fetch</code>, minkä avulla hakeminen rajoitetaan eksplisiittisiin kutsuihin. Tarkasta tässä vaiheessa edellisen tehtävän mallivastaus -- huomaat että sielläkin -- vaikka annotaatio <code>@Basic</code> ei ollut käytössä -- konkreettinen kuva ladataan hyvin harvoin.</p>

                <pre class="sh_java">
import javax.persistence.Basic;
import javax.persistence.Entity;
import javax.persistence.Lob;
import org.springframework.data.jpa.domain.AbstractPersistable;

@Entity
public class FileObject extends AbstractPersistable&lt;Long&gt; {

    @Lob
    @Basic(fetch = FetchType.LAZY)
    private byte[] content;

    // getterit ja setterit
}</pre>

                <p>Ylläoleva <code>@Basic(fetch = FetchType.LAZY)</code> annotaatio pyytää JPA-toteutusta (tapauksessamme Hibernate) luomaan annotoidun olioattribuutin get-metodiin ns. proxymetodin -- data haetaan tietokannasta vasta kun metodia <code>getContent()</code> kutsutaan.</p>


                <h2>Yleiskäyttöinen tiedoston tallennus ja lataaminen</h2>

                <p>Edellisessä esimerkissä määrittelimme kontrollerimetodin palauttaman mediatyypin osaksi <code>@RequestMapping</code> annotaatiota. Usein tiedostopalvelimet voivat kuitenkin palauttaa lähes minkätyyppisiä tiedostojan tahansa. Tutustutaan tässä yleisempään tiedoston tallentamiseen ja lataukseen.</p>

                <p>Käytämme edellisessä esimerkissä käytettyä <code>FileObject</code>-entiteettiä toteutuksen pohjana.</p>

                <p>Jotta voimme kertoa tiedoston mediatyypin, haluamme tallentaa sen tietokantaan. Tallennetaan tietokantaan lisäksi myös tiedoston alkuperäinen nimi sekä tiedoston pituus.</p>

                <pre class="sh_java">
import javax.persistence.Basic;
import javax.persistence.Entity;
import javax.persistence.Lob;
import org.springframework.data.jpa.domain.AbstractPersistable;

@Entity
public class FileObject extends AbstractPersistable&lt;Long&gt; {

    private String name;
    private String mediaType;
    private Long size;

    @Lob
    @Basic(fetch = FetchType.LAZY)
    private byte[] content;

    // getterit ja setterit
}</pre>


                <p>Pääsemme kaikkiin kenttiin käsiksi <code>MultipartFile</code>-olion kautta; muokataan aiemmin näkemäämme kontrolleria siten, että otamme kaikki yllämääritellyt kentät tietokantaan tallennettavaan olioon.</p>


                <pre class="sh_java">
@RequestMapping(method = RequestMethod.POST)
public String save(@RequestParam("file") MultipartFile file) throws IOException {
    FileObject fo = new FileObject();

    fo.setName(file.getOriginalName());
    fo.setMediaType(file.getContentType());
    fo.setSize(file.getSize());
    fo.setContent(file.getBytes());

    fileObjectRepository.save(fo);

    return "redirect:/files";
}</pre>


                <p>Nyt tietokantaan tallennettu olio tietää myös siihen liittyvän mediatyypin. Haluamme seuraavaksi pystyä myös kertomaan kyseisen mediatyypin tiedostoa hakevalle käyttäjälle.</p>

                <p>Viime viikon materiaalissa vilahti käsite <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/http/ResponseEntity.html" target="_blank">ResponseEntity</a>. ResponseEntityä käytetään vastauksen paketointiin; voimme palauttaa kontrollerista ResponseEntity-olion, jonka pohjalta Spring luo vastauksen käyttäjälle. ResponseEntity-oliolle voidaan myös asettaa otsaketietoja, joihin saamme asetettua mediatyypin.</p>

                <pre class="sh_java">
    @RequestMapping(value = "/{id}", method = RequestMethod.GET)
    public ResponseEntity&lt;byte[]&gt; viewFile(@PathVariable Long id) {
        FileObject fo = fileObjectRepository.findOne(id);

        final HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.parseMediaType(fo.getContentType()));
        headers.setContentLength(fo.getSize());

        return new ResponseEntity&lt;&gt;(fo.getContent(), headers, HttpStatus.CREATED);
    }</pre>                         

                <p>Ylläolevassa esimerkissä vastaanotetaan pyyntö, minkä pohjalta tietokannasta haetaan FileObject-olio. Tämän jälkeen luodaan otsakeolio <code>HttpHeaders</code> ja asetetaan sille palautettavan datan mediatyyppi ja koko. Lopuksi palautetaan <code>ResponseEntity</code>-olio, mihin data, otsaketiedot ja pyyntöön liittyvä statusviesti (tässä tapauksessa CREATED) liitetään.</p>

                <p>Edeltävä esimerkki ei ota kantaa tiedoston nimeen tai siihen, miten se ladataan. Voimme lisäksi vastaukseen <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html" target="_blank">Content-Disposition</a>-otsakkeen, minkä avulla voidaan ehdottaa tiedoston tallennusnimeä sekä kertoa että tiedosto on liitetiedosto, jolloin se tulee tallentaa.</p>

                <pre class="sh_java">
    @RequestMapping(value = "/{id}", method = RequestMethod.GET)
    public ResponseEntity&lt;byte[]&gt; viewFile(@PathVariable Long id) {
        FileObject fo = fileObjectRepository.findOne(id);

        final HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.parseMediaType(fo.getContentType()));
        headers.setContentLength(fo.getSize());
        headers.add("Content-Disposition", "attachment; filename=" + fo.getName());

        return new ResponseEntity&lt;&gt;(fo.getContent(), headers, HttpStatus.CREATED);
    }</pre>                         




                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-filemanager">
                                    FileManager
                                </a>
                            </h1>
                        </header>
                        <div id="t-filemanager" class="collapse">

                            <p>Tässä tehtävässä toteutetaan yleisempi tiedostojen varastointiin ja näyttämiseen käytettävä sovellus. Tehtävästä saa kaksi tehtäväpistettä kun se palautetaan kokonaisena.</p>

                            <p>Kuten edellisessä tehtävässä, pääset toteuttamaan huomattavan osan sovelluksesta itse -- tarkista että suunnittelemasi domain-oliot sopivat yhteen annetun näkymän kanssa.</p>

                            <p>Toteuta toiminnallisuus, jonka avulla seuraavat toiminnot ovat käytössä.</p>

                            <ul>
                                <li>Kun käyttäjä tekee GET-tyyppisen pyynnön osoitteeseen <code>/files</code>, pyyntöön lisätään tietokannasta löytyvät tiedostot ja käyttäjä ohjataan sivulle <code>files.html</code>.</li>
                                <li>Kun käyttäjä lähettää lomakkeella tiedoston osoitteeseen <code>/files</code>, pyynnöstä otetaan talteen kaikki tiedot mitä näkymässä halutaan näyttää, ja tallennetaan ne tietokantaan. Pyyntö ohjataan lopuksi uudelleen osoitteeseen <code>/files</code>.</li>
                                <li>Kun käyttäjä klikkaa yksittäiseen tiedostoon liittyvää delete-nappia, tulee tiedosto poistaa tietokannasta. Lopuksi pyyntö uudelleenohjataan osoitteeseen <code>/files</code>.</li>
                                <li>Kun käyttäjä klikkaa yksittäiseen tiedostoon liittyvää nimeä sen lataamista varten, tulee tiedosto lähettää käyttäjälle. Aseta pyyntöön datan lisäksi myös tiedoston mediatyyppi että ja ehdotus tiedoston tallennusnimestä.</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <p>Edellä nähdyt lähestymistavat toimivat isossa osassa tapauksia, mutta lataavat datan hetkellisesti tietokannasta kontrollerin käyttöön. Palaamme tähän seuraavalla viikolla.</p>



                <h1>Tietoturva</h1>



                <h2>Autentikointi ja autorisointi</h2>

                <p>Autentikoinnilla tarkoitetaan sitä, että käyttäjän identiteetti varmistetaan. Autentikointi tapahtuu esimerkiksi käyttäjätunnuksen ja salasanan avulla. Autorisoinnilla taas tarkoitetaan sen varmistamista, että käyttäjä saa tehdä hänen yrittämiään asioita.</p>

                <p>Käyttäjän identiteetti tarkistetaan yleisimmin käyttäjätunnus-salasana -parin avulla. Kiitettävä osa nykyaikaisista sovelluskehyksistä lähes kaikki tarjoavat jonkinlaisen autentikointimekanismin.</p>

                <p>Springin tietoturvakomponentin, <a href="http://projects.spring.io/spring-security/" target="_blank">Spring Security</a>n saa käyttöön lisäämällä projektin <code>pom.xml</code>-tiedostoon seuraavan riippuvuuden.</p>

                <pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>

                <p>Komponentti tuo käyttöön pyyntöjä tarkastelevan <em>filtterin</em>, joka toimii ennen kontrollerimetodeja. Oletuskonfiguraatiolla pääsy estetään käytännössä kaikkiin sovelluksen resursseihin, mutta sitä voi luonnollisesti muuttaa. Luodaan oma konfiguraatiotiedosto <code>SecurityConfiguration</code>, joka sisältää sovelluksemme tietoturvakonfiguraation. Huom! Kun konfiguraatiotiedostoja alkaa olla useampia, voit asettaa ne asettaa esimerkiksi erillisen pakkauksen <code>wad.config</code> sisään. </p>

                <pre class="sh_java">
// pakkaus 

import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.authentication.configurers.GlobalAuthenticationConfigurerAdapter;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.annotation.web.servlet.configuration.EnableWebMvcSecurity;

@Configuration
@EnableWebMvcSecurity
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // ei päästetä käyttäjää mihinkään sovelluksen resurssiin ilman
        // kirjautumista
        http.authorizeRequests().anyRequest().authenticated();

        // tarjotaan mahdollisuus kirjautumiseen ja annetaan kaikille
        // pääsy kirjautumissivulle
        http.formLogin().permitAll();
    }

    @Configuration
    protected static class AuthenticationConfiguration extends GlobalAuthenticationConfigurerAdapter {
        @Override
        public void init(AuthenticationManagerBuilder auth) throws Exception {
            // käyttäjällä jack, jonka salasana on bauer, on rooli USER
            auth.inMemoryAuthentication()
                    .withUser("jack").password("bauer").roles("USER");
        }
    }
}</pre>

                <p>Tietoturvakonfiguraatio koostuu kahdesta osasta. Ensimmäisessä osassa <code>configure(HttpSecurity http)</code> määritellään sovelluksen osoitteet joihin on pääsy kielletty tai pääsy sallittu. Toisessa osassa <code>init(AuthenticationManagerBuilder auth)</code> taas määritellään  -- tässä tapauksessa -- käytössä olevat käyttäjätunnukset ja salasanat.</p>

                <p>Kun määritellään osoitteita, joihin käyttäjä pääsee käsiksi, on hyvä varmistaa, että viimeisenä sanotaan <code>anyRequest().authenticated()</code> -- tämä käytännössä johtaa tilanteeseen, missä kaikki osoitteet, joita ei ole erikseen määritelty, vaatii kirjautumista. Voimme määritellä osoitteita, jotka eivät vaadi kirjautumista seuraavasti:</p>

                <pre class="sh_java">
    // ..
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .antMatchers("/free").permitAll()
                .antMatchers("/access").permitAll()
                .antMatchers("/to/*").permitAll()
                .anyRequest().authenticated();

        // tarjotaan mahdollisuus kirjautumiseen ja annetaan kaikille
        // pääsy kirjautumissivulle
        http.formLogin().permitAll();
    }
    // ..</pre>                            

                <p>Ylläolevassa esimerkissä osoitteisiin <code>/free</code> ja <code>/access</code> ei tarvitse kirjautumista. Tämän lisäksi kaikki osoitteet polun <code>/to/</code> alla on kaikkien käytettävissä. Loput osoitteet on kaikilta kielletty. Tämän lisäksi, komento <code>http.formLogin().permitAll()</code> määrittelee sivun käyttöön kirjautumissivun, johon annetaan kaikille pääsy.</p>


                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-secretmessages">
                                    Secret Messages
                                </a>
                            </h1>
                        </header>
                        <div id="t-secretmessages" class="collapse">

                            <p>Tehtävässä on sovellus viestien näyttämiseen. Tehtävänäsi on lisätä siihen salaustoiminnallisuus -- kenenkään muun kuin käyttäjän "maxwell_smart" ei tule päästä viesteihin käsiksi. Aseta Maxwellin salasanaksi "kenkapuhelin".</p>

                        </div>
                    </div>
                </div>

                <h3>Näkymätason autorisointi</h3>


                <p>Autorisointi pelkkien polkujen perusteella ei aina riitä, vaan käyttöliitymissä halutaan usein rajoittaa toiminta esimerkiksi käyttäjäroolien perusteella. Thymeleaf-projektiin löytyy liitännäinen, jonka avulla voimme lisätä tarkistuksia HTML-sivuille. Liitännäisen saa käyttöön lisäämällä seuraavan riippuvuuden <code>pom.xml</code>-tiedostoon.</p>

                <pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;
    &lt;artifactId&gt;thymeleaf-extras-springsecurity3&lt;/artifactId&gt;
&lt;/dependency&gt;   
                </pre>                            

                <p>Nyt näkymiin voi määritellä elementtejä, joiden sisältö näytetään vain esimerkiksi tietyllä roolilla kirjautuneelle käyttäjälle. Seuraavassa esimerkissä teksti "salaisuus" näkyy vain käyttäjälle, jolla on rooli "ADMIN".</p>

                <pre class="sh_xml">
&lt;div sec:authorize="hasRole('ROLE_ADMIN')"&gt;
    &lt;p&gt;salaisuus&lt;/p&gt;
&lt;/div&gt;
                </pre>                            

                <p>Attribuutilla <code>sec:authorize</code> määritellään säännöt, joita tarkistuksessa käytetään. Attribuutille käy mm. arvot <code>isAuthenticated()</code>, <code>hasRole('...')</code> ja <code>hasAnyRole('...')</code>. Lisää sääntöjä löytyy Spring Securityn <a href="http://docs.spring.io/spring-security/site/docs/3.0.x/reference/el-access.html" target="_blank">dokumentaatiosta</a>.</p>


                <h3>Metoditason autorisointi</h3>

                <p>Pelkän näkymätason autorisoinnin ongelmana on se, että usein toimintaa halutaan rajoittaa tarkemmin -- esimerkiksi siten, että tietyt operaatiot (esim. poisto tai lisäys) mahdollistetaan vain tietyille rooleille. Käyttöliittymän näkymää rajoittamalla ei voida rajoittaa kutsuja polkuihin, ja aiemmin luotu polkuihin tehtävien kutsujen rajoitus ei auta esimerkiksi REST-tyyppisissä osoitteissa, varsinkin jos GET-pyyntöihin halutaan oikeus kaikille.</p>

                <p>Saamme sovellukseemme käyttöön myös metoditason autorisoinnin. Lisäämällä tietoturvakonfiguraatiotiedostoon luokkatason annotaation <code>@EnableGlobalMethodSecurity(securedEnabled = true, proxyTargetClass = true)</code>, Spring Security etsii metodeja, joissa käytetään sopivia annotaatioita ja suojaa ne. Suojaus tapahtuu käytännössä siten, että metodeihin luodaan proxy-metodit; aina kun metodia kutsutaan, kutsutaan ensin Spring securityn tietoturvakomponenttia, joka tarkistaa onko käyttäjä kirjautunut.</p>

                <p>Kun konfiguraatiotiedostoon on lisätty annotaatio, on käytössämme muunmuassa annotaatio <a href="http://docs.spring.io/autorepo/docs/spring-security/3.1.7.RELEASE/apidocs/org/springframework/security/access/annotation/Secured.html" target="_blank">@Secured</a>. Alla olevassa esimerkissä <code>post</code>-metodin käyttöön vaaditaan "ADMIN"-rooli.</p>

                <pre class="sh_java">
    @Secured("ROLE_ADMIN")
    @RequestMapping(method = RequestMethod.POST)
    public String post() {
        // ..
        return "redirect:/posts";
    }
                </pre>                            

                <h3>Roolien määrittely</h3>


                <p>Roolien määrittely tapahtuu osana konfiguraatiota. Alla olevassa konfiguraatiossa määritellään kolme eri käyttäjää, joilla jokaisella on oma rooli.</p>

                <pre class="sh_java">
    @Configuration
    protected static class AuthenticationConfiguration extends GlobalAuthenticationConfigurerAdapter {
        @Override
        public void init(AuthenticationManagerBuilder auth) throws Exception {
            auth.inMemoryAuthentication()
                    .withUser("aku").password("313").roles("USER");
            auth.inMemoryAuthentication()
                    .withUser("roope").password("onnenraha").roles("POMO");
            auth.inMemoryAuthentication()
                    .withUser("ohjelmistokehittaja").password("om1st4j4").roles("ADMIN");
        }
    }
    ...</pre>                            

                <p>Käyttäjä "aku" on normaali käyttäjä, "roope" on pomo, ja ohjelmistokehittäjä käytännössä päättää kaikesta.</p>



                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-hiddenfields">
                                    Hidden fields
                                </a>
                            </h1>
                        </header>
                        <div id="t-hiddenfields" class="collapse">

                            <p>Tehtävässä on sama sovellus viestien näyttämiseen kuin edellisessä tehtävässä.</p>

                            <h1>Kirjautuminen ja näkymän piilottaminen</h1>

                            <p>Luo sovellukseen tietoturvakonfiguraatio, missä määritellään kaksi käyttäjää. Ensimmäisellä käyttäjällä "user", jonka salasana on "password" on rooli "USER". Toisella käyttäjällä "postman", jonka salasana on "pat", on rooli "POSTER".</p>

                            <p>Muokkaa näkymää <code>messages.html</code> siten, että vain käyttäjät, joilla on rooli "POSTER" näkee lomakkeen, jolla voi lisätä uusia viestejä.</p>

                            <p>Muokkaa lisäksi konfiguraatiota siten, että käyttäjä voi kirjautua ulos osoitteesta <code>/logout</code>. Voit käyttää seuraavaa koodia (joutunet lisäämään konfiguraatioon muutakin..). </p>
                            <pre class="sh_java">
http.formLogin()
    .permitAll()
    .and()
    .logout()
    .logoutUrl("/logout")
    .logoutSuccessUrl("/login");</pre>                                            


                            <h1>Metoditason suojaus</h1>


                            <p>Lisää sovellukseen metoditason suojaus millä rajoitat POST-pyyntöjen tekemisen osoitteeseen <code>/message</code> vain käyttäjille, joilla on rooli "POSTER". Vaikka testit päästäisivät sinut läpi jo ennen tämän toteutusta, tee se silti :).</p>

                        </div>
                    </div>
                </div>


                <p>Käyttäjän identiteetin varmistaminen vaatii käyttäjälistan, joka taas yleensä ottaen tarkoittaa käyttäjän rekisteröintiä jonkinlaiseen palveluun. Käyttäjän rekisteröitymisen vaatiminen heti sovellusta käynnistettäessä voi rajoittaa käyttäjien määrää huomattavasti, joten rekisteröitymistä kannattaa pyytää vasta kun siihen on tarve.</p>

                <p>Erillinen rekisteröityminen ja uuden salasanan keksiminen ei ole aina tarpeen. Web-sovelluksille on käytössä useita kolmannen osapuolen tarjoamia keskitettyjä identiteetinhallintapalveluita. Esimerkiksi <a href="http://oauth.net/2/" target="_blank">OAuth2</a>:n avulla sovelluskehittäjä voi antaa käyttäjilleen mahdollisuuden käyttää jo olemassaolevia tunnuksia. Myös erilaiset sosiaalisen median palveluihin perustuvat autentikointimekanismit ovat yleistyneet viime aikoina.</p>



                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-extauth">
                                    External auth
                                </a>
                            </h1>
                        </header>
                        <div id="t-extauth" class="collapse">

                            <p>Teimme sattumalta viime viikolla tehtävän, missä luotiin rajapinta tunnistautumista varten. Rajapinta on käytössä osoitteessa <a href="http://authebin.herokuapp.com/authenticate">http://authebin.herokuapp.com/</a>, mistä sitä voi käyttää.</p>

                            <p>Tutustu tässä tehtävässä tehtäväpohjassa olevaan luokkaan <code>CustomAuthenticationProvider</code> sekä sen käyttöön <code>SecurityConfiguration</code>-luokassa. Toteuta toiminnallisuus, minkä avulla käyttäjä voi kirjautua osoitteessa http://authebin.herokuapp.com olevan palvelun avulla. Tässä tehtävässä on hyötyä RestTemplate-luokasta..</p>

                            <p>Tehtävässä ei ole testejä. Palauttamalla tehtävän, olet testannut että se toimii toivotusti ja tunnistautuminen kolmannen osapuolen rajapinnan kautta onnistuu.</p>

                        </div>
                    </div>
                </div>




                <h2>HTTPS</h2>

                <p>Usein kommunikointi selaimen ja palvelimen välillä halutaan salata, erityisesti salasanojen lähetyksen yhteydessä.</p>

                <p>HTTPS on HTTP-pyyntöjä SSL (nykyisin myös TLS)-rajapinnan yli. HTTPS mahdollistaa sekä käytetyn palvelun verifioinnin sertifikaattien avulla että lähetetyn ja vastaanotetun tiedon salauksen.</p>

                <p>HTTPS-pyynnöissä asiakas ja palvelin sopivat käytettävästä salausmekanismista ennen varsinaista kommunikaatiota. Käytännössä selain ottaa ensiksi yhteyden palvelimen HTTPS-pyyntöjä kuuntelevaan porttiin (yleensä 443), lähettäen palvelimelle listan selaimella käytössä olevista salausmekanismeista. Palvelin valitsee näistä parhaiten sille sopivan (käytännössä vahvimman) salausmekanismin, ja lähettää takaisin salaustunnisteen (palvelimen nimi, sertifikaatti, julkinen salausavain). Selain ottaa mahdollisesti yhteyttä sertifikaatin tarjoajaan -- joka on kolmas osapuoli -- ja tarkistaa onko sertifikaatti kunnossa.</p>

                <p>Selain lähettää palvelimelle salauksessa käytettävän satunnaisluvun palvelimen lähettämällä salausavaimella salattuna. Palvelin purkaa viestin ja saa haltuunsa selaimen haluaman satunnaisluvun. Viesti voidaan nyt lähettää salattuna satunnaislukua ja julkista salausavainta käyttäen.</p>

                <p>Käytännössä kaikki web-palvelimet tarjoavat HTTPS-toiminnallisuuden valmiina, joskin se täytyy ottaa palvelimilla käyttöön. Esimerkiksi Herokussa HTTPS:n saa käyttöön komennolla <code>heroku addons:add piggyback_ssl</code>. Lisätietoa Herokun SSL-tuesta osoitteessa <a href="https://devcenter.heroku.com/articles/ssl-endpoint" target="_blank">https://devcenter.heroku.com/articles/ssl-endpoint</a>.</p>


                <h2>OWASP</h2>


                <p>OWASP (<em>Open Web Application Security Project</em>) on verkkosovellusten tietoturvaan keskittynyt kansainvälinen järjestö. Sen tavoitteena on tiedottaa tietoturvariskeistä ja sitä kautta edesauttaa turvallisten web-sovellusten kehitystä. OWASP-yhteisö pitää mm. yllä listaa merkittävimmistä web-tietoturvariskeistä. Vuoden 2013 lista on seuraava:</p>

                <ol>
                    <li>Injection</li><br/>
                    <li>Broken Authentication and Session Management</li><br/>
                    <li>Cross-Site Scripting (XSS)</li><br/>
                    <li>Insecure Direct Object References</li><br/>
                    <li>Security Misconfiguration</li><br/>
                    <li>Sensitive Data Exposure</li><br/>
                    <li>Missing Function Level Access Control</li><br/>
                    <li>Cross-Site Request Forgery (CSRF)</li><br/>
                    <li>Using Components with Known Vulnerabilities</li><br/>
                    <li>Unvalidated Redirects and Forwards</li><br/>
                </ol>

                <p>Tutustu listaan tarkemmin osoitteessa <a href="https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project">https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project</a>. He tarjoavat dokumentaatiossaan kuvaukset riskeistä, sekä esimerkkejä hyökkäyksistä; <a href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet" target="_blank">Tässä</a> esimerkki XSS-filtterien kiertämisestä.</p>




                <div class="tehtavat">
                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-twiitberg">
                                    Twiitberg
                                </a>
                            </h1>
                        </header>
                        <div id="t-twiitberg" class="collapse">

                            <p>Tehtäväpohjaan on hahmoteltu palvelua, minne käyttäjä voi lisätä lyhyitä viestejä ja kuvia. Kuten huomaat, sovellus on jäänyt kesken, eikä edes autentikointi toimi. Tehtävänäsi tässä on (1) tutustua palveluun, (2) korjata autentikaatio, ja (3) keksiä toiminnallisuus tai kaksi, mitä palvelussa ei vielä ole, ja mitä siellä pitäisi olla. Toteuta keksimäsi toiminnallisuudet, ja palauta tehtävä.</p>

                            <p>Kirjoita tehtävän palautuksen yhteyteen toteuttamasi ominaisuudet -- tehtävä on kolmen kurssipisteen arvoinen.</p>

                        </div>
                    </div>
                </div>

            </section>
            <!-- END WEEK5 -->


            <!-- BEGIN WEEK6 -->

            <section class="weeklimit" data-week-id="6">

                <header>
                    <h1 id="viikko6">Viikko 6</h1>
                </header>

                <h1>Sovellusten skaalautuminen</h1>


                <p><em>Kts. <a href="http://en.wikipedia.org/wiki/Scalability" target="_blank">Wikipedian määritelmä skaalautuvuudelle</a></em></p>


                <p>Kun sovellukseen liittyvä verkkoliikenne ja tiedon määrä kasvaa niin isoksi, että sovelluksen käyttö takkuilee, tulee asialle tehdä jotain.</p>


                <aside class="extra">
                    <h1>Hitausongelmat</h1>

                    <p>Vaikka tässä kappaleessa puhummekin skaalautuvuudesta, liittyvät sovelluksen hitausongelmat usein myös konfiguraatio-ongelmiin. Tyypillisiä ongelmia ovat esimerkiksi toistuvat tietokantakyselyt tauluihin, joiden oleellisiin kenttiin ei ole määritelty hakuoperaatioita tehostavia indeksejä. Sovelluksen ongelmakohdat löytyy usein sovelluksen toimintaa profiloimalla. Spring-sovellusten profilointi onnistuu esimerkiksi <a href="http://blogs.vmware.com/vfabric/2012/10/understanding-the-difference-between-spring-insight-developer-insight-operations.html" target="_blank">Spring Insight</a>-komponenttien avulla. Spring Boot-projekteihin voi lisätää myös <a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-actuator" target="_blank">Actuator</a>-komponentin, joka kerää tilastoja sovelluksen käytöstä.</p>

                    <p>Vastaavasti selainpuolelle löytyy komponentteja, joiden avulla sivun nopeutta voi analysoida. Tutustu esimerkiksi Googlen <a href="https://developers.google.com/web-toolkit/speedtracer/get-started?csw=1" target="_blank">Speedtracer</a>-komponenttiin.</p>

                </aside>

                <p>Olettaen, että sovelluksen konfiguraatio on kunnossa, käytännössä ratkaisuun on kaksi vaihtoehtoa; (1) olemassaolevien resurssien parantaminen ja (2) palvelinmäärän kasvattaminen. Resurssien parantamiseen sisältyy esimerkiksi lisämuistin hankinta, käytettyjen algoritmien optimointi ym, kun taas palvelinmäärää kasvattaessa sovelluskehittäjän tulee mahdollistaa pyyntöjen jakaminen useamman palvelimen välillä.</p>

                <p>Sovellukset eivät skaalaannu lineaarisesti, ja skaalautumiseen liittyy paljon muutakin kuin resurssien lisääminen. Jos yksi palvelin pystyy käsittelemään tuhat pyyntöä sekunnissa, emme voi olettaa, että kahdeksan palvelinta pystyy käsittelemään kahdeksantuhatta pyyntöä sekunnissa, sillä tehoon vaikuttavat myös muut käytetyt komponentit sekä verkkokapasiteetti. Aivan kuten uuden turboahdetun auton hankkiminen ei poista aamuruuhkia, yksittäinen tehokas komponentti sovelluksessa ei takaa sovelluksen tehokkuutta.</p>

                <p>Ei ole olemassa yhtä oikeaa lähestymistapaa. Joskus tehokkaamman palvelimen hankkiminen on nopeampaa ja kustannustehokkaampaa kuin sovelluksen muokkaaminen -- esimerkiksi hitaasti toimiva tietokanta tehostuu tyypillisesti huomattavasti lisäämällä käytössä olevaa muistia.</p>



                <!--

                <p>tänne myös load balancing -- vertical scaling</p>


                <p>yksinkertainen webisovellus (internet -> palvelin -> kanta)</p>
                -->

                <h2>Palvelinmäärän kasvattaminen</h2>

                <p>Käytännössä skaalautumisesta puhuttaessa puhutaan horisontaalisesta skaalautumisesta, jossa käyttöön hankitaan esimerkiksi lisää palvelimia. Vertikaalinen skaalautumisen harkinta on mahdollista tietyissä tapauksissa, esimerkiksi tietokantapalvelimen ja -kyselyiden toimintaa suunniteltaessa, mutta yleisesti ottaen horisontaalinen skaalautuminen on kustannustehokkaampaa. (vrt. kahden miestyökuukauden käyttö algoritmin optimointiin, joka aiheuttaa algoritmin 10% tehoparannuksen, vs. ylimääräisen palvelimen hankkiminen, josta saa saman hyödyn; käyttäjien määrän kasvaessa uusien palvelinten hankkiminen on joka tapauksessa vastassa.)</p>

                <p>Pyyntöjen määrän kasvaessa yksinkertainen ratkaisu on palvelinmäärän eli käytössä olevan raudan kasvattaminen. Tällöin pyyntöjen jakaminen palvelinten kesken hoidetaan erillisellä kuormantasaajalla (<em><a href="http://en.wikipedia.org/wiki/Load_balancing_(computing)" target="_blank">load balancer</a></em>), joka ohjaa pyyntöjä palvelimille.</p>

                <p>Jos sovellukseen ei liity tilaa (esimerkiksi käyttäjän tunnistaminen tai ostoskori), kuormantasaaja voi ohjata pyyntöjä käytössä oleville palvelimille round-robin -tekniikalla. Jos sovellukseen liittyy tila, tulee tietyn asiakkaan tekemät pyynnöt ohjata aina samalle palvelimelle. Tämän voi toteuttaa esimerkiksi siten, että kuormantasaaja lisää pyyntöön evästeen, jonka avulla käyttäjä identifioidaan ja ohjataan oikealle palvelimelle. Tätä lähestymistapaa kutsutaan usein termillä (<em>sticky session</em>).</p>

                <p>Pelkkä palvelinmäärän kasvattaminen ja kuormantasaus ei kuitenkaan ole aina tarpeeksi. Kuormantasaus helpottaa verkon kuormaa, mutta ei ota kantaa palvelinten kuormaan. Jos yksittäinen palvelin käsittelee pitkään kestävää laskentaintensiivistä kyselyä, voi kuormantasaaja ohjata tälle palvelimelle lisää kyselyjä "koska eihän se ole vähään aikaan saanut mitään töitä".  Käytännössä tällöin entisestään paljon laskentaa tekevä palvelimen saa lisää kuormaa. On kuitenkin mahdollista käyttää kuormantasaajaa, joka lisäksi pitää kirjaa palvelinten tilasta, mutta käytännössä kuorma vaihtuu usein hyvin nopeasti, ja reagointi ei aina ole nopeaa.</p>

                <p>Parempi ratkaisu palvelinmäärän kasvattamiselle on palvelinmäärän kasvattaminen <em>ja</em> sovelluksen suunnittelu siten, että laskentaintensiiviset operaatiot käsitellään erillisillä palvelimilla. Tällöin käytetään käytännössä erillistä laskentaklusteria aikaa vievien laskentaoperaatioiden käsittelyyn, jolloin käyttäjän pyyntöjä kuuntelevan palvelimen kuorma pysyy alhaisena.</p>

                <p>Riippuen pyyntöjen määrästä, palvelinkonfiguraatio voidaan toteuttaa jopa siten, että staattiset tiedostot (esim. kuvat) löytyvät erillisiltä palvelimilta, GET-pyynnöt käsitellään erillisillä pyyntöjä vastaanottavilla palvelimilla, ja datan muokkaamista tai prosessointia vaativat kyselyt (esim POST) ohjataan asiakkaan pyyntöjä vastaanottavien palvelinten toimesta laskentaklusterille.</p>

                <aside class="extra">
                    <h1>Rajoitettu määrä samanaikaisia pyyntöjä osoitetta kohden</h1>

                    <p>Staattisten resurssien kuten kuvien ja tyylitiedostojen hajauttaminen eri palvelimille on oikeastaan fiksua. <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html" target="_blank">HTTP 1.1-spesifikaation</a> yhteyksiin liittyvässä osissa suositellaan tiettyyn osoitteeseen tehtävien samanaikaisten pyyntöjen määrän rajoittamista kahteen.</p>

                    <p><em>Clients that use persistent connections SHOULD limit the number of simultaneous connections that they maintain to a given server. A single-user client SHOULD NOT maintain more than 2 connections with any server or proxy. A proxy SHOULD use up to 2*N connections to another server or proxy, where N is the number of simultaneously active users. These guidelines are intended to improve HTTP response times and avoid congestion.</em></p>

                    <p>Käytännössä suurin osa selaimista tekee enemmän kuin 2 kyselyä kerrallaan samaan osoitteeseen. Jos web-sivusto sisältää paljon erilaisia staattisita resursseja, ja ne sijaitsevat kaikki samalla palvelimella, saadaan resursseja korkeintaan selaimeen rajoitettu määrä kerrallaan. Toisaalta, jos resurssit jaetaan useamman sijainnin kesken, ei tätä rajoitetta ole.</p>

                    <p>Resurssien jakaminen useampaan sijantiin mahdollistaa myös maantieteellisen hajauttamisen, missä käyttäjä saa sivun sisällön lähellä olevilta palvelimilta, mikä nopeuttaa vasteaikaa. Sama resurssi voi olla myös useammalla palvelimella.</p>

                    <p>Tutustu aiheeseen lisää lukemalla Wikipedian artikkeli <a href="http://en.wikipedia.org/wiki/Content_delivery_network" target="_blank">Content delivery network</a>.</p>

                </aside>



                <h2>Sessiot</h2>

                <p>Kun käyttäjä kirjautuu palvelinohjelmistoon, tieto käyttäjästä pidetään tyypillisesti yllä sessiossa. Sessiot toimivat evästeiden avulla, jotka palvelin asettaa pyynnön vastaukseen, ja selain lähettää aina palvelimelle. Sessiotiedot ovat oletuksena yksittäisellä palvelimella, mikä aiheuttaa ongelmia palvelinmäärän kasvaessa. Edellä olevassa kappaleessa erääksi ratkaisuksi mainittiin kuormantasaajien (load balancer) käyttö siten, että käyttäjät ohjataan aina samalle koneelle. Tämä ei kuitenkaan ole aina mahdollista -- kuormantasaajat eivät aina tue sticky session -tekniikkaa -- eikä kannattavaa -- kun palvelinmäärää säädellään dynaamisesti, uusi palvelin käynnistetään tyypillisesti vasta silloin, kun havaitaan ruuhkaa -- olemassaolevat käyttäjät ohjataan ruuhkaantuneelle palvelimelle uudesta palvelimesta riippumatta.</p>

                <p>Yksi vaihtoehto on skaalautumisongelman siirtäminen tietokannalle. Sen sijaan, että käytetään palvelimen hallinnoimia sessioita, pidetään käyttäjätunnus ja kirjautumistieto salattuna evästeessä. Eväste lähetetään kaikissa tiettyyn osoitteeseen tehtävissä kutsuissa; palvelin voi tarvittaessa purkaa evästeessä olevan viestin ja hakea käyttäjään liittyvät tiedot tietokannasta. Tässä luonnollisesti tietokannasta voi muodostua pullonkaula -- myös tietokantojen lisääminen on mahdollista.</p>

                <div class="tehtavat">
                    <div class="tehtava" id="t-cookieauth">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-cookieauth">
                                    Cookie-based authentication
                                </a>
                            </h1>
                        </header>

                        <div id="t-cookieauth" class="collapse">

                            <p>Tässä tehtävässä hiotaan Springin <a href="http://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/web/authentication/rememberme/PersistentTokenBasedRememberMeServices.html" target="_blank">PersistentTokenBasedRememberMeServices</a>-komponenttia luomalla siihen JPA:ta käyttävä tietokantatoiminnallisuus. PersistentTokenBasedRememberMeServices-komponentti tarjoaa evästeisiin perustuvan autentikaation, joka perustuu seuraaviin askeleisiin:</p>

                            <ol>
                                <li>Kun käyttäjä kirjautuu siten, että hän valitsee <code>Remember Me</code>-vaihtoehdon, käyttäjälle annetaan eväste.</li>
                                <li>Eväste sisältää käyttäjän käyttäjätunnuksen, evästeen sarjanumeron, sekä viestin. Sarjanumero ja viesti ovat satunnaisesti generoituja ja ne tallennetaan tietokantaan.</li>
                                <li>Kun käyttäjä vierailee sivulla, hän lähettää pyynnössä evästeen. Tällöin käyttäjätunnus, sarjanumero ja viesti haetaan tietokannasta.</li>
                                <li>Jos kaikki edellämainitut löytyvät tietokannasta, oletetaan että käyttäjä on kirjautunut sivulle. Samalla käytetty viesti poistetaan tietokannasta, ja tietokantaan luodaan uusi satunnainen viesti aiemmin käytettyjen sarjanumeron ja käyttäjätunnuksen pariksi. Käyttäjälle palautetaan uusi eväste, missä on uudet tiedot.</li>
                                <li>Jos käyttäjätunnus ja sarjanumero on oikein, mutta viesti on väärin, oletetaan että joku on yrittänyt ryövätä käyttäjän tunnuksen ja pyydetään käyttäjää kirjautumaan. Samalla kaikki käyttäjään liittyvät aiemmat evästetiedot / kirjautumisdatat poistetaan tietokannasta.</li>
                                <li>Jos käyttäjätunnusta ja sarjanumeroa ei ole olemassa, pyydetään käyttäjää kirjautumaan.</li>
                            </ol>

                            <p>Ylläolevan toteutuksen etuna on se, että se skaalautuu melko hyvin. Palvelinten määrää voi kasvattaa niin pitkään kuin tietokantatason toiminta toimii hyväksyttävällä tehokkuudella.</p>

                            <p>Projektiin on toteutettu valmiiksi entiteettiluokka <code>CustomPersistentToken</code> sekä <code>PersistentTokenBasedRememberMeServices</code>-palvelun tarvitseman <a href="http://docs.spring.io/autorepo/docs/spring-security/current/apidocs/org/springframework/security/web/authentication/rememberme/PersistentTokenRepository.html" target="_blank">PersistentTokenRepository</a>-rajapinnan toteuttavan luokan runko, joka löytyy sijainnista <code>wad.auth.CustomPersistentTokenService</code>.</p>

                            <p><strong>Toteuta tarvittava toiminnallisuus JPA-tuen aikaansaamiseksi.</strong> Tarvitset ainakin palvelun CustomPersistentToken-entiteetin tallentamiseen, jonka lisäksi tarvitset sopivaa logiikkaa <code>CustomPersistentTokenService</code>-luokkaan; voit ottaa mallia esimerkiksi Springin vastaavasta JDBC-rajapintaa käyttävästä <a href="https://github.com/spring-projects/spring-security/blob/master/web/src/main/java/org/springframework/security/web/authentication/rememberme/JdbcTokenRepositoryImpl.java" target="_blank">JdbcTokenRepositoryImpl</a>-luokasta, missä vastaava toteutus on tehty ilman JPA:ta -- voit käytännössä hyödyntää samaa toimintaideaa omassa koodissasi. Lue siis JdbcTokenRepositoryImpl-luokan toteutus, ja kopioi sen logiikka omaan JPA-pohjaiseen toteutukseesi. </p>

                            <p>Tehtävä on kahden tehtäväpisteen arvoinen.</p>

                        </div>
                    </div>
                </div>

                <p>Juuri harjoitellun vaihtoehdon lisäksi on evästeisiin perustuva autentikoituminen mahdollista toteuttaa myös siten, että tietokannassa olevia evästetietoja ei päivitetä pyynnön yhteydessä, mikä vähentää tietokantakuormaa. Viimeistään tällöin palvelimelle tulee konfiguroida HTTPS-tuki, jonka jälkeen kaikki liikenne tulee ohjata HTTPS-protokollan yli. Tämä vähentää <a href="http://en.wikipedia.org/wiki/Man-in-the-middle_attack" target="_blank">man-in-the-middle</a> hyökkäyksen uhriksi joutumisen riskiä.</p>


                <h2>Asynkroniset metodikutsut ja viestijonot</h2>

                <p>Tähän asti toteuttamissamme sovelluksissa pyynnön suorittaminen on tapahtunut kutakuinkin seuraavasti:</p>

                <ol>
                    <li>Pyyntö lähetetään palvelimelle</li>
                    <li>Palvelin vastaanottaa pyynnön ja ohjaa pyynnön oikealle kontrollerille</li>
                    <li>Kontrolleri vastaanottaa pyynnön ja ohjaa pyynnön oikealle palvelulle tai palveluille</li>
                    <li>Palvelu vastaanottaa pyynnön, suorittaa pyyntöön liittyvät operaatiot mahdollisesti muiden palveluiden kanssa, ja palauttaa vastauksen kontrollerille</li>
                    <li>Kontrolleri ohjaa pyynnön sopivalle näkymälle, joka renderöidään -- vastaus palautetaan lopulta käyttäjälle.</li>
                </ol>

                <p>Palvelukutsun suorituksen odottaminen ei ole aina tarpeen. Jos sovelluksemme suorittaa esimerkiksi raskaampaa laskentaa, tai tekee pitkiä tietokantaoperaatioita joiden tuloksia käyttäjän ei tarvitse nähdä heti, kannattaa pyyntö suorittaa asynkronisesti.</p>

                <p>Asynkroniset metodikutsut tapahtuvat seuraavasti (tässä palvelukutsu tapahtuu asynkronisesti):</p>

                <ol>
                    <li>Pyyntö lähetetään palvelimelle</li>
                    <li>Palvelin vastaanottaa pyynnön ja ohjaa pyynnön oikealle kontrollerille</li>
                    <li>Kontrolleri vastaanottaa pyynnön ja ohjaa pyynnön oikealle palvelulle</li>
                    <li>Palvelu asettaa pyynnön suoritusjonoon ja palvelukutsusta palataan heti (palvelun tyyppi on void)</li>
                    <li>Kontrolleri ohjaa pyynnön sopivalle näkymälle, joka renderöidään -- vastaus palautetaan lopulta käyttäjälle.</li>
                </ol>

                <p>Ohjelmistokehykset toteuttavat asynkroniset metodikutsut luomalla palvelukutsusta erillisen säikeen, jossa pyyntö käsitellään. Spring Bootin tapauksessa asynkroniset metodikutsut saa käyttöön lisäämällä sovelluksen konfiguraatioon (tapauksessamme usein <code>Application</code>-luokassa) rivi <code>@EnableAsync</code>. Kun konfiguraatio on paikallaan, voimme suorittaa metodeja asynkronisesti. Jotta metodisuoritus olisi asynkroninen, tulee metodin olla <code>void</code>-tyyppinen, sekä sillä tulee olla annotaatio <code>@Async</code>.</p>

                <p>Tutkitaan tapausta, jossa tallennetaan <code>Item</code>-tyyppisiä olioita. Item-olion sisäinen muoto ei ole niin tärkeä.</p>

                <pre class="sh_java">
    @RequestMapping(method = RequestMethod.POST)
    public String create(RedirectAttributes redirectAttributes,
            @Valid @ModelAttribute Item item, BindingResult bindingResult) {
        if (bindingResult.hasErrors()) {
            return "form";
        }

        itemService.create(item);

        return "redirect:/items";
    }</pre>

                <p>Oletetaan että <code>ItemService</code>-olion metodi <code>create</code> on void-tyyppinen, ja näyttää seuraavalta:</p>

                <pre class="sh_java">
    public void create(Item item) {
        // koodia.. 
    }</pre>

                <p>Metodin muuttaminen asynkroniseksi vaatii <code>@Async</code>-annotaation.</p>

                <pre class="sh_java">
    @Async
    public void create(Item item) {
        // koodia.. 
    }</pre>

                <p>Voila! Käytännössä asynkroniset metodikutsut toteutetaan asettamalla metodikutsu suoritusjonoon, josta se suoritetaan kun sovelluksella on siihen mahdollisuus.</p>


                <div class="tehtavat">
                    <div class="tehtava" id="t-calculations">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-calculations">
                                    Calculations
                                </a>
                            </h1>
                        </header>

                        <div id="t-calculations" class="collapse">

                            <p>Tehtäväpohjassa on sovellus, joka tekee raskasta laskentaa (nukkuu kuin tutkijat). Tällä hetkellä käyttäjä joutuu odottamaan laskentapyynnön suoritusta pitkään, mutta olisi hienoa jos käyttäjälle kerrottaisiin laskennan tilasta jo laskentavaiheessa.</p>

                            <p>Muokkaa sovellusta siten, että laskenta tallennetaan kertaalleen jo ennen laskentaa -- näin siihen saadaan viite; aseta oliolle myös status "PROCESSING". Muokkaa tämän jälkeen luokkaa <code>CalculationService</code> siten, että laskenta tapahtuu asynkronisesti.</p>

                            <p>Huom! Älä poista <code>CalculationService</code>-luokasta koodia</p>

                            <pre class="sh_java">
        try {
            Thread.sleep(2000);
        } catch (InterruptedException ex) {
            Logger.getLogger(CalculationService.class.getName()).log(Level.SEVERE, null, ex);
        }</pre>                            


                            <p>Kun sovelluksesi toimii oikein, laskennan lisäyksen pitäisi olla nopeaa ja käyttäjä näkee lisäyksen jälkeen laskentakohtaisen sivun, missä on laskentaan liittyvää tietoa. Kun sivu ladataan uudestaan noin 2 sekunnin kuluttua, on laskenta valmistunut.</p>

                        </div>
                    </div>
                </div>


                <h3>Rinnakkain suoritettavat metodikutsut</h3>

                <p>Koostepalvelut, eli palvelut jotka keräävät tietoa useammasta palvelusta ja yhdistävät tietoja käyttäjälle, tyypillisesti haluavat näyttää käyttäjälle vastauksen.</p>

                <p>Näissä tilanne on usein se, että palveluita on useita, ja niiden peräkkäinen suorittaminen on tyypillisesti hidasta. Suoritusta voi nopeuttaa ottamalla käyttöön rinnakkaisen suorituksen, joka onnistuu esimerkiksi Javan <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html" target="_blank">ExecutorService</a>-luokan avulla. Voimme käytännössä lisätä tehtäviä niitä suorittavalle palvelulle, jolta saamme viitteen tulevaa vastausta varten.</p>

                <p>Spring tarjoaa myös tähän apuvälineitä. Kun lisäämme sovellukselle <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/task/AsyncTaskExecutor.html">AsyncTaskExecutor</a>-rajapinnan toteuttaman olion (esimerkiksi <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor.html" target="_blank">ThreadPoolTaskExecutor</a>), voimme injektoida sen sovelluksemme käyttöön tarvittaessa. Tietynlaisen olion sovellukseen tapahtuu luomalla <code>@Bean</code>-annotaatiolla merkitty olio konfiguraatiotiedostossa. Alla esimerkiksi luodaan edellämainitut oliot.</p>


                <pre class="sh_java">
// konfiguraatiotiedosto
    @Bean
    public AsyncTaskExecutor asyncTaskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(8);
        return executor;
    }</pre>

                <p>Nyt voimme ottaa käyttöön sovelluksessa <code>AsyncTaskExecutor</code>-rajapinnan toteuttavan olion.</p>
                <pre class="sh_java">
    @Autowired
    private AsyncTaskExecutor taskExecutor;</pre>

                <p>Käytännössä tehtävien lisääminen rinnakkaissuorittajalle tapahtuu esimerkiksi seuraavasti. Alla luodaan kolme <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Callable.html" target="_blank">Callable</a>-rajapinnan toteuttavaa oliota, annetaan ne <code>taskExecutor</code>-ilmentymälle, ja otetaan jokaisen kohdalla talteen <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html" target="_blank">Future</a>-viite, mihin suorituksen tulos asetetaan kun suoritus on loppunut. Future-oliosta saa tuloksen <code>get</code>-metodilla.</p>

                <pre class="sh_java">
    // käytössä myös ylläoleva taskExecutor
    List&lt;Future&lt;TuloksenTyyppi&gt;&gt; results = new ArrayList&lt;&gt;();

    results.add(taskExecutor.submit(new Callable&lt;TuloksenTyyppi&gt;() {
        @Override
        public TuloksenTyyppi call() {
            // laskentaa.. -- tulos voi olla käytännössä mitä tahansa
            return new TuloksenTyyppi();
        }
    }));
    
    for (Future&lt;TuloksenTyyppi&gt; result: results) {
        TuloksenTyyppi t = result.get();

        // tee jotain tällä..
    }</pre>


                <div class="tehtavat">
                    <div class="tehtava" id="t-lowestprice">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-lowestprice">
                                    Lowest Prices
                                </a>
                            </h1>
                        </header>

                        <div id="t-lowestprice" class="collapse">

                            <p>Tehtäväpohjaan on lähdetty toteuttamaan sovellusta, joka etsii eri palveluiden rajapinnoista halutun esineen hintaa ja palauttaa halvimman. Palvelusta on toteutettu ensimmäinen versio, mutta se on liian hidas.</p>

                            <p>Ennenkuin sovelluskehittäjät juoksevat hakemaan uutta rautaa, muokkaa palvelun <code>QuoteService</code>-toiminnallisuutta siten, että se suorittaa hintakyselyt rinnakkain nykyisen peräkkäissuorituksen sijaan.</p>

                        </div>
                    </div>
                </div>

                <aside class="extra">
                    <h1>Java 8 ja kokoelmien rinnakkainen läpikäynti</h1>

                    <p>Java 8 tarjoaa kehittyneemmän välineistön kokoelmien läpikäyntiin. Tutustu näihin osoitteessa <a href="http://docs.oracle.com/javase/tutorial/collections/streams/parallelism.html" target="_blank">http://docs.oracle.com/javase/tutorial/collections/streams/parallelism.html</a>.</p>

                </aside>

                <h3>Viestijonot</h3>

                <p>Kun palvelinohjelmistoja skaalataan siten, että osa laskennasta siirretään erillisille palvelimille, on oleellista että palveluiden välillä kulkevat viestit (pyynnöt ja vastaukset) eivät katoa, ja että käyttäjän pyyntöjä vastaanottavan palvelimen ei tarvitse huolehtia toisille palvelimille lähetettyjen pyyntöjen perille menemisestä tai lähetettyjen viestien vastausten käsittelystä. Eniten käytetty lähestymistapa viestien säilymisen varmentamiseen on viestijonot (<em>messaging</em>, <em>message queues</em>), joiden tehtävänä on toimia viestien väliaikaisena säilytyspisteenä. Käytännössä viestijonot ovat erillisiä palveluita, joihin viestien tuottajat (<em>producer</em>) voivat lisätä viestejä, joita viestejä käyttävät palvelut kuluttavat (<em>consumer</em>).</p>

                <p>Viestijonoja käyttävät sovellukset kommunikoivat viestijonon välityksellä. Tuottaja lisää viestejä viestijonoon, josta käyttäjä niitä hakee. Kun viestin sisältämän datan käsittely on valmis, prosessoija lähettää viestin takaisin. Viestijonoissa on yleensä varmistustoiminnallisuus: jos viestille ei ole vastaanottajaa, jää viesti viestijonoon ja se tallennetaan esimerkiksi viestijonopalvelimen levykkeelle. Viestijonojen konkreettinen toiminnallisuus riippuu viestijonon toteuttajasta.</p>

                <p>Viestijonosovelluksia on useita, esimerkiksi <a href="http://activemq.apache.org/" target="_blank">ActiveMQ</a> ja <a href="http://www.rabbitmq.com/" target="_blank">RabbitMQ</a>. Viestijonoille on myös useita standardeja, joilla pyritään varmistamaan sovellusten yhteensopivuus. Esimerkiksi Javan melko pitkään käytössä ollut <a href="http://en.wikipedia.org/wiki/Java_Message_Service" target="_blank">JMS</a>-standardi määrittelee viestijonoille rajapinnan, jonka viestijonosovelluksen tarjoajat voivat toteuttaa. Nykyään myös <a href="http://www.amqp.org/" target="_blank">AMQP</a>-protokolla on kasvattanut suosiotaan. Myös Spring tarjoaa komponentteja viestijonojen käsittelyyn, tutustu lisää aiheeseen <a href="http://spring.io/guides/gs/messaging-jms/" target="_blank">täällä</a>.</p>


                <h2>Palvelinpuolen välimuistit</h2>

                <p>Tyypillisissä web-palvelinohjelmistoissa huomattava osa kyselyistä on GET-tyyppisiä pyyntöjä. GET-tyyppiset pyynnöt eivät muokkaa palvelimella olevaa dataa, vaan pyytävät tietoa. Esimerkiksi tietokannasta dataa hakevat GET-tyyppiset pyynnöt luovat yhteyden tietokantasovellukseen, josta data haetaan. Jos näitä pyyntöjä on useita, eikä tietokannassa oleva data juurikaan muutu, on hyödyllistä ottaa data talteen siten, että tietokantakyselyä ei tarvitse tehdä.</p>

                <p>Spring Bootia käytettäessä palvelimessa käytettävän välimuistin konfigurointi tapahtuu lisäämällä konfiguraatiotiedostoon annotaatio <code>@EnableCaching</code> sekä luomalla <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/cache/CacheManager.html" target="_blank">CacheManager</a>-rajapinnan toteuttava olio sovellukseen. Yksi vaihtoehto on yksinkertaisen muistiin ladattavan välimuistitoteutuksen, kuten <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/cache/support/SimpleCacheManager.html" target="_blank">SimpleCacheManager</a> käyttäminen. Välimuistille tulee lisäksi määritellä välimuistin <em>nimi</em>, johon välimuistia käytettäessä viitataan. Alla sovelluksen käyttöön tuodaan yksinkertainen välimuistitoteutus, joka pitää kirjaa <code>beers</code>-nimisestä kokoelmasta.</p>

                <pre class="sh_java">
// muu konfiguraatio
    @Bean
    public CacheManager cacheManager() {
        SimpleCacheManager manager = new SimpleCacheManager();
        manager.setCaches(Arrays.asList(new ConcurrentMapCache("beers")));
        return manager;
    }
// muu konfiguraatio
                </pre>                

                <p>Kun välimuisti on konfiguroitu, voimme lisätä välimuistitoiminnallisuuden palvelumetodeille <code>@Cacheable</code>-annotaation avulla. Alla olevassa esimerkissä metodin <code>read</code> palauttama tulos asetetaan välimuistiin.</p>

                <pre class="sh_java">
@Service
public class BeerService {

    @Autowired
    private BeerRepository beerRepository;

    @Cacheable("beers")
    public Beer read(Long id) {
        return beerRepository.findOne(id);
    }

    // ...</pre>

                <p>Käytännössä annotaatio <code>@Cacheable</code> luo metodille <code>read</code> proxy-metodin, joka ensin tarkistaa onko haettavaa tulosta välimuistissa -- proxyt ovat käytössä vain jos metodia kutsutaan luokan ulkopuolelta. Jos tulos on välimuistissa, palautetaan se sieltä, muuten tulos haetaan tietokannasta ja tallennetaan välimuistiin. Metodin parametrina annettavia arvoja hyödynnetään cacheavaimen toteuttamisessa, eli jokaista olutta kohden voidaan luoda oma tietue välimuistiin. Tutustu Springin <a href="http://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/cache.html" target="_blank">cache</a>-dokumentaation osaan "Default Key Generation" niin saat tarkemman kuvan avaimen luontiprosessista.</p>

                <p>Välimuistitoteutuksen vastuulla ei ole pitää kirjaa tietokantaan tehtävistä muutoksista, jolloin välimuistin tyhjentäminen muutoksen yhteydessä on sovelluskehittäjän vastuulla. Dataa muuttavat metodit tulee annotoida sopivasti annotaatiolla <code>@CacheEvict</code>, jotta välimuistista poistetaan muuttuneet tiedot.</p>



                <div class="tehtavat">
                    <div class="tehtava" id="t-weatherservice">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-weatherservice">
                                    Weather Service
                                </a>
                            </h1>
                        </header>

                        <div id="t-weatherservice" class="collapse">

                            <p>Kumpulan kampuksella majaileva ilmatieteen laitos kaipailee pientä viritystä omaan sääpalveluunsa. Tällä hetkellä palvelussa on toiminnallisuus sijaintien hakemiseen, lisäämiseen sekä säähavaintojen lisäämiseen. Ilmatieteen laitos on toteuttanut säähavaintojen lisäämisen suoraan tuotantotietokantaan, mihin ei tässä palvelussa päästä käsiksi. Palvelussa halutaan kuitenkin muutama lisätoiminnallisuus:</p>


                            <h1>Sijaintien tallennus välimuistiin</h1>

                            <p>Lisää sovellukseen välimuistitoiminnallisuus. Osoitteisiin <code>/locations</code> ja <code>/locations/{id}</code> tehtyjen hakujen tulee toimia siten, että jos haettava sijainti ei ole välimuistissa, se haetaan tietokannasta ja tallennetaan välimuistiin. Jos sijainti taas on välimuistissa, tulee se palauttaa sieltä ilman tietokantahakua.</p>


                            <h1>Välimuistin tyhjennys tarvittaessa</h1>

                            <p>Lisää sovellukseen toiminnallisuus, missä käytössä oleva välimuisti tyhjennetään kun käyttäjä lisää uuden sijainnin tai tekee GET-tyyppisen pyynnön osoitteeseen <code>/flushcaches</code>. Erityisesti jälkimmäinen on tärkeä asiakkaalle, sillä se lisää tietokantaan tietoa myös palvelinohjelmiston ulkopuolelta.</p>

                        </div>
                    </div>
                </div>

                <aside class="extra">
                    <h1>Erilaiset välimuistitoteutukset</h1>

                    <p>Ympäristöprofiilien <code>@Profile</code> avulla sovelluskehittäjä voi konfiguroida erilaiset välimuistiasetukset eri ympäristöille. Kun testattaessa käytetään esimerkiksi aiemmin käyttämäämme <code>SimpleCacheManager</code>-luokkaa, on tuotannossa hyödyllistä ottaa käyttöön ympäristöön sopiva ratkaisu. Tyypillisiä tuotannossa käytettäviä komponentteja ovat <a href="http://ehcache.org/" target="_blank">EHCache</a> ja <a href="http://memcached.org/" target="_blank">Memcached</a>.</p>

                </aside>



                <h2>Tiedostojen jakaminen ja tietokannat</h2>

                <p>Kun sovelluksen kasvu saavuttaa pisteen, missä tietokantojen määrää kasvatetaan, on hyvä hetki miettiä sovelluksen tietokantarakennetta. Jos suurin osa muutoksista on kyselyjä, voidaan tietokanta toteuttaa siten, että tietokantoja, joihin tehdään kirjoitusoperaatioita on vain muutama, ja loput tietokannoista toimivat <em>read-only</em>-tietokantoina. Sovelluksen kasvaessa tästä isommaksi, voidaan saapua tilanteeseen, missä data jaetaan tietokantojen kesken esimerkiksi ajan perusteella; vanhempi ja vähemmän käytetty data voidaan myös siirtää esimerkiksi edullisempaan tietokantaan.</p>

                <p>Kun tietokantojen määrä kasvaa, on numeeristen tunnusten (esim <code>Long</code>) käyttäminen tunnisteena ongelmallista. Jos tietokantataulussa on numeerinen tunnus, ja useampi tietokanta luo uusia tietokantarivejä, tarvitaan erillinen palvelu tunnusten antamiselle -- tämän palvelun kaatuessa koko sovellus voi kaatua. Toisaalta, jos palvelua ei ole toteutettu oikein, on tunnusten törmäykset mahdollisia, mikä johtaa helposti tiedon katoamiseen sekä tietoturvariskeihin. Yhtenä vaihtoehtona numeerisille tunnuksille on ehdotettu <a href="http://docs.oracle.com/javase/7/docs/api/java/util/UUID.html" target="_blank">UUID</a>-pohjaisia merkkijonotunnuksia, jotka voidaan luoda ennen olion tallentamista tietokantaan.</p>

                <p>Spring Data JPAn tapauksessa tämä tarkoittaa sitä, että <code>AbstractPersistable</code>-luokan periminen ei onnistu kuten ennen. Voimme kuitenkin toteuttaa oman UUIDPersistable-luokan, joka luo tunnuksen automaattisesti. </p>

                <pre class="sh_java">
@MappedSuperclass
public abstract class UUIDPersistable implements Persistable&lt;String&gt; {

    @Id
    private String id;

    public UUIDPersistable() {
        this.id = UUID.randomUUID().toString();
    }

    public String getId() {
        return this.id;
    }

    public void setId(String id) {
        this.id = id;
    }

    @JsonIgnore
    @Override
    public boolean isNew() {
        return false;
    }

    // muuta mahdollista
}</pre>

                <p>Ylläoleva toteutus id-kentän olion luontivaiheessa, jolloin se on käytössä jo ennen olion tallentamista tietokantaan. Rajapinta <a href="http://docs.spring.io/spring-data/data-commons/docs/current/api/org/springframework/data/domain/Persistable.html" target="_blank">Persistable</a> on rajapinta, jota Spring Data -projektit käyttävät olioiden tallennuksessa erilaisiin tietokantoihin.</p>

                <p>Nyt voimme luoda merkkijonotunnusta käyttävän entiteetin seuraavasti:</p>

                <pre class="sh_java">
@Entity
public class Person extends UUIDPersistable {

    private String name;

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }
}</pre>


                <h3>Otsaketiedot</h3>

                <p>Tiedostoja jaettaessa dataa ei kannata siirtää uudestaan jos se on jo käyttäjällä. Voimme määritellä vastauksen otsaketietoihin tietoa datan vanhentumisesta, jonka perusteella selain osaa päätellä milloin näytettävä tieto on vanhentunutta ja se pitäisi hakea uudestaan. Hieman uudempi tapa on <a href="http://en.wikipedia.org/wiki/HTTP_ETag" target="_blank">entiteettitagin</a> käyttö pyynnön vastauksessa. Kun resurssiin liittyvään vastaukseen lisätään ETag-otsake, lähettää selain tiedostoa seuraavalla kerralla haettaessa aiemmin annetun arvon osana <code>"If-None-Match"</code>-otsaketta. Käytännössä palvelimella voidaan tällöin tarkistaa onko tiedosto muuttunut -- jos ei, vastaukseksi riittää pelkkä statuskoodi 304 -- NOT MODIFIED.</p>



                <div class="tehtavat">
                    <div class="tehtava" id="t-imageservice">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-imageservice">
                                    Image Service
                                </a>
                            </h1>
                        </header>

                        <div id="t-imageservice" class="collapse">

                            <p>Tehtäväpohjassa on kuvapalvelu mikä tarjoaa kuvien listauksen ja pienennyksen.</p>

                            <h1>Kuvan lisäämisen muokkaaminen</h1>

                            <p>Tällä hetkellä kuvan lisääminen ohjaa käyttäjän suoraan <code>/images</code>-osoitteeseen, eli palvelun juureen. Muuta sovellusta siten, että käyttäjä ohjataan uuteen osoitteeseen <code>/images/{id}</code>, missä <code>id</code> on juuri luodun kuvan merkkijonoavain. Toteuta myös sopiva kontrolleri, joka toimii yhteistyössä <code>index.html</code>-näkymässä olevan koodin kanssa.</p>

                            <h1>Kuvan hakeminen</h1>

                            <p>Kun käyttäjä hakee kuvaa, tällä hetkellä kuva haetaan aina tietokannasta. Muokkaa kuvien lähettämistä siten, että käyttäjälle palautetaan kuvan mukana myös ETag-otsake, jonka arvoksi on asetettu kyseisen kuvan <code>id</code>-kentän arvo (huom! alkuperäisillä kuvilla ja thumbnaileilla on eri arvot.). Seuraavan kerran kun käyttäjä pyytää samaa kuvaa, hän lähettää pyynnön mukana myös <code>If-None-Match</code>-otsakkeen, joka sisältää aiemmin lähetetyn ETag-otsakkeen arvon.</p>

                            <p>Riippumatta otsakkeen <code>If-None-Match</code> arvosta, palauta vastauksena vain statuskoodi <code>304</code>, eli ei muokattu. Huom! Älä lähetä kuvaa tällöin vastauksessa -- käytä vain statuskoodia.</p>

                        </div>
                    </div>
                </div>



                <aside class="extra">
                    <h1>NoSQL-tietokannat</h1>

                    <p>NoSQL-tietokannoilla viitataan tyypillisesti ei-relaatiomalliin perustuviin tietokantoihin kuten dokumenttitietokantoihin (esim <a href="http://www.mongodb.com/" target="_blank">MongoDB</a>) ja key-value -tietokantoihin (esim <a href="http://redis.io/" target="_blank">Redis</a>). Näiden tietokantojen etuna perinteisiin relaatiotietokantoihin pidetään väitetysti parempaa skaalautuvuutta sekä tehokkuutta. Yksi merkittävistä NoSQL-buumin aloittajista oli Twitterin noin 2010 tekemä <a href="http://www.computerworld.com/s/article/9161078/Twitter_growth_prompts_switch_from_MySQL_to_NoSQL_database" target="_blank">päätös vaihtaa pois relaatiotietokantojen käytöstä</a>; taustasyynä muutokselle oli "relaatiotietokantojen hitaus".</p>

                    <p>Lue edellisen artikkelin jälkeen <a href="http://www.mysql.com/" target="_blank">MySQL</a>:n ja <a href="https://mariadb.org/" target="_blank">MariaDB</a>:n isän Monty Wideniuksen <a href="http://blog.jelastic.com/2013/01/21/are-nosql-and-big-data-just-hype/" target="_blank">näkemys</a> NoSQL-tietokannoista.</p>

                    <p><em>The main reason Twitter had problems with MySQL back then, was that they were using it incorrectly. The strange thing was that the solution they suggested for solving their problems could be done just as easily in MySQL as in Cassandra.</em></p>

                    <p>Twitter on sittemmin palannut myös relaatiotietokantojen käyttöön -- nykyään komponentteja käytetään niille <a href="http://highscalability.com/blog/2011/12/19/how-twitter-stores-250-million-tweets-a-day-using-mysql.html" target="_blank">sopivissa paikoissa</a>.</p>

                    <hr/>

                    <p>Riippumatta debaatista, Spring Data-projekti tarjoaa huomattavaan osaan näistä Spring Data JPA-projektia vastaavan tuen. Käytännössä kurssilla käyttämä ohjelmointityylimme sopii myös NoSQL-tietokantojen käyttöön. Hieman yksinkertaistaen ainoat konkreettiset muutokset liittyvät entiteettiluokkien annotaatioihin sekä <code>JpaRepository</code>-rajapinnan muuttamiseen esimerkiksi <code>MongoRepository</code>-rajapintaan; <a href="http://spring.io/guides/gs/accessing-data-mongodb/" target="_blank">opas</a> alkuun pääsemiseen.</p>

                </aside>


                <h1>Websocketit</h1>

                <p>Silloin tällöin halutaan toteuttaa palveluja, jotka tarjoavat käyttäjälle jatkuvasti uutta tietoa ilman erillistä sivulatausta. Perinteisesti nämä palvelut on toteutettu <a href="http://en.wikipedia.org/wiki/Comet_(programming)" target="_blank">Comet</a>-ohjelmointityylillä, missä sivun latauduttua palvelimelle lähetetään Javascript-pyyntö, mihin palvelin vastaa vasta silloin kun uutta dataa on olemassa. Selain tekee vastauksen käsittelyn jälkeen heti uuden pyynnön. Tämä selaimen ja palvelimen välinen keskustelutyyli on samalla tavoin toimivaa kuin tähän mennessä näkemämme kysymys-vastaus -tyyli -- selain kysyy jotain ja palvelin vastaa jotain.</p>

                <p><a href="http://en.wikipedia.org/wiki/WebSocket" target="_blank">Websocketit</a> ovat tapa toteuttaa tämä kommunikointi siten, että selain rekisteröityy palveluun, jonka jälkeen palvelin voi lähettää selaimelle dataa ilman erillistä pyyntöä. Rekisteröityminen tapahtuu sivulla olevan Javascriptin avulla, jonka jälkeen Javascriptiä käytetään myös palvelimelta tulevan tiedon käsittelyyn.</p>

                <p>Spring tarjoaa myös komponentit Websockettien käyttöön. Tarvitsemme ensiksi riippuvuudet Spring messaging ja Spring boot starter-projekteihin, jonka jälkeen määrittelemme osoitteet, joiden kautta kommunikaatio kulkee.</p>

                <pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-messaging&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>

                <pre class="sh_java">
package wad.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.AbstractWebSocketMessageBrokerConfigurer;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;

@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfiguration extends AbstractWebSocketMessageBrokerConfigurer {

    @Override
    public void configureMessageBroker(MessageBrokerRegistry config) {
        config.enableSimpleBroker("/vastauskanava");
        config.setApplicationDestinationPrefixes("/app");
    }

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/register").withSockJS();
    }
}</pre>

                <p>Ylläolevan konfiguraation oleellisimmat osat ovat annotaatio <code>@EnableWebSocketMessageBroker</code>, joka mahdollistaa websocketien käytön sekä luo viestinvälittäjän. Konfiguraation osa <code>config.enableSimpleBroker("/vastauskanava");</code> luo polun, jota pitkin vastaukset lähetetään käyttäjälle ja <code>config.setApplicationDestinationPrefixes("/app");</code> kertoo että sovelluksen polkuun <code>/app</code> päätyvät viestit ohjataan viestinvälittäjälle. Näiden lisäksi rivi <code>registry.addEndpoint("/register").withSockJS();</code> määrittelee <a href="http://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol" target="_blank">STOMP</a>-protokollalle osoitteen, mitä kautta palveluun voi rekisteröityä. Tässä lisäksi määritellään <a href="https://github.com/sockjs" target="_blank">SockJS</a> fallback-tuki, jota käytetään jos käyttäjän selain ei tue Websocketteja -- STOMP-protokolla on yksi vaihtoehto Websocket-viestinvälitykseen.</p>

                <p>Selainpuolella käyttäjä tarvitsee sekä SockJS- että StompJS-kirjastot. Mainitsimme aiemmin <a href="http://en.wikipedia.org/wiki/Content_delivery_network" target="_blank">CDN</a>-verkostot, joista staattista sisältöä voi hakea. Esimerkiksi <a href="http://cdnjs.com/" target="_blank">CDNJS</a>-palvelu ehdottaa edellämainituille kirjastoille olemassaolevia osoitteita -- kirjastot voi luononllisesti pitää myös osana omaa sovellusta.</p>

                <p>Kokonaisuudessaan selainpuolen toiminnallisuus on esimerkiksi seuraava -- alla body-elementin sisältö:</p>

                <pre class="sh_xml">
&lt;p&gt;&lt;input type="button" onclick="send();" value="Say Wut!"/&gt;&lt;/p&gt;

&lt;script src="//cdnjs.cloudflare.com/ajax/libs/sockjs-client/0.3.4/sockjs.min.js"&gt;&lt;/script&gt;
&lt;script src="//cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"&gt;&lt;/script&gt;
&lt;script&gt;
// luodaan asiakasohjelmisto, joka rekisteröityy osoitteeseen "/register"
var client = Stomp.over(new SockJS('/register'));

// kun käyttäjä painaa sivulla olevaa nappia, lähetetään osoitteeseen
// "/app/messages" viesti "hello world!"
function send() {
    client.send("/app/messages", {}, JSON.stringify({'message': 'hello world!'}));
}

// otetaan yhteys sovellukseen ja kuunnellaan "vastauskanava"-nimistä kanavaa
// -- jos kanavalta tulee viesti, näytetään JavaScript-alert ikkuna
client.connect({}, function (frame) {    
    client.subscribe('vastauskanava', function (response) {
        alert(response);
    });
});

// kun sivu suljetaan, yritetään sulkea yhteys palvelimelle
window.onbeforeunload = function () {
    client.disconnect();
}
&lt;/script&gt;</pre>

                <p>Palvelinpuolella ohjelmistomme toimii esimerkiksi seuraavasti. Kuunnellaan osoitteeseen <code>/messages</code>-tulevia pyyntöjä -- allaoleva esimerkki yrittää muuntaa automaattisesti pyynnössä tulevan JSON-datan <code>Message</code>-olioksi. Toisin kuin aiemmin, käytämme nyt <code>@MessageMapping</code>-annotaatiota, joka on viestinvälityksen vastine <code>@RequestMapping</code>-annotaatiolle.</p>

                <pre class="sh_java">
@Controller
public class MessageController {
    
    // koska konfiguraatiossa määritelty "/app"-juuripoluksi, vastaanottaa
    // tämä kontrollerimetodi osoitteeseen /app/messages tulevat viestit
    @MessageMapping("/messages")
    public void handleMessage(Message message) throws Exception {
        // tee jotain
    }
}</pre>

                <p>Voimme lisäksi toteuttaa esimerkiksi palvelun, joka lähettää viestejä <em>kaikille</em> tiettyyn polkuun rekisteröityneille käyttäjille. Allaoleva palvelu lähettää viestin kerran kymmenessä sekunnissa.</p>

                <pre class="sh_java">
@Service
public class MessageService {

    @Autowired
    private SimpMessagingTemplate template;

    @Scheduled(fixedDelay = 10000)
    public void addMessage() {
        Message message = new Message();
        // aseta viestin sisältö
        this.template.convertAndSend("/vastauskanava", message);
    }
}
                </pre>          

                <p>Yllä käytetty <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/messaging/simp/SimpMessagingTemplate.html" target="_blank">SimpMessagingTemplate</a> on hieman kuin aiemmin käyttämämme RestTemplate, mutta eri käyttötarkoitukseen.</p>



                <div class="tehtavat">
                    <div class="tehtava" id="t-chat2010">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-chat2010">
                                    Chat 2010
                                </a>
                            </h1>
                        </header>

                        <div id="t-chat2010" class="collapse">

                            <p>Huom! Tässä tehtävässä ei ole testejä; palauta tehtävä vasta kun sovelluksesi toimii. Tehtävä on kolmen tehtäväpisteen arvoinen.</p>

                            <p>Tutustu osoitteessa <a href="http://spring.io/guides/gs/messaging-stomp-websocket/" target="_blank">http://spring.io/guides/gs/messaging-stomp-websocket/</a> olevaan oppaaseen.</p>

                            <p>Tässä tehtävässä on hahmoteltu vastaavanlaista chat-palvelua, mutta tässä käyttäjä voi kirjautuessaan valita kanavan, mihin hän kirjoittaa viestejä. Tehtävään on hahmoteltu yksinkertainen kirjautuminen sekä käyttöliittymä, missä on toiminnallisuus yhteyden ottamiseen palvelimelle.</p>

                            <p>Toteuta palvelinpuolelle toiminnallisuus, missä palveluun rekisteröityminen tapahtuu osoitteessa <code>/register</code> ja viestien lähetys tapahtuu osoitteeseen <code>/ws</code>. Tämän lisäksi viestinvälittäjä toimii polussa <code>/channel</code>.</p>

                            <p>Lisää tämän jälkeen viestien lähetystä kuunteleva toiminnallisuus; viestit lähetetään osoitteeseen <code>/ws/messages</code> -- viestin mukana tulee tieto alikanavasta, mihin viesti halutaan ohjata. Esimerkiksi, jos alikanava on "wad", tulee viesti toimittaa osoitteeseen <code>/channel/wad</code>.</p>

                            <p>Kun saat viestien lähettämisen toimimaan, lisää sovellukseen vielä <em>Poliitikko</em>-luokan ilmentymä. Poliitikko lähettää viestejä kanavalla <code>/channel/default</code> kerran kymmenessä sekunnissa. Tutustu annotaatioon <code>@Scheduled</code> tämän toiminnallisuuden saavuttamiseksi.</p>

                        </div>
                    </div>
                </div>


            </section>


            <!-- END WEEK6 -->


            <!-- BEGIN WEEK7 -->





            <section class="weeklimit" data-week-id="7">

                <header>
                    <h1 id="viikko7">Viikko 7</h1>
                </header>

                <h1>Kertaus</h1>

                <p>Kurssin viimeisen viikon teemana on hieman isomman sovelluksen toteuttaminen alusta lähtien. Sovelluksen teemana on miniyhteisöpalvelu, missä käyttäjät näkevät kaveriensa viestejä; kavereiden viesteistä voidaan myös tykätä. Käytämme ulkoasupohjana netistä valmiiksi löytyvää ulkoasua. Tässä tapauksessa ulkoasumme on <a href="http://w3layouts.com/" target="_blank">w3layouts</a>-palvelun tarjoama <a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0 Unported</a>-lisenssillä varustettu <a href="http://w3layouts.com/cyan-flat-ui-kit-responsive-mobile-web-template/" target="_blank">Cyan Flat UI KIT Responsive mobile web template</a>. Käytännössä pohja tarjoaa nipun komponentteja, joita voimme hyödyntää osana sivumme rakentamista. Pohja käyttää myös valmiita Javascript- ja CSS-komponentteja, kuten <a href="http://jquery.com/" target="_blank">jQuery</a> ja <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Termi "responsive" tarkoittaa sitä, että käyttöliittymä mukautuu sitä käyttävän laitteen näytön kokoon.</p>

                <p>Ensimmäinen askel käyttöliittymän käyttöönotossa on valmiin paketin purkaminen siten, että sivun katsominen onnistuu kun palvelin käynnistetään. Ensimmäisessä tehtäväpohjassa tämä on tehty valmiiksi -- sivuun liittyvät erilaiset resurssit kuten Javascript-tiedostot ja kuvat on siirretty kansion <code>static</code>-alle, näkymän linkit on korjattu osoittamaan oikeisiin sijainteihin, ja näkymästä on luotu erillinen tiedosto <code>template.html</code>. Tämän lisäksi palvelinohjelmiston oletuskontrolleri ohjaa käyttäjän näkymään, missä tiedoston <code>template.html</code> sisältö näytetään.</p>

                <p>Koko viikko tehdään tehtäväorientoituneesti; seuraavat tehtäväpohjat sisältävät aina edellisen tehtävän ratkaisun, jolloin voit hypätä joidenkin kohtien yli tarvittaessa. Tehtävissä ei ole testejä; palauta tehtävä aina kun saat sen onnistuneesti valmiiksi.</p>

                <div class="tehtavat">
                    <div class="tehtava" id="t-henkilot-ja-viestit-ex">

                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-henkilot-ja-viestit">
                                    Henkilöt ja viestit
                                </a>
                            </h1>
                        </header>

                        <div id="t-henkilot-ja-viestit" class="collapse">

                            <p>Lisätään tässä sivulle toiminnallisuus viestien listaamiseen ja lähettämiseen. Henkilöiden luomista tai kirjautumista ei vielä toteuteta. Tämä tehtävä on kahden tehtäväpisteen arvoinen. Palauttaessasi tehtävän vakuutat että toteutuksesi toimii tehtävänannon mukaisesti.</p>

                            <img src="img/exercises/w7e01-uml.png"/>

                            <p>Luo tehtävään ylläolevassa UML-kaaviossa kuvatut entiteetit <code>Person</code> ja <code>Post</code>, sekä niille sopivat <code>Repository</code>-rajapinnat. Lisää tämän jälkeen profiiliin <code>DevProfile</code> koodi, jolla saat sovellukseen sovelluksen käynnistyessä muutaman käyttäjän sekä heille viestejä (<code>@PostConstruct</code>-annotaatiosta on tässä hyötyä!).</p>

                            <p>Kun testidata on käytössä, luo <code>template.html</code>-tiedostosta kopio nimeltä <code>index.html</code>. Muokkaa luokkaa <code>DefaultController</code> siten, että pyyntö mihin tahansa osoitteeseen näyttää sivun <code>index.html</code>; lisää modeliin myös 10 uusinta viestiä, uusin ensimmäisenä.</p>

                            <p>Muokkaa tämän jälkeen sivua <code>index.html</code> siten, että viestit näkyvät siinä. Löytänet oikean alueen hakemalla tekstiä <em>"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec dapibus dui id libero auctor cursus."</em>. Kun saat toteutuksen toimimaan, sinun pitäisi nähdä templaten sijaan lisäämäsi tekstit; viestialue voi näyttää esimerkiksi seuraavalta:</p>

                            <p>&nbsp;</p>
                            <img src="img/exercises/w7-post-anonymous-sorted.png"/>
                            <p>&nbsp;</p>

                            <p>Lisää tämän jälkeen erillinen kontrolleri, joka kuuntelee osoitteeseen <code>/posts</code> tulevia POST-tyyppisiä pyyntöjä. Kun kontrolleri vastaanottaa pyynnön, se tallentaa viestin ja ohjaa käyttäjän oletusnäkymään (missä haetaan kymmenen uusinta viestiä). Voit hakea esimerkiksi tietokannasta satunnaisen henkilön viestin lähettäjäksi.</p>

                            <p>Kun POST-pyyntöjä osoitteeseen <code>/posts</code> kuunteleva kontrolleri toimii, muokkaa <code>index.html</code>-tiedostossa olevaa viestikenttää seuraavanlaisesta</p>

                            <p>&nbsp;</p>
                            <img src="img/exercises/w7-post-message-pre.png"/>
                            <p>&nbsp;</p>

                            <p>seuraavanlaiseksi</p>

                            <p>&nbsp;</p>
                            <img src="img/exercises/w7-post-message-post.png"/>
                            <p>&nbsp;</p>

                            <p>Kun laatikkoon kirjoitetaan viesti ja "Let 'Em Know!"-nappia painetaan, tulee viesti lähettää POST-tyyppisellä pyynnöllä osoitteeseen <code>/posts</code>. Huomaa että tarvitset lomakkeen tietojen lähettämiseen -- jos palvelin valittaa jotain CORS-teemaista, varmista, että osa lomakkeesta tehdään Thymeleafin avulla (esim <code>th:action="@{/posts}</code>).</p>

                        </div>
                    </div>

                    <div class="tehtava" id="t-profiilit-ex">

                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-profiilit">
                                    Profiilit
                                </a>
                            </h1>
                        </header>

                        <div id="t-profiilit" class="collapse">

                            <p>Lisätään tässä sivulle toiminnallisuus henkilöiden listaamiseen. Tämä tehtävä on yhden tehtäväpisteen arvoinen. Palauttaessasi tehtävän vakuutat että toteutuksesi toimii tehtävänannon mukaisesti.</p>

                            <img src="img/exercises/w7e02-uml.png"/>

                            <p>Lisää luokalle <code>Person</code> kentät <code>lastUpdated</code> ja <code>slogan</code>. Lastupdated pitää kirjaa viimeisimmästä muutoksesta; slogan taas on -- noh -- henkilön slogan.</p>

                            <p>Muokkaa tämän jälkeen oletuskontrolleria siten, että se lisää 10 viimeksi tietojaan päivittänyttä käyttäjää modeliin. Muokkaa sivua <code>index.html</code> siten, että sivulla oletuksena ollut henkilö "Zach Dunes" vaihtuu käyttäjälistaan.</p>

                            <p>&nbsp;</p>
                            <img src="img/exercises/w7-profiilit-pre.png"/>
                            <p>&nbsp;</p>

                            <p>Kun tehtävä on valmis, sivulla näkyy viimeisimmät käyttäjät ja heidän sloganit.</p>

                            <p>&nbsp;</p>
                            <img src="img/exercises/w7-profiilit-post.png"/>
                            <p>&nbsp;</p>


                        </div>
                    </div>

                    <div class="tehtava" id="t-uusia-henkiloita-ex">

                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-uusia-henkiloita">
                                    Uusia henkilöitä
                                </a>
                            </h1>
                        </header>

                        <div id="t-uusia-henkiloita" class="collapse">

                            <p>Tässä tehtävässä toteutetaan ensimmäinen versio uusien henkilöiden lisäämisestä. Tehtävä on yhden tehtäväpisteen arvoinen.</p>

                            <p>Muokkaa tiedostoa <code>index.html</code> siten, että kopioit nykyisen kirjautumislomakkeen ja luot siitä erillisen "Sign up"-lomakkeen, minkä avulla voi luoda uuden käyttäjän. Lomake voi näyttää esimerkiksi seuraavanlaiselta</p>

                            <p>&nbsp;</p>
                            <img src="img/exercises/w7-sign-up.png"/>
                            <p>&nbsp;</p>


                            <p>Lisää tämän jälkeen sovellukseen erillinen kontrolleri, joka kuuntelee <code>POST</code>-tyyppisiä pyyntöjä osoitteeseen <code>/persons</code>; pyynnön pohjalta luodaan uusi käyttäjä. Muokkaa kontrolleria ja juuri luomaasi lomaketta siten, että niiden avulla voidaan luoda uusia käyttäjiä. Uuden käyttäjän lisäämisen tulee onnistua kirjoittamalla käyttäjän nimi ja slogan; käyttäjien lisäämiseen erikoistunut kontrolleri tallentaa käyttäjän ja ohjaa pyynnön oletuskontrollerille.</p>

                            <p>&nbsp;</p>
                            <img src="img/exercises/w7-signing-up.png"/>
                            <p>&nbsp;</p>


                            <p>&nbsp;</p>
                            <img src="img/exercises/w7-signed-up.png"/>
                            <p>&nbsp;</p>

                        </div>
                    </div>


                    <div class="tehtava" id="t-kirjautuminen-ex">

                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-kirjautuminen">
                                    Kirjautuminen
                                </a>
                            </h1>
                        </header>

                        <div id="t-kirjautuminen" class="collapse">

                            <p>Tässä tehtävässä sovellukseen lisätään autorisointi- ja autentikointitoiminnallisuus. Tämän lisäksi kirjautumissivu ja uuden käyttäjän luomiseen tarkoitettu sivu muokataan erillisiksi sivuiksi, sekä asetetaan viestien lähetys niin, että niillä on oikeat kirjoittajat. Tehtävä on neljän tehtäväpisteen arvoinen -- kun palautat tehtävän, sen tulee toimia kokonaisuudessaan.</p>

                            <img src="img/exercises/w7e04-uml.png"/>

                            <p>Ennen alkua, lisää <code>Person</code>-entiteetille kentät username, password ja salt. Käyttäjätunnuksen tulee olla uniikki.</p>

                            <h1>Sivujen eriyttäminen</h1>

                            <p>Kopioi <code>index.html</code>-tiedostosta kaksi uutta versiota, toisen nimeksi tulee <code>login.html</code> ja toisen nimeksi <code>signup.html</code>. Luo tämän jälkeen oletuskontrolleriin kaksi kontrollerimetodia. Pyyntö osoitteeseen <code>/login</code> näyttää sivun <code>login.html</code>. Pyyntö osoitteeseen <code>/signup</code> näyttää sivun <code>signup.html</code>.</p>

                            <p>Muokkaa sivuja siten, että <code>login.html</code> näyttää seuraavalta:</p>

                            <p>&nbsp;</p>
                            <img src="img/exercises/w7e04-signin.png"/>
                            <p>&nbsp;</p>

                            <p>Kun sivulla klikkaa linkkiä "Sign up now", pääsee osoitetta <code>/signup</code> kuuntelevan kontrollerin kautta sivulle <code>signup.html</code>, joka näyttää seuraavalta:</p>

                            <p>&nbsp;</p>
                            <img src="img/exercises/w7e04-signup.png"/>
                            <p>&nbsp;</p>

                            <p>Kirjautumissivun tulee vieläkin lähettää lomakkeelle syötettävät tiedot palvelimelle.</p>

                            <h1>Tietoturvakonffit</h1>

                            <p>Lue tässä välissä seuraavat sivut <a href="http://www.javacodegeeks.com/2012/08/bcrypt-salt-its-bare-minimum.html" target="_blank">http://www.javacodegeeks.com/2012/08/bcrypt-salt-its-bare-minimum.html</a> ja <a href="http://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/crypto/bcrypt/BCrypt.html" target="_blank">http://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/crypto/bcrypt/BCrypt.html</a>.</p>

                            <p>Muokkaa Person-luokan <code>setPassword</code>-metodi seuraavanlaiseksi:</p>
                            <pre class="sh_java">
    public void setPassword(String password) {
        this.salt = BCrypt.gensalt();
        this.password = BCrypt.hashpw(password, this.salt);
    }</pre>

                            <p>Jos et tiedä mikä ihmeen <code>salt</code> tai miksi ylläoleva tehdään, lue esimerksi Wikipedian artikkeli <a href="http://en.wikipedia.org/wiki/Salt_(cryptography)" target="_blank">Salt (cryptography)</a>.</p>

                            <p>Lisää tämän jälkeen projektiin Spring Security-riippuvuus, ja konfiguroi siihen liittyvä <code>SecurityConfiguration</code>-komponentti seuraavasti:</p>

                            <ul>
                                <li>Kuka tahansa saa tehdä pyynnön osoitteisiin <code>/login</code>, <code>/signup</code> ja <code>/static</code> (sekä kaikkiin sen alla oleviin resursseihin). Kuka tahansa saa myös lähettää POST-tyyppisen pyynnön osoitteeseen <code>/persons</code>.</li>
                                <li>Sovelluksessa on kirjautumislomake, joka on osoitteessa <code>/login</code> -- kun kirjautuminen onnistuu, käyttäjä ohjataan oletuskontrollerin kuuntelemaan osoitteeseen.</p>
                                <li>Sovelluksessa on logout-toiminnallisuus, joka on osoitteessa <code>/logout</code> -- kun kirjautuminen onnistuu, käyttäjä ohjataan <code>/login</code>-osoitteeseen.</p>
                                <li>Kirjautumiseen käytetään alla annettua <code>JpaAuthenticationProvider</code>-luokkaa.</li>
                            </ul>

                            <pre class="sh_java">
@Component
public class JpaAuthenticationProvider implements AuthenticationProvider {

    @Autowired
    private PersonRepository personRepository;

    @Override
    public Authentication authenticate(Authentication a) throws AuthenticationException {
        String username = a.getPrincipal().toString();
        String password = a.getCredentials().toString();

        Person person = personRepository.findByUsername(username);

        if (person == null) {
            throw new AuthenticationException("Unable to authenticate user " + username) {
            };
        }

        if (!BCrypt.hashpw(password, person.getSalt()).equals(person.getPassword())) {
            throw new AuthenticationException("Unable to authenticate user " + username) {
            };
        }

        List&lt;GrantedAuthority&gt; grantedAuths = new ArrayList&lt;&gt;();
        grantedAuths.add(new SimpleGrantedAuthority("USER"));

        return new UsernamePasswordAuthenticationToken(person.getUsername(), password, grantedAuths);
    }

    @Override
    public boolean supports(Class&lt;?&gt; type) {
        return true;
    }
}</pre>                            

                            <p>Nyt sekä kirjautuminen käyttäjänä että käyttäjän luomisen pitäisi toimia.</p>

                            <h1>Uloskirjautuminen</h1>

                            <p>Spring Security olettaa, että uloskirjautumispyynnön mukana annetaan edellisen pyynnön vastaukseen generoitu satunnainen tunnus. Pelkkä GET-pyyntö osoitteeseen <code>/logout</code> ei toimi, sillä haluamme estää mahdollisia <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)" target="_blank">CSRF</a>-hyökkäyksiä.</p>

                            <p>Haluamme kuitenkin että logout-nappi on linkki, joten teemme erillisen piilossa olevan lomakkeen, joka lähetetään linkkiä painamalla.</p>

                            <p>Muokkaa sivun oikeassa ylälaidassa olevaa logout-nappia siten, että se lähettää piilossa generoidun lomakkeen palvelimelle. Allaolevasta koodista lienee sinulle hyötyä.</p>

                            <pre class="sh_java">
&lt;ul class="logout list-unstyled"&gt;
    &lt;li&gt;&lt;a href="#" onclick="document.getElementById('logout-form').submit();"&gt;&lt;span&gt; &lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;form style="visibility: hidden" id ="logout-form" method="post" action="#" th:action="@{/logout}"&gt;&lt;input type="submit" value="Logout"/&gt;&lt;/form&gt;</pre>

                            <p>Nyt myös uloskirjautumisen pitäisi toimia.</p>


                            <h1>Viestien lähetys oikealla nimellä</h1>

                            <p>Kun käyttäjä on sivulla, hän on kirjautunut. Käyttäjätunnukseen pääsee käsiksi <a href="http://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/core/context/SecurityContextHolder.html" target="_blank">SecurityContextHolder</a>-luokan kautta, joka pitää kirjaa kirjautuneesta käyttäjästä. Luokkaa käytetään seuraavasti:</p>

                            <pre class="sh_java">
Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
System.out.println(authentication.getName()); // tulostaa käyttäjätunnuksen</pre>                            

                            <p>Toteuta palvelu, jonka voi injektoida <code>@Autowired</code>-annotaation avulla mihin tahansa sovellukseen, ja jolta saa tällä hetkellä kirjautuneen käyttäjän tiedot <em>Person</em>-oliona.</p>

                            <p>Lisää tämän jälkeen osoitteeseen <code>/posts</code>-tehtäviä pyyntöjä kuuntelevaan kontrolleriin toiminnallisuus, missä uutta viestiä lisättäessä sille lisätään myös oikea kirjoittaja.</p>

                            <p>Nyt kun kirjaudut sovellukseen, voit kirjoittaa viestin siten, että viestin kirjoittajana näkyy käyttäjäsi nimi.</p>
                        </div>
                    </div>



                    <div class="tehtava" id="t-tykkaaminen-ex">

                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-tykkaaminen">
                                    Tykkääminen
                                </a>
                            </h1>
                        </header>

                        <div id="t-tykkaaminen" class="collapse">
                            <p>Tässä tehtävässä lisätään tykkäystoiminnallisuus viesteihin. Tehtävä on kahden tehtäväpisteen arvoinen. Palauta se taas kokonaisuutena.</p>

                            <img src="img/exercises/w7e05-uml.png"/>

                            <p>Muokkaa ensin <code>Post</code>-entiteettiä siten, että sille luodaan satunnaisesti generoitu merkkijonotunnus. Luo tämän jälkeen entiteetti <code>Like</code> (kannattanee nimetä se jotenkin ettei tietokanta hermostu :)), joka kuvaa resurssiin liittyvää tykkäystä. Pidä resurssina merkkijonoa, joka viittaa esimerkiksi postin tunnukseen; jokainen tykkäys liittyy myös käyttäjään.</p>

                            <p>Tee tämän jälkeen kontrolleri, joka kuuntelee POST-tyyppisiä pyyntöjä osoitteeseen <code>/likes</code>. Pyynnön mukana tulee parametri <code>resourceId</code>, joka viittaa tykättävään resurssiin -- lisää myös jokaiseen tykkäykseen <em>nykyinen</em> käyttäjä, jonka saat edellisessä tehtävässä toteutetusta palvelusta. Uudelleenohjaa käyttäjä oletuskontrollerille tykkäyksen lisäämisen jälkeen.</p>

                            <p>Muokkaa tämän jälkeen oletuskontrolleria siten, että tietokannasta haetaan sivulla näytettäviin viesteihin liittyvät tykkäykset. Lisää tykkäykset modelin attribuutiksi nimeltä <code>likes</code> -- tykkäysten tulee olla <code>Map</code>, missä avain on resurssin tunnus ja arvo tykkäysten lukumäärä.</p>

                            <p>Toteuta tämän jälkeen käyttöliittymään <em>viestikohtainen</em> tykkäyslinkki -- alla olevasta koodista lienee hyötyä.</p>

                            <pre class="sh_xml">
&lt;form style="visibility: hidden" th:id="@{like-{id}(id=${post.id})}" method="post" action="#" th:action="@{/likes}"&gt;
    &lt;input type="text" name="resourceId" th:value="${post.id}"&gt;&lt;/input&gt;
    &lt;input type="submit" value="Like"/&gt;
&lt;/form&gt;
&lt;p&gt;
    &lt;a href="#" th:onclick="@{document.getElementById('like-{id}').submit();(id=${post.id})}"&gt;+1 like&lt;/a&gt; 
    &lt;span th:if="${likes[post.id] != null}"&gt;
        &lt;span th:text="${likes[post.id]}"&gt;num&lt;/span&gt; like&lt;span th:if="${likes[post.id] &gt; 1}"&gt;s&lt;/span&gt;
    &lt;/span&gt;
&lt;/p&gt;</pre>

                            <p>Kun tehtävä toimii, sivuilla näkyy tykkäysnapit sekä tehtyjen tykkäysten määrät.</p>

                            <p>&nbsp;</p>
                            <img src="img/exercises/w7e05-likes.png"/>
                            <p>&nbsp;</p>

                            <p>Huom! Jos teet tulevaisuudessa tykkäystoiminnallisuutta, joskus puhdas selainpuolen toteutus on tarpeeksi -- tutustu esimerkiksi <a href="http://socialitejs.com/" target="_blank">SocialiteJS</a>-kirjastoon.</p>

                        </div>
                    </div>


                    <div class="tehtava" id="t-kaverit-ex">

                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-kaverit">
                                    Kaverit
                                </a>
                            </h1>
                        </header>

                        <div id="t-kaverit" class="collapse">
                            <p>Tässä tehtävässä lisätään mahdollisuus kaverien lisäämiseen. Tehtävä on kolmen tehtäväpisteen arvoinen. Palauta se taas kokonaisuutena.</p>

                            <img src="img/exercises/w7e06-uml.png"/>

                            <h1>Entiteetti ja kaveripyynnön lisäys</h1>

                            <p>Luo entiteetti <code>FriendshipRequest</code>, jossa on <code>Person</code>-olio sekä lähteenä että kohteena (source & target). Tämän lisäksi entiteetillä on status, joka voi saada arvot <code>Requested</code>, <code>Accepted</code>, <code>Rejected</code>.</p>

                            <p>Kun entiteetti on olemassa, luo uusi kontrolleri, joka kuuntelee POST-tyyppisiä pyyntöjä osoitteeseen <code>/friends</code>. POST-tyyppinen pyyntö saa parametrina kentän muuttujan <code>personId</code>, joka on sen käyttäjän tunnus, kenelle kaveripyyntö tehdään. Tallenna pyyntö tietokantaan jos tietokannassa ei ole jo samaa pyyntöä tai vastaavaa pyyntöä, siten, että lähde ja kohde ovat vaihtuneet päittäin.</p>

                            <p>Muokkaa vielä käyttöliittymää siten, että käyttäjäprofiili näyttää seuraavalta -- listassa tulee näkyä vain ne käyttäjät, jotka eivät ole nykyisen käyttäjän kavereita.</p>


                            <p>&nbsp;</p>
                            <img src="img/exercises/w7e06-friendem.png"/>
                            <p>&nbsp;</p>

                            <p>Allaolevasta koodista lienee hyötyä.</p>

                            <pre class="sh_xml">
&lt;form method="POST" th:action="@{/friends}"&gt;
    &lt;input type="hidden" name="personId" th:value="${user.id}"/&gt;
    &lt;input type="submit" class="p-btn" value="Friend 'em!"/&gt;
&lt;/form&gt;</pre>


                            <h1>Kaveripyyntöjen näyttäminen</h1>

                            <p>Muokkaa oletuskontrolleria siten, että vastaukseen lisätään niiden kaveripyyntöjen lukumäärä, joiden status on <code>Requested</code> ja kohde nykyinen käyttäjä. Muokkaa tämän jälkeen sivua <code>index.html</code> siten, että sivun oikeassa ylälaidassa näytetään notifikaatio, vain jos käyttäjälle on kaveripyyntöjä.</p> 

                            <p>&nbsp;</p>
                            <img src="img/exercises/w7e06-notif.png"/>
                            <p>&nbsp;</p>
                            
                            <p>Muokkaa notifikaatiota siten, että kun notifikaatiota klikataan, niin käyttäjä tekee GET-pyynnön osoitteeseen <code>/friends</code>.</p>

                            
                            <h1>Kaveripyyntöjen hyväksyminen</h1>

                            <p>Muokkaa <code>/friends</code>-osoitetta kuuntelevaa kontrolleria siten, että se palauttaa käyttäjälle tehdyt kaveripyynnöt ja näyttää sivun <code>friends.html</code></p>

                            <p>Tee tämän jälkeen sivusta <code>index.html</code> kopio <code>friends.html</code> ja muokkaa sitä siten, että se näyttää vain listan käyttäjiä. Muokkaa käyttäjälistaa siten, että jokaiselle käyttäjälle on nappi "Ok! I Like 'im!".</p>
                            
                            <p>&nbsp;</p>
                            <img src="img/exercises/w7e06-notif.png"/>
                            <p>&nbsp;</p>
                            
                            <p>Kun nappia painetaan, käyttäjän pitäisi olla toisen käyttäjän kaveri.</p>
                            
                        </div>
                    </div>
                    
                    
                    <div class="tehtava" id="t-omafeature-ex">

                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-omafeature">
                                    Oma feature
                                </a>
                            </h1>
                        </header>

                        <div id="t-omafeature" class="collapse">
                            <p>Lisää tässä tehtävässä oma feature sovellukseen -- esimerkiksi kuvien lisääminen -- toinen vaihtoehto on myös käyttöliittymän pilkkominen järkevämpiin osiin (fragmenteiksi). Oman toiminnallisuuden tekemisestä saa 3 pistettä. </p>
                        </div>
                    </div>
                </div>

                <p>Kuten huomaat, yhteisöpalvelumme on vielä kaukana valmiista -- ensiaskeleet on kuitenkin tehty. Ennenpitkää sovellus pilkottaisiin pienempiin palasiin, ja sovelluksen toiminta rakennettaisiin niin, että sivulle toteutettava JavaScript-komponentti hakisi sivun sisällön eri komponenteista. Palaamme tähän <em>myöhemmällä kurssilla..</em>.</p>

            </section>

            <!-- END WEEK7 -->




            <!-- BEGIN WEEK2 -->
<!--
            <section class="weeklimit" data-week-id="2">
                <header>
                    <h1 id="viikko2">Viikko 2</h1>
                </header>


            </section>
-->
            <!-- END WEEK2 -->

        </article>

        <footer>
            <p>
                <a id="license" rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.0/"><img alt="Creative Commons License" style="border-width:0; float:left; padding:15px" src="http://i.creativecommons.org/l/by-nc-sa/2.0/88x31.png" /></a>
                <small>T&auml;m&auml; materiaali on lisensoitu Creative Commons BY-NC-SA-lisenssill&auml;, joten voit k&auml;ytt&auml;&auml; ja levitt&auml;&auml; sit&auml; vapaasti, kunhan alkuper&auml;isten tekij&ouml;iden nimi&auml; ei poisteta. Jos teet muutoksia materiaaliin ja haluat levitt&auml;&auml; muunneltua versiota, se t&auml;ytyy lisensoida samanlaisella vapaalla lisenssill&auml;. Materiaalien k&auml;ytt&ouml; kaupalliseen tarkoitukseen on ilman erillist&auml; lupaa kielletty. Tekij&auml;(t): <a href="http://www.cs.helsinki.fi/en/people/avihavai" target="_blank">Arto Vihavainen</a> sekä <a href="http://www.cs.helsinki.fi/en/rage" target="_blank">Agile Education Research</a> -tutkimusryhm&auml;.
            </p>
        </footer>

        <div class="hidden">
            <p>the end.</p>
        </div>


        <script src="js/libs/jquery/jquery.js"></script>
        <script src="js/libs/jqueryui/jquery-ui.js"></script>
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
        <script src="js/libs/syntaxhighlight/sh_main.min.js"></script>

        <script src="js/libs/chartist.min.js"></script>
        <script src="js/libs/visibility.core.js"></script>
        <script src="js/libs/visibility.timers.js"></script>
        <script src="js/libs/visibility.fallback.js"></script>
        <script src="js/js-logger.js"></script>
        <script src="js/verticalfloat.js"></script>
        <script src="js/pheromones.js"></script>
        <script src="js/wepa.js"></script>


    </body>
</html>
